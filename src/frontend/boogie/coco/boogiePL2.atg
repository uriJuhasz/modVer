
/*---------------------------------------------------------------------------
// BoogiePL -
//--------------------------------------------------------------------------*/
#include <vector>
#include <list>
#include <string>
#include <memory>
#include <functional>
#include "frontend/boogie/ParseTree.h"

using namespace frontend::boogie::ParseTree;
using std::vector;
using std::list;
using std::unique_ptr;
using std::string;
using std::function;
using std::make_unique;

COMPILER BoogiePL

/*--------------------------------------------------------------------------*/
Program program;
Parser(const std::basic_string<unsigned char>& buf)
: Parser(new Scanner(buf.c_str(),buf.size())){
	
}
void parse(){
    BoogiePL();
} 

static TextPosition toPos(const Token* t){ return TextPosition(t->line,t->col); } 

static wstring toIdentifier(const wstring& s){
    return s.starts_with('\\') ? s.sub_str(1) : s;
}

bool isLabel() {
  Token* t = la;
  return (la->kind == _ident && scanner->peek()->kind == _colon );
} 

bool isIdColon() {
  Token* t = la;
  return (la->kind == _ident && scanner->peek()->kind == _colon );
} 

bool isBVBound() {
  if (!la->kind != _digits)
    return false;
  if (scanner->peek()->kind != _colon )
    return false;
  if (scanner->peek()->kind != _digits )
    return false;
  return true;
}

typedef function< void(Attributes&&, pIdentifier&&, const Type&, pExpression&&) > ActionAITW;
typedef function< void(              pIdentifier&&, const Type&, pExpression&&) > ActionITW;
typedef function< void(              pIdentifier&&, const Type&               ) > ActionIT;

/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  special = "'~#$^_.?`".
  glyph = "`~!@#$%^&*()-_=+[{]}|;:',<.>/?\\".

  cr        = '\r'.
  lf        = '\n'.
  tab       = '\t'.
  
  space = ' '.
  quote = '"'.

  newLine = cr + lf.
  regularStringChar = ANY - quote - newLine.

  nondigit = letter + special.
  nonquote = letter + digit + space + glyph.

  leftBracket = '['.

$namespace=frontend::boogie::parser

/*------------------------------------------------------------------------*/
TOKENS
  ident =  [ '\\' ] nondigit {nondigit | digit}.
  bvlit = digit {digit} 'b' 'v' digit {digit}.
  digits = digit {digit}.

  colon = ':'.

  string = quote { regularStringChar | "\\\"" } quote.

  decimal = digit {digit} 'e' [ '-' ] digit {digit} .
  dec_float = digit {digit} '.' digit {digit} [ 'e' [ '-' ] digit {digit} ] .
		float = [ '-' ] digit {digit} 'e' [ '-' ] digit {digit} 'f' digit {digit} 'e' digit {digit} 
										| '0' 'N' 'a' 'N' digit {digit} 'e' digit {digit}
										| '0' 'n' 'a' 'n' digit {digit} 'e' digit {digit}
										| '0' '+' 'o' 'o' digit {digit} 'e' digit {digit}
										| '0' '-' 'o' 'o' digit {digit} 'e' digit {digit} .

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab


/*------------------------------------------------------------------------*/
PRODUCTIONS


/*------------------------------------------------------------------------*/
BoogiePL
= (. auto program = make_unique<Program>(); .)
  { ConstantsDef  <. *program .>
  | FunctionDef   <. *program .>
  | AxiomP        <. *program .>
  | TypeDefs      <. *program .>
  | GlobalVarDefs <. *program .>
  | ProcedureP     <. *program .>
  | ImplementationP<. *program .>
  }
  EOF
  .

/*------------------------------------------------------------------------*/
TypeDefs<. Program& prog .>
= (. Attributes attributes; .)
  "type"
  AttributesP<attributes>
        UserDefinedType<. prog, cloneC(attributes) .>
  { "," UserDefinedType<. prog, cloneC(attributes) .> }    
  ";"
  .

UserDefinedType<. Program& prog, Attributes&& attributes .>
= (. pIdentifier id; 
     Identifiers params;
     pType body;
  .)
  Identifier<id>
  [ IdentifiersWS<params> ]
  [ "=" TypeP<body> ]
  (. TypeParameters tParams;
     for (auto& pid : params) tParams.push_back(make_unique<TypeVariable>(move(pid)));
     if (body) prog.addTypeDef(make_unique<TypeSynonymDef>(id,tParams,body));
          else prog.addTypeDef(make_unique<TypeConstructorDef>(id,tParams) ); .)
.

/*------------------------------------------------------------------------*/
ConstantsDef<. Program& scope .>
= (. TextPosition pos; 
     Attributes   attributes;
     bool         unique = false; 
     Identifiers  ids;
     pType        type;
     pConstantOrderSpec orderSpec(new ConstantOrderSpec()); .)
  
  "const"                                   (. pos = toPos(t); .)
  AttributesP<attributes>
  [ "unique"                                (. unique = true;  .) ]
  IdsType<ids,type>
  [ OrderSpec<*orderSpec> ]
  ";"
                                            (.  for (auto& id : ids) 
                                                    scope.addVariableDef(
                                                        make_unique<Constant>(
                                                            pos, 
                                                            cloneC(attributes), 
                                                            move(id), 
                                                            type->clone(),
                                                            unique, 
                                                            orderSpec->clone())); 
                                            .)
  .

OrderSpec<. ConstantOrderSpec& orderSpec.>
= "extends"                                                          (. orderSpec.specified = true; .) 
  [ OrderSpecParent<orderSpec> { ","  OrderSpecParent<orderSpec> } ]
  [ "complete"                                                       (. orderSpec.complete  = true; .) ] 
  .

OrderSpecParent<. ConstantOrderSpec& orderSpec .>
= (. bool unique = false;
     pIdentifier id;  .)
    [ "unique"             (. unique = true; .) ]
    Identifier<id>         (. orderSpec.parents.push_back(ConstantParentSpec(move(id), unique)); .)
.
  
/*------------------------------------------------------------------------*/
GlobalVarDefs<. Scope& scope .>
= (. TextPosition pos;
     Attributes attributes; .)
  "var"                                     (. pos = toPos(t); .)
  AttributesP<attributes>
  IdsTypeWheres<. [&attributes,&scope]
    (pIdentifier&& id, const Type& type, pExpression&& e){
        scope.addVariableDef( make_unique<GlobalVariable>(
            id->pos, cloneC(attributes), move(id), type.clone(), move(e) )); } .> 
  ";"
  .

/*------------------------------------------------------------------------*/
FunctionDef<. Scope& scope .>
= (. TextPosition   pos;
     Attributes     attributes;
     pIdentifier    id;
     TypeParameters typeParams;
     Types          argTypes;
     Identifiers    argNames;
     pType          resultType;
     pExpression    body;
  .)
  "function"                         (. pos=toPos(t); .) 
  AttributesP<attributes> 
  Identifier<id>
  [ TypeParams<typeParams> ]
  "(" [ VarOrTypeArgC<argTypes,argNames> { "," VarOrTypeArgC<argTypes,argNames> } ] ")"
  (   "returns" "(" VarOrTypeAsType<resultType> ")"
    | ":" TypeP<resultType> )
  ( "{" Expression<body> "}" | ";" )
  (. scope.addFunctionDef( make_unique<Function>(
    	pos, 
    	move(attributes), 
    	move(id),
    	move(argTypes),
    	move(resultType),
      move(argNames),
    	move(body)));
    	//Boogie makes func(a,b:T) into func(a:T,b:T) but func(a,b) as func(<anon0>:a,<anon1>:b)
    	//Boogie adds body as axiom if "inline" attribute is present 
        //We ignore the return variable name - not usable anywhere - Boogie has a bug
  .)
.

VarOrTypeAsType<. pType& type .>
  = 
    IF (isIdColon()) ( ident colon TypeP<type> )
    | TypeP<type>
.

VarOrTypeArgC<. Types& args, Identifiers& argNames .>
= (. pType type, pIdentifier id; .)
    VarOrTypeArg<type,id> (. args.push_back(type); argNames.push_back(id); .)
.

VarOrTypeArg<. pType& type, pIdentifier& id .>
= (   ( IF (isIdColon) Identifier<id> ":" TypeP<Type> )
    | (                                   TypeP<Type> ))
.


/*------------------------------------------------------------------------*/
AxiomP<. Program& prog .>
= (. TextPosition pos;
     Attributes attributes; 
     pExpression e; .)
  "axiom"                  (. pos = toPos(t); .)
   AttributesP<attributes>
   Proposition<e> ";"      (. prog.addAxiom(make_unique<Axiom>(pos, move(attributes), move(e))); .)
 .

/*------------------------------------------------------------------------*/
ProcedureP<. Program& prog .>
= (. Attributes     attributes;
     pIdentifier    id;
     pProcSignature sig;
     auto           spec(make_unique<ProcSpec>());
  .)

  "procedure"
  AttributesP<attributes>
  Identifier<id>
  ProcSignature<sig>
  (   ";"  
      { ProcSpecP<*spec> }
    | { ProcSpecP<*spec> }
      ImplBody<. prog, id->clone(), cloneC(attributes), sig->cloneWOWhere(), spec->clone() .>
  )
  (. prog.addProcedure( make_unique<Procedure>(move(id), move(attributes), move(sig), move(spec))); .)
.

ProcSignature<. pProcSignature& sig .>
= (. TypeParams typeParameters;
     Formals formals;.)
  [ TypeParams<typeParameters> ]
              ProcFormals<FormalDir::In,  formals>
  [ "returns" ProcFormals<FormalDir::Out, formals> ]
.

ProcFormals<. FormalDir dir, Formals& formals .>
= "("
  [ AttrsIdsTypeWheres<. [dir,&formals](auto attrs,auto id, auto type, auto e)
      {formals.push_back(make_unique<Formal>(move(attrs),move(id),move(type),move(e),dir));} .> ]
  ")"
.

ProcSpecP<. ProcSpec& spec .>
=   Modifies<spec>
  | SpecPrePost<spec>
.

Modifies<. ProcSpec& spec .>
= (. Identifiers ids .)
  "modifies"
    [ IdentifiersCS<ids>  (. for (auto id : ids) spec.modifies.push_back(make_unique<VariableExpression>(move(id))); .) ]
    ";"
.

SpecPrePost<. ProcSpec& spec .>
= (. TextPosition pos; 
     bool free = false; 
     SpecExpressions* dest;
     Expression e; .)
  ["free"                   (. free=true .)        ]
  (   "requires"            (. dest = &spec.pre;  .)               
    | "ensures"             (. dest = &spec.post; .)
  )                         (. pos = toPos(t);    .)
  AttributesP<attributes>
  Proposition<e> ";"        (. dest.push_back(make_unique<SpecExpression>(pos,free,move(e))); .)
.


ImplementationP<. Program& prog .>
= (. Attributes     attributes;
     pIdentifier    id;
     pProcSignature sig;
     auto           spec(make_unique<ProcSpec>());
  .)

  "implementation"
  AttributesP<attributes>
  Identifier<id>
  ImplSignature<sig>
  { ProcSpecP<*spec> }  
  ImplBody<. prog, move(id), move(attributes), move(sig), move(spec) .>
.

ImplSignature<. pProcSignature& sig .>
= (. TypeParams typeParameters;
     Formals formals;
     .)
  [ TypeParams<typeParameters> ]
              ImplFormals<FormalDir::In,  formals>
  [ "returns" ImplFormals<FormalDir::Out, formals> ]
.

ImplFormals<. FormalDir dir, Formals& formals .>
= "("
  [ IdsTypeS<. [dir,&formals](auto id, auto type)
      {formals.push_back(make_unique<Formal>(move(id),move(type),input));} .> ]
  ")"
.

ImplBody<. Program& prog, pIdentifier&& id, Attributes&& attributes, pProcSignature&& sig, pProcSpec&& spec .>
= (. ScopedBlocks body .) 
  ScopedBlocksP<body>
  (. prog.addImplementation( make_unique<Implementation>(move(id), move(attributes), move(sig), move(spec), move(body))); .)
.

ScopedBlocksP<. ScopedBlocks& bs .>
= "{"
  { LocalVar<bs.locals> }
  StmtList<bs.blocks> //eats up "}"
.


/*------------------------------------------------------------------------*/
BoundVarsP<. BoundVars& vars .>
= (.
    Contract.Requires(x != null);
    Contract.Ensures(Contract.ValueAtReturn(out ds) != null);
    List<TypedIdent>/*!*/ tyds = new List<TypedIdent>();
    ds = new List<Variable>();
    var dsx = ds;
  .)
  AttrsIdsTypeWheres<true, false, "bound variables", delegate(TypedIdent tyd, QKeyValue kv) { dsx.Add(new BoundVariable(tyd.tok, tyd, kv)); } >
  .

/*------------------------------------------------------------------------*/
LocalVar<. Locals& locals .>
= (. Attributes attributes; .)
  "var"
  AttributesP<attributes>
  IdsTypeWheres<. [attributes&,locals&](auto id, auto type, auto e){ 
    locals.push_back(make_unique<LocalVariable>( cloneC(attributes), move(id), type.clone() )) } .> 
  ";"
  .

/*------------------------------------------------------------------------*/
//IdsType variants

IdsTypeS<. ActionIT action .>
  = IdsTypeF<action> { "," IdsTypeF<action> }
.

IdsTypeF<. ActionIT action .>
  = (. Identifiers ids;
       pType type; .)
  IdentifiersCS<ids> ":" TypeP<type> (. for (auto& id : ids) action(move(id),type->clone()); .)
.

IdsType<. Identifiers& ids, pType& type .>
  = IdentifiersCS<ids> ":" TypeP<type>
.

IdsTypeWheres<. ActionITW action .>
	= IdsTypeWhere<action> { "," IdsTypeWhere<action> }
.

IdsTypeWhere<.  ActionITW action .>
= (. vector<pIdentifier> ids;  
     pType               type;  
     pExpression         e; 
  .)
  IdsType<ids,type>
  [ "where" Expression<e>  ]
	  (. for (auto& id : ids)
	       action(move(id), type->clone(), e->clone());
	  .)
  .


AttrsIdsTypeWheres<. ActionAITW action .>
= AttrsIdsTypeWhere<action> { "," AttrsIdsTypeWhere<action> }
.

AttrsIdsTypeWhere<. ActionAITW action .>
= (. Attributes attributes; .)
  AttributesP<attributes>
  IdsTypeWhere<.[&attributes](auto id, auto type, auto e){action(cloneC(attributes),move(id),move(type),move(e));}.>
.

/*------------------------------------------------------------------------*/
//Types
TypeP<. pType& type .>
= (  TypeAtom<type>
  | TypeConstructor<type>
  | MapType<type>)
.

TypeAtom<. pType& type .>
=   "int"              (. type = new BasicType(t, SimpleType.Int); .)
  | "real"             (. type = new BasicType(t, SimpleType.Real); .)
  | "bool"             (. type = new BasicType(t, SimpleType.Bool); .)
  | "(" TypeP<type> ")"
 .

TypeConstructor<. pType& type .>
=(. pIdentifier id;
    Types       args;
 .)
   Identifier<id> [TypeArgs<args>]   (. type = new UnresolvedTypeIdentifier(id, args); .)
.

TypeArgs<. Types types .>
= (. pIdentifier id;
     pType       type;  .)
  (
    ((  TypeAtom<type>    (. types.push_back(move(type)); .)
      | Identifier<id>    (. types.push_back(new UnresolvedTypeIdentifier(id)); .)
    )
    [ TypeArgs<ts> ] )
  | MapType<type>      (. types.push_back(move(type)); .)
  )
  .


MapType<. pType& type .>
= (. TextPosition pos;
     TypeParameters typeParameters;
     vector<pType> arguments;
     pType result;
   .)
  [ TypeParams<typeParameters> ]
  "[" (. pos = t .) [ TypesCS<arguments> ] "]"
  TypeP<result>
  (. type = new MapType(pos, typeParameters, arguments, result); .)
.


TypeC<. Types& types .>
= (. pType t; .)
  TypeP<t>                 (. types.push_back(t); .)
.

TypesCS<. Types& types .>
  = TypeC<types> { "," TypeC<types>}
.

TypeParams<. TypeParameters& typeParams .>
=  (. Identifiers ids; .)
  "<"                         //(.  startToken = t;  .)
    IdentifiersCS<ids>
  ">"                         (. for (auto& id : ids ) typeParams.push_back(make_unique<TypeVariable>(move(id))); .)
  .

/*------------------------------------------------------------------------*/
/* the StmtList also reads the final curly brace */
StmtList<. BlockSeq& bs .>
  = { BigBlock<bs> } "}" 
.

BigBlock<. BlockSeq& bs .>
= (. pLabel label;
     SimpleStatementSeq cmds;
     pComplexStatement  endCmd;
  .)
    ( IF(isLabel())
       Label<label> | () )
    { Cmd<cmds> }
    ( StructuredCmd<endCmd> | TransferCmd<endCmd> )
    (. bs.push_back(make_unique<Block>(label,cmds,endCmd)); .)
.

TransferCmd<. ControlStatementSeq& ss .>
= (. Contract.Ensures(Contract.ValueAtReturn(out tc) != null); tc = dummyTransferCmd;
     Token y;  List<IToken>/*!*/ xs;
     List<String> ss = new List<String>();
  .)
  ( "goto"             (. y = t; .)
    IdentifiersCS<out xs>     (. foreach(IToken/*!*/ s in xs){
                            Contract.Assert(s != null);
                            ss.Add(s.val); }
                          tc = new GotoCmd(y, ss);
                       .)
  | "return"           (. tc = new ReturnCmd(t); .)
  ) ";"
  .

StructuredCmd<. pComplexStatement& cmd .>
= (. Contract.Ensures(Contract.ValueAtReturn(out ec) != null); ec = dummyStructuredCmd;  Contract.Assume(cce.IsPeerConsistent(ec));
     IfCmd/*!*/ ifcmd;  WhileCmd/*!*/ wcmd;  BreakCmd/*!*/ bcmd;
  .)
  ( IfCmd<out ifcmd>    (. ec = ifcmd; .)
  | WhileCmd<out wcmd>  (. ec = wcmd; .)
  | BreakCmd<out bcmd>  (. ec = bcmd; .)
  )
  .

IfCmd<out IfCmd/*!*/ ifcmd>
= (. Contract.Ensures(Contract.ValueAtReturn(out ifcmd) != null); IToken/*!*/ x;
     Expr guard;
     StmtList/*!*/ thn;
     IfCmd/*!*/ elseIf;  IfCmd elseIfOption = null;
     StmtList/*!*/ els;  StmtList elseOption = null;
  .)
  "if"                       (. x = t; .)
  Guard<out guard>
  "{" StmtList<out thn>
  [ "else"
    ( IfCmd<out elseIf>      (. elseIfOption = elseIf; .)
    | "{"
      StmtList<out els>      (. elseOption = els; .)
    )
  ]
  (. ifcmd = new IfCmd(x, guard, thn, elseIfOption, elseOption); .)
  .

WhileCmd<out WhileCmd/*!*/ wcmd>
= (. Contract.Ensures(Contract.ValueAtReturn(out wcmd) != null); IToken/*!*/ x;  Token z;
     Expr guard;  Expr/*!*/ e;  bool isFree;
     List<PredicateCmd/*!*/> invariants = new List<PredicateCmd/*!*/>();
     StmtList/*!*/ body;
     QKeyValue kv = null;
  .)
  "while"             (. x = t; .)
  Guard<out guard>    (. Contract.Assume(guard == null || cce.Owner.None(guard)); .)
  {                   (. isFree = false; z = la/*lookahead token*/; .)
    [ "free"          (. isFree = true;  .)
    ]
    "invariant"
    AttributesP<attributes>
    Expression<out e> (. if (isFree) {
                           invariants.Add(new AssumeCmd(z, e, kv));
                         } else {
                           invariants.Add(new AssertCmd(z, e, kv));
                         }
						 kv = null;
                      .)
    ";"
  }
  "{"
  StmtList<out body>  (. wcmd = new WhileCmd(x, guard, invariants, body); .)
  .

Guard<out Expr e>
= (. Expr/*!*/ ee;  e = null; .)
  "("
  ( "*"                   (. e = null; .)
  | Expression<out ee>    (. e = ee; .)
  )
  ")"
  .

BreakCmd<out BreakCmd/*!*/ bcmd>
= (.Contract.Ensures(Contract.ValueAtReturn(out bcmd) != null); IToken/*!*/ x;  IToken/*!*/ y;
     string breakLabel = null;
  .)
  "break"             (. x = t; .)
  [ Identifier<out y>      (. breakLabel = y.val; .)
  ] ";"               (. bcmd = new BreakCmd(x, breakLabel); .)
  .

/*------------------------------------------------------------------------*/

Cmd<. pCmd& c .>
/* ensures (c == null) != (label != null) */
= (. IToken/*!*/ x; Expr/*!*/ e;
     List<IToken>/*!*/ xs;
     List<IdentifierExpr> ids;
     c = dummyCmd;  label = null;
     Cmd/*!*/ cn;
     QKeyValue kv = null;
  .)
 
//    Label<label>
    AssignCmd<c>
  | PredicateCmd<c>
  | HavocCmd<c>
  | CallCmd<c>
  | ParCallCmd<c>
  | YieldCmd<c>
.
  
PredicateCmd<. pCmd& c .>
= (. TextPosition pos; 
     unique_ptr<Attributes> attributes;
     unique_ptr<Expression> e;
     bool isAssert;
  .)
  (   "assert"                       (. isAssert=true;      .) 
    | "assume"                       (. isAssert=false;     .)
  )                                  (. pos = toTextPos(t); .)
  AttributesP<attributes>
  Proposition<out e>    
  ";"                                 (. c = isAssert ? new AssertCmd(pos, attributes, e) : new AssumeCmd(pos, attributes, e); .)
.

HavocCmd<. unique_ptr<Cmd>& c .>
= (. TextPosition pos;
     list<unique_ptr<Identifier>> ids 
  .)
  "havoc"               (. pos = t; .)
  IdentifiersCS<ids> ";"  (. c = new HavocCmd(x,ids); .)
  .

YieldCmd<. unique_ptr<Cmd>& c .>
= (. TextPosition pos; .)
  "yield"               (. pos = t; .)
  ";"                   (. c = new YieldCmd(pos); .)
  .

/*------------------------------------------------------------------------*/

Label<. unique_ptr<Label>& label .>
= (. unique_ptr<Identifier> id; .)
  Identifier<out id> ":" (. label = new Label(id); .)
  .

AssignCmd<. unique_ptr<Cmd>& cmd .>
= (. list<unique_ptr<AssignLHS>> lhss;
     list<unique_ptr<Expression>> rhss;
     TextPosition pos;                   
  .)
    AssignLHS<lhss> { "," AssignLHS<lhss> }
    ":="                                   (. pos = toTextPos(t); .)
    ExpressionCS<rhss>
    ";"                                    (. cmd new AssignCmd(pos, lhss, rhss); .)
.

AssignLHS<. list<unique_ptr<AssignLHS>>& lhss .>
= (. unique_ptr<Identifier> id; 
     unique_ptr<AssignLHS> lhs;
  .)
    Identifier<id>         (. lhs = new SimpleAssignLhs(move(id)); .)
    { MapAssignIndex<lhs> }
    (. lhss.Add(lhs); .)
    .

MapAssignIndex<. unique_ptr<AssignLHS>& lhs .>
= (. TextPosition pos;
     list<unique_ptr<Expression>> indices;
     Expr e;
  .)
  "["                          (. pos = toTextPos(t); .)
    [ ExpressionCS<indices> ]
  "]"                          (. lhs = new MapAssignLhs(pos, lhs, indices); .)
  .

/*------------------------------------------------------------------------*/
CallCmd<out Cmd c>
= (. Contract.Ensures(Contract.ValueAtReturn(out c) != null); 
     IToken x; 
     bool isAsync = false;
     bool isFree = false;
     QKeyValue kv = null;
     c = null;
  .)
  [ "async"          (. isAsync = true;  .)
  ]
  [ "free"          (. isFree = true;  .)
  ]
  "call"                          (. x = t; .)
  AttributesP<attributes>
  CallParams<isAsync, isFree, kv, x, out c> (. .)
  .

ParCallCmd<out Cmd d>
= (. Contract.Ensures(Contract.ValueAtReturn(out d) != null); 
     IToken x; 
     QKeyValue kv = null;
	 Cmd c = null;
     List<CallCmd> callCmds = new List<CallCmd>();
  .)
  "par"                          (. x = t; .)
  AttributesP<attributes>
  CallParams<false, false, kv, x, out c> (. callCmds.Add((CallCmd)c); .) 
  { "|" CallParams<false, false, kv, x, out c> (. callCmds.Add((CallCmd)c); .) 
  }
  ";" (. d = new ParCallCmd(x, callCmds, kv); .)
  .

CallParams<bool isAsync, bool isFree, QKeyValue kv, IToken x, out Cmd c>
= (. 
    List<IdentifierExpr> ids = new List<IdentifierExpr>();
    List<Expr> es = new List<Expr>();
    Expr en;
    IToken first; 
    IToken p;
	c = null;
  .)
  Identifier<out first>
    ( "("
      [ Expression<out en>       (. es.Add(en); .)
        { "," Expression<out en> (. es.Add(en); .)
        }
      ]
      ")"                         (. c = new CallCmd(x, first.val, es, ids, kv); ((CallCmd) c).IsFree = isFree; ((CallCmd) c).IsAsync = isAsync; .)
    |
                                  (. ids.Add(new IdentifierExpr(first, first.val)); .)
      [ "," Identifier<out p>  (. ids.Add(new IdentifierExpr(p, p.val)); .)
        { "," Identifier<out p>  (. ids.Add(new IdentifierExpr(p, p.val)); .)
        }
      ] ":="
      Identifier<out first> "("
      [ Expression<out en>       (. es.Add(en); .)
        { "," Expression<out en> (. es.Add(en); .)
        }
      ]
      ")"                         (. c = new CallCmd(x, first.val, es, ids, kv); ((CallCmd) c).IsFree = isFree; ((CallCmd) c).IsAsync = isAsync; .)
    )
  .

/*------------------------------------------------------------------------*/
//Identifiers
IdentifiersCS<. Identifiers& ids .>
  =  IdentifierC<ids> { "," IdentifierC<id> }
.

IdentifiersWS<. Identifiers& ids .>
  = IdentifierC<ids> { IdentifierC<ids> }
.

IdentifierC<. Identifiers& ids .>
= (. pIdentifier id; .)
  Identifier<id> (. ids.push_back(move(id)); .)
.

/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
//Expressions
Proposition<. pExpression& e .>
  = Expression<e>
.

ExpressionCS<. Expressions& es.>
= ExpressionC<e> { "," ExpressionC<e> }
.

ExpressionC<. Expressions& es.>
= (. pExpression e .)
  Expression<e> (. es.push_back(e) .)
.

Expression<. pExpression& e .>
= 
    (IF (isUnaryITEExpression()) UnaryITEExpression<e> )
  | ( ImpliesExpression<false, e> { ExpressionR<e> } )
.

ExpressionR<. pExpression& e0 .>
= (. TextPosition pos; 
     unique_ptr<Expression> e1 .)
  EquivOp                       (. pos = t; .)
  ImpliesExpression<false, e1>  (. e0 = new Expression( pos, Operator.iff(), e0, e1 ) .)
  .

EquivOp = "<==>" | '\u21d4'.


/*------------------------------------------------------------------------*/
ImpliesExpression<. pExpression& e0 .>
// = "ab" LogicalExpression<e0> "ba".
= (. TextPosition pos;
     pExpression e1; .)
  LogicalExpression<e0>
  [ ImpliesExpressionR<e0> | ExpliesExpressionR<e0> ]
.

ImpliesExpressionR<. pExpression& e0 .>
=   (. TextPos p;
       pExpression e1; .)
    /* recurse because implication is right-associative */
    ImpliesOp               (. pos = toPos(t); .)
    ImpliesExpressionRR<e1> (. e0 = Expression::make(Operation::Implies, e0, e1); .)
.

ImpliesExpressionRR<. pExpression& e1 .>
=   LogicalExpression<e1>      
    [ ImpliesExpressionR<e1> ] 
.

ImpliesOp = "==>" | '\u21d2'.

ExpliesExpressionR<. pExpression& e0 .>
= ExpliesExpressionRR<e0> { ExpliesExpressionRR<e0> }
.

ExpliesExpressionRR<. pExpression& e0 .>
=(. TextPos p;
    pExpression e1; .)
  ExpliesOp               (. pos = toPos(t) .)
  LogicalExpression<e1>   (. e0 = Expression::make(Operation::Explies, e0, e1); .)
.

ExpliesOp = "<==" | '\u21d0'.

/*------------------------------------------------------------------------*/
LogicalExpression<pExpression& e>
= RelationalExpression<e> 
  [ LogicalExpressionAnd<e> | LogicalExpressionOr<e> ]
.

LogicalExpressionAnd<pExpression& e>
  = LogicalExpressionAndR<e> { LogicalExpressionAndR<e> }
.

LogicalExpressionAndR<pExpression& e0>
  = (. TextPos p;
       pExpression e1; .)
  AndOp                    (. pos = toPos(t); .)
  RelationalExpression<e1> (. e0 = Expression::make(Operation::And,e0,e1); .)
.

LogicalExpressionOr<pExpression& e>
  = LogicalExpressionOrR<e> { LogicalExpressionOrR<e> }
.

LogicalExpressionOrR<pExpression& e0>
  = (. TextPos p;
       pExpression e1; .)
  OrOp                     (. pos = toPos(t); .)
  RelationalExpression<e1> (. e0 = Expression::make(Operation::Or,e0,e1); .)
.


AndOp = "&&" | '\u2227'.
OrOp = "||" | '\u2228'.

/*------------------------------------------------------------------------*/
RelationalExpression<. pExpression& e0 .>
= (. TextPosition pos;
     pOperation op;
     pExpression e1 .)
  BvTerm<e0>
  [ RelOp<pos,op> BvTerm<e1>            (. e0 = Expression::make(pos,op,e0,e1); .)  ]
.

RelOp<. TextPosition& pos, pOperation& op .>
=                  
  ( "=="               (. op = Operation::Eq; .)
  | "<"                (. op = Operation::LT; .)
  | ">"                (. op = Operation::GT; .)
  | ( "<=" | '\u2264') (. op = Operation::LE; .)
  | ( ">=" | '\u2265') (. op = Operation::GE; .)
  | ("!=" | '\u2260')  (. op = Operation::NE; .)
  | "<:"               (. op = Operation::Subtype; .)
  ) (. pos = topPos(t) .)
 .

/*------------------------------------------------------------------------*/
BvTerm<. pExpression& e0 .>
= (. TextPosition pos; .)
  Term<e0>
  { "++"                  (. pos = toPos(t); pExpression e1; .)
    Term<e1>              (. e0 = Expression::make(pos, Operation::BVConcat, e0, e1); .)
  }
.


/*------------------------------------------------------------------------*/
Term<. pExpression& e0 .>
= (. TextPosition pos; pExpression e1; .)
  Factor<e0>
  { AddOp<x, op>
    Factor<e1>      (. e0 = Expr.Binary(x, op, e0, e1); .)
  }
.

AddOp<. TextPosition& pos, pOperation& op .>
=                  
  ( "+"            (. op = Operation::Add; .)
  | "-"            (. op = Operation::Sub; .)
  )                (. pos = toPos(t) .)
  .

/*------------------------------------------------------------------------*/
Factor<. pExpression& e0 .>
= (. TextPosition pos; Operation op; pExpression e1; .)
  Power<e0>
  { MulOp<pos, op> Power<e1> (. e0 = Expr.Binary(x, op, e0, e1); .) }
.

MulOp<. TextPosition& pos, Operation& op .>
=                  
  ( "*"            (. op = Operation::Mul; .)
  | "div"          (. op = Operation::Div; .)
  | "mod"          (. op = Operation::Mod; .)
  | "/"            (. op = Operation::DivR; .)
  )                (. pos = toPos(t) .)
.

/*------------------------------------------------------------------------*/
Power<. pExpression& e0 .>
=  (. TextPosition pos; pExpression e1; .)
  UnaryExpression<e0>
  [ /* recurse because exponentation is right-associative */
    "**"           (. pos = toPos(t); .)
    Power<e1>      (. e0 = Expression::make(pos, Operation::Pow, e0, e1); .)
  ]
  .

/*------------------------------------------------------------------------*/
UnaryExpression<. pExpression& e .>
= (. TextPosition pos; Operation op; .)
    UnaryOp<pos,op> UnaryExpression<e>  (. e = Expression.make(pos,op,e); .)
  | CoercionExpression<e>
.

UnaryITEExpression<. pExpression& e .>
= (. TextPosition pos; Operation op; .)
    UnaryOp<pos,op> UnaryITEExpression<e>  (. e = Expression.make(pos,op,e); .)
  | IfThenElseExpression<e>
.

UnaryOp<. TextPosition& pos, Operation& op .>
=                  
  ( "-"                (. op = Operation::Minus; .)
  | ( "!" | '\u00ac' ) (. op = Operation::Negate; .)
  )                    (. pos = toPos(t) .)
.

/*------------------------------------------------------------------------*/

/* This production creates ambiguities, because types can start with "<"
   (polymorphic map types), but can also be followed by "<" (inequalities).
   Coco deals with these ambiguities in a reasonable way by preferring to read
   further types (type arguments) over relational symbols. E.g., "5 : C < 0"
   will cause a parse error because "<" is treated as the beginning of a
   map type. */

CoercionExpression<. pExpression& e .>
= (. TextPosition pos;
     pType type;
    .)
  ArrayExpression<e> 
  { ":" (. pos = toPos(t); .) TypeP<type> (. e = Expression::makeCast(pos,e,t); .) }
.

/*------------------------------------------------------------------------*/
ArrayExpression<. pExpression& e .>
= AtomExpression<e>
  { ArrayExpressionR<e> }
.

ArrayExpressionR<. pExpression& e .>
= "["        (. TextPosition pos = toPos(t); .)
      [   IF (isBVBound()) BvBoundP<pos,e>
        | MapReadOrWrite<pos,e> 
      ]
  "]"
.

MapReadOrWrite<. TextPosition pos, pExpressions& e .>
= (. Expressions  args;
     Operation    op = Operation::MapRead; 
  .)
  ( ( ExpressionCS<args> [ MapWrite<op,args> ] )
    | MapWrite<op,args> 
  )                                               (. e = Expression::make(pos,op,args); .)
.
        
MapWrite<. Operation& op, Expressions& es .>
  =  ":=" ExpressionC<args> (. op = Operation::MapWrite; .)
.

BvBoundP<. TextPosition pos, pExpressions& e .>
= (. pExpression& l,h; .)
  NatE<l> ":" NatE<h> (. e = Expression::make(pos, Operation::BVSelect, l, h ); .)
.

/*------------------------------------------------------------------------*/
AtomExpression<. pExpression& e .>
=   LiteralExpression<e>
  | FAExpression<e>
  | OldExpression<e>
  | CastExpression<e>
  | BinderOrParenExpression<e>
//  | IfThenElseExpression<e>
  | CodeExpression<e>
.

LiteralExpression<. pExpression& e .>
=   BooleanLiteralExpression<e>
  | NatE<e>
  | Dec<e>            
  | FloatE<e>
  | BvLit<e>
.

BooleanLiteralExpression<. pExpression& e .>
=   "false"           (. e = new LiteralExpression(toPos(t), false); .)
  | "true"            (. e = new LiteralExpression(toPos(t), true); .)
.
FAExpression<. pExpression& e .>
= (. Expressions args;
     pIdentifierExpression ide;
     pIdentifier id; 
  .)
  IdentifierExpression<ide>    (. id = ide->identifier->clone(); e = move(ide) .)
    [ "(" ExpressionCS<args> ")"  (. e = new FAExpression(e.pos, new FunctionCall(id), move(args)); .) ]
.

OldExpression<. pExpression& e .>
= (.  TextPosition pos; .)
  "old"                    (. pos = toPos(t); .)
    "(" Expression<e> ")"    (. e = new OldExpression(pos, e); .)
.

BinderOrParenExpression<. pExpression& e .>
= (. TextPosition pos;
     Binder b;
  .)
  "(" 
        Expression<e>                 (. if (e is BvBounds) this.SemErr("parentheses around bitvector bounds are not allowed"); .)
      | ( Binder<pos,binder> QuantifierBody<pos,binder,e> )
   ")"
.

Binder<. TextPosition& pos, Binder& binder .>
=
      Forall                            (. binder = Binder::forall; .)
    | Exists                            (. binder = Binder::exists; .)
    | Lambda                            (. binder = Binder::lambda; .)
                                        (. pos = toPos(t); .)
.

QuantifierBody<. TextPosition pos, Binder binder, pExpression& e .>
= (. TextPosition pos2;
     TypeParameters  typeVars;
     BoundVars       vars;
     Attributes      attributes;
     Triggers        triggers;
     pExpression     ie;                 .)
  (
    (   TypeParams<typeVars> [ BoundVarsP<vars> ]
      | BoundVarsP<vars> )
    QSep
    AttributesAndTriggers<attributes,triggers>
    Expression<ie>
  ) (. e = new BinderExpression(pos, binder, move(attributes), move(triggers), move(typeVars), move(vars), move(ie)); .)
  .

Forall = "forall" | '\u2200'.
Exists = "exists" | '\u2203'.
Lambda = "lambda" | '\u03bb'.
QSep = "::" | '\u2022'.


CastExpression<. unique_ptr<Expression>& e .>
= (. unique_ptr<Function>   func;.)
    ("int" |               (. func = new ArithmeticCoercion(toPos(t), ArithmeticCoercion.CoercionType.ToInt)  .)
     "real"                (. func = new ArithmeticCoercion(toPos(t), ArithmeticCoercion.CoercionType.ToReal) .) )
  "(" Expression<e> ")"    (. e = new FAExpression(func.pos, func, e); .)
.


CodeExpression<. unique_ptr<Expression>& e .>
= (. TextPosition pos;
     Locals locals;
     list<Block>    blocks;   .)
  "|{"   (. pos = toPos(t); .)
    { LocalVar<locals> } SpecBlock<blocks> { SpecBlock<blocks> } 
  "}|" (. e = new CodeExpression(pos, locals, blocks); .)
  .

SpecBlock<. list<Block>& blocks .>
= (. unique_ptr<Identifier> id;
     list<unique_ptr<Cmd>> commands;
     TextPosition pos2;
     list<unique_ptr<Identifier>> nexts;
     unique_ptr<Block> b;


     IToken label;
     List<Cmd> cs = new List<Cmd>();
     List<IToken>/*!*/ xs;
     List<String> ss = new List<String>();
     b = dummyBlock;
     Expr/*!*/ e;
  .)
  Identifier<id> ":"
  { Cmd<cs> }
  ( "goto"                      (. pos2 = toPos(t); .)
    IdentifiersCS<nexts>          (. b = new Block(id, cs, new GotoCmd(pos2,nexts)) .)
  | "return"                    (. pos2 = toPos(t); .)
    Expression<out e>           (. b = new Block(id, cs, new ReturnExprCmd(pos2,e)); .)
  ) (. blocks.push_back(move(b)) .)
  ";"
  .

AttributesP<. Attributes& attributes .>
= 
  { "{" AttributeI<attributes> "}" }
.

AttributesAndTriggers<. unique_ptr<Attributes>& attributes, unique_ptr<Triggers> triggers .>
= (. attributes = new Attributes(); triggers = new Triggers() .)
  { "{" (AttributeI<*attributes> | TriggerI<*triggers>) "}" }
.

TriggerI<. Triggers& triggers .> 
= (. unique_ptr<Trigger> trigger = new Trigger() .)
    ExpressionCS<trigger.expressions> (. triggers.push_back(move(trigger)); .)
.

AttributeI<. Attributes& attributes .> 
= (. pAttribute attribute(make_unique<Attribute>()) .)
    ":" Identifier<attribute.id>                     
        [       AttributeParameter<attribute.params>
          { "," AttributeParameter<attribute.params> }
        ]       (. attributes.push_back(move(attribute)).)
.  //Boogie takes { :nopats Expression } as a dis-unification constraint

AttributeParameter<. list<unique_ptr<AttributeParam>>& params .>
= (. unique_ptr<Expression> e; .)
  ( string            (. params.push_back(new     StringAttributeParam( t, t.val.sub_string(1, t.val.Length-2) ); .)
  | Expression<e>     (. params.push_back(new ExpressionAttributeParam( e )); .)
  )
.

IfThenElseExpression<. unique_ptr<Expression>& e .>
= (. Token tok;
     unique_ptr<Expression> e0, e1, e2; .)
  "if" (. tok = t; .) Expression<e0> "then" Expression<e1> "else" Expression<e2>
  (. e = new FAExpression(tok, new IfThenElse(tok), new List<Expr>{ e0, e1, e2 }); .)
.



/*------------------------------------------------------------------------*/
IdentifierExpression<. unique_ptr<Expression>& e .> = 
    (. unique_ptr<Identifier> id .)
    Identifier< id >  (. e = new IdentifierExpression(id); .)
.

Identifier<. pIdentifier& id .> = 
    ident (. id = make_unique<Identifier>(toPos(t),toIdentifier(t->val)); .)
.

/*------------------------------------------------------------------------*/
NatE<. pExpression& e .>
= (. TextPosition pos; Integer n; .)
  Nat<pos,n>  (. e = make_unique<LiteralExpression>(pos,n); .)
  .

Nat<. TextPosition& pos, Integer& n .>
=
  digits
  (. try {
       n = Integer(t.val);
     } catch (std::runtime_exception&) {
       this.SemErr("incorrectly formatted number");
       n = 0;
     }
  .)
  .

/*------------------------------------------------------------------------*/
Dec<. unique_ptr<LiteralExpression>& le .>
= (. string s = ""; .)
  (   decimal     (. s = t.val; .)
    | dec_float   (. s = t.val; .)
  )
  (. try {
       n = BigDec.FromString(s);
     } catch (FormatException) {
       this.SemErr("incorrectly formatted number");
       n = BigDec.ZERO;
     }
  .)
  .

/*------------------------------------------------------------------------*/
BvLit<. unique_ptr<LiteralExpression>& le .>
=
  bvlit
  (.
     string s = t.val;
     auto pos = s.find("bv");
     assert(pos>=0);
     string a = s.substring(0,pos);
     string b = s.substring(pos + 2);
     Integer n;
     try {
       n = Integer(a);
       m = Integer(b);
     } catch (std::runtime_exception& ) {
       this.SemErr("incorrectly formatted bitvector");
       n = 0;
       m = 0;
     }
    le = new LiteralExpression(toTextPos(t), new BitVectorLiteral(n,m));
  .)
  .

FloatE<. unique_ptr<LiteralExpression>& le .> = 
(. Rational r; TextPosition pos .)
Float<r> (. return new LiteralExpression(pos,r); .)
.

Float<. Rational& r, TextPosition& pos .>
= (. string s = ""; .)
  (
    float   (. s = t.val; pos = toTextPos(t); .)
  )
  (. try {
       r = Rational(s);
     } catch (std::runtime_exception& e) {
       this.SemErr("incorrectly formatted floating point, " + e.Message);
       r = 0;
     }
  .)
  .

END BoogiePL.
