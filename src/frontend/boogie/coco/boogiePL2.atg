
/*---------------------------------------------------------------------------
// BoogiePL -
//--------------------------------------------------------------------------*/
#include <vector>
#include <list>
#include <string>
#include <memory>
#include "frontend/boogie/AST.h"

using namespace frontend::boogie::AST;
using std::vector;
using std::list;
using std::unique_ptr;
using std::string;

COMPILER BoogiePL

/*--------------------------------------------------------------------------*/
Program program;
Parser(const std::basic_string<unsigned char>& buf)
: Parser(new Scanner(buf.c_str(),buf.size())){
	
}
void parse(){
	BoogiePL();
} 

static TextPosition toTextPos(const Token& t){ return TextPosition(t.line,t.col); } 

static string toIdentifier(const string& s){
    return s.starts_with('\\') ? s.sub_str(1) : s;
}



/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  special = "'~#$^_.?`".
  glyph = "`~!@#$%^&*()-_=+[{]}|;:',<.>/?\\".

  cr        = '\r'.
  lf        = '\n'.
  tab       = '\t'.
  
  space = ' '.
  quote = '"'.

  newLine = cr + lf.
  regularStringChar = ANY - quote - newLine.

  nondigit = letter + special.
  nonquote = letter + digit + space + glyph.

$namespace=frontend::boogie::parser

/*------------------------------------------------------------------------*/
TOKENS
  ident =  [ '\\' ] nondigit {nondigit | digit}.
  bvlit = digit {digit} 'b' 'v' digit {digit}.
  digits = digit {digit}.

  string = quote { regularStringChar | "\\\"" } quote.

  decimal = digit {digit} 'e' [ '-' ] digit {digit} .
  dec_float = digit {digit} '.' digit {digit} [ 'e' [ '-' ] digit {digit} ] .
		float = [ '-' ] digit {digit} 'e' [ '-' ] digit {digit} 'f' digit {digit} 'e' digit {digit} 
										| '0' 'N' 'a' 'N' digit {digit} 'e' digit {digit}
										| '0' 'n' 'a' 'n' digit {digit} 'e' digit {digit}
										| '0' '+' 'o' 'o' digit {digit} 'e' digit {digit}
										| '0' '-' 'o' 'o' digit {digit} 'e' digit {digit} .

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab


/*------------------------------------------------------------------------*/
PRODUCTIONS


/*------------------------------------------------------------------------*/
BoogiePL
= { ConstantsDef  <. program .>
  | FunctionDef   <. program .>
  | Axiom         <. program .>
  | TypeDefs      <. program .>
  | GlobalVarDefs <. program .>
  | Procedure     <. program .>
  | Implementation<. program .>
  }
  EOF
  .

/*------------------------------------------------------------------------*/
ConstantsDef<. AST::Scope& scope .>
= (. TextPosition pos; 
     bool unique = false; 
     vector<AST::Identifier> ids;
     unique_ptr<AST::Type> type;
     unique_ptr<AST::Attributes> attributes;
     unique_ptr<AST::ConstantOrderSpec> orderSpec = new ConstantOrderSpec();
  .)
  
  "const"                                   (. pos = toTextPos(*t); .)
  { Attributes<attributes> }
  [ "unique"                                (. unique = true;  .) ]
  Identifiers<ids> ":" Type<type>
  [ OrderSpec<orderSpec> ]
  (.  for (const auto& id : ids) 
  			scope.addVariableDef(
  				new AST::Constant(
                                    pos, 
                                    attributes->clone(), 
                                    id, 
                                    type->clone(),
                                    unique, 
                                    orderSpec->clone()); 
  .)
  ";"
  .


OrderSpec<. unique_ptr<ConstantOrderSpec>& orderSpec.>
= "extends"                                                          (. orderSpec->specified = true; .) 
  [ OrderSpecParent<orderSpec> { ","  OrderSpecParent<orderSpec> } ]
  [ "complete"                                                       (. orderSpec->ChildrenComplete = true; .) ] 
  .


OrderSpecParent<. ConstantOrderSpec& orderSpec .>
= (. bool unique = false;  .)
    [ "unique"             (. unique = true; .) ]
    ident                  (. orderSpec.parents.push_back(new ConstantParent (new IdentifierExpression(t, t.val), unique)); .)
	.
  
/*------------------------------------------------------------------------*/
GlobalVarDefs<. Scope& scope .>
= (. unique_ptr<AST::Attributes> attributes; .)
  "var"
  { Attributes<attributes> }
  IdsTypeWheres<. [attributes&,scope&]{TypedIdentifier tid => scope.addVariableDef( new AST::GlobalVariable(tid, attributes)) } .> ";"
  .

IdsTypeWheres<. void action(unique_ptr<TypedIdentifier>) .>
	= IdsTypeWhere<action> { "," IdsTypeWhere<action> }.

/* context is allowed to be null if allowWhereClauses is true */
IdsTypeWhere<. void action(unique_ptr<TypedIdentifier>) .>
  =                                 (. list<Identifier> ids;  
                                       unique_ptr<Type> type;  
                                       unique_ptr<Expression> whereExp; .)
  Identifiers<ids> ":" Type<type>
  [ "where" Expression<whereExp>  ]
	  (. for (auto& id : ids)
	       action(new TypedIdentifier(id, id.val, type, whereExp ? whereExp->clone() : nullptr));
	  .)
  .

/*------------------------------------------------------------------------*/
FunctionDef<. Scope& scope .>
= (. Token idToken;
     Token typeParamToken;
     unique_ptr<TypeParameters> typeParams;
     unique_ptr<list<Variable>> arguments;
     unique_ptr<TypedIdentifier> tid;
     unique_ptr<TypedIdentifier> returnTID = null;
     QKeyValue argKv = null;
     unique_ptr<Attributes> attributes;
     unique_ptr<Expression> body = null;
  .)
  "function" { Attributes<attributes> } Identifier<idToken>
  [ TypeParams<typeParamToken, typeParams> ]
  "(" [ VarOrType<arguments> { "," VarOrType<arguments> } ] ")"
  (
    "returns" "(" VarOrType<returnTID> ")"
    |
    ":" TypeAsNameless<returnTID>   
  )
  ( "{" Expression<body> "}" | ";" )
  (.

    scope.addFunctionDef(new FunctionDef(
    	toTextPos(idToken), 
    	attributes, 
    	new IdentifierExpression(idToken, idToken.val),
    	arguments,
    	returnTid,
    	body));
    	//Boogie makes func(a,b:T) into func(a:T,b:T) but func(a,b) as func(<anon0>:a,<anon1>:b)
    	//Boogie adds body as axiom if "inline" attribute is present 
  .)
  .

TypeAsNameless<. unique_ptr<Variable>& var .>
= (. unique_ptr<Type> type; .)
Type<type> (. var = new Variable(move(type)) .)
.

/*------------------------------------------------------------------------*/



/*------------------------------------------------------------------------*/
LocalVars<. Scope& scope .>
= (. unique_ptr<AST::Attributes> attributes; .)
  "var"
  { Attributes<attributes> }
  IdsTypeWheres<. [attributes&,scope&]{TypedIdentifier tid => scope.addVariableDef( new AST::LocalVariable(tid, attributes)) } .> ";"
  .

ProcFormals<. bool incoming, bool allowWhereClauses, list<Variable>& ds .>
= (. Contract.Ensures(Contract.ValueAtReturn(out ds) != null);
     ds = new List<Variable>();
     var dsx = ds;
     var context = allowWhereClauses ? "procedure formals" : "the 'implementation' copies of formals";
  .)
  "("
  [ AttrsIdsTypeWheres<allowWhereClauses, allowWhereClauses, context, delegate(TypedIdent tyd, QKeyValue kv) { dsx.Add(new Formal(tyd.tok, tyd, incoming, kv)); }>
  ]
  ")"
  .

BoundVars<.IToken/*!*/ x, out List<Variable>/*!*/ ds.>
= (.
    Contract.Requires(x != null);
    Contract.Ensures(Contract.ValueAtReturn(out ds) != null);
    List<TypedIdent>/*!*/ tyds = new List<TypedIdent>();
    ds = new List<Variable>();
    var dsx = ds;
  .)
  AttrsIdsTypeWheres<true, false, "bound variables", delegate(TypedIdent tyd, QKeyValue kv) { dsx.Add(new BoundVariable(tyd.tok, tyd, kv)); } >
  .

/*------------------------------------------------------------------------*/
/* AttrsIdsTypeWheres is used with the declarations of formals and bound variables */
AttrsIdsTypeWheres<. bool allowAttributes, bool allowWhereClauses, string context, System.Action<TypedIdent, QKeyValue> action .>
=
  AttributesIdsTypeWhere<allowAttributes, allowWhereClauses, context, action>
  { "," AttributesIdsTypeWhere<allowAttributes, allowWhereClauses, context, action> }
  .


AttributesIdsTypeWhere<. bool allowAttributes, bool allowWhereClauses, string context, System.Action<TypedIdent, QKeyValue> action .>
= (. unique_ptr<Attributes> attrbutes; .)
  { Attributes<attributes>    (. if (!allowAttributes) {
                              kv = null;
                              this.SemErr("attributes are not allowed on " + context);
                            }
                         .)
  }
  IdsTypeWhere<allowWhereClauses, context, delegate(TypedIdent tyd) { action(tyd, kv); }>
  .


/*------------------------------------------------------------------------*/

Type<. unique_ptr<Type>& type .>
= (.Contract.Ensures(Contract.ValueAtReturn(out ty) != null); IToken/*!*/ tok; ty = dummyType; .)
  (
    TypeAtom<out ty>
  |
    Identifier<out tok>       (. List<Bpl.Type>/*!*/ args = new List<Bpl.Type> (); .)
    [ TypeArgs<args> ]   (. ty = new UnresolvedTypeIdentifier (tok, tok.val, args); .)
  |
    MapType<out ty>
  )
  .

TypeArgs<.List<Bpl.Type>/*!*/ ts.>
= (.Contract.Requires(ts != null); IToken/*!*/ tok; Bpl.Type/*!*/ ty; .)
  (
    TypeAtom<out ty>     (. ts.Add(ty); .)
    [ TypeArgs<ts> ]
  |
    Identifier<out tok>       (. List<Bpl.Type>/*!*/ args = new List<Bpl.Type> ();
                            ts.Add(new UnresolvedTypeIdentifier (tok, tok.val, args)); .)
    [ TypeArgs<ts> ]
  |
    MapType<out ty>      (. ts.Add(ty); .)
  )
  .

TypeAtom<out Bpl.Type/*!*/ ty>
= (.Contract.Ensures(Contract.ValueAtReturn(out ty) != null); ty = dummyType; .)
  ( "int"              (. ty = new BasicType(t, SimpleType.Int); .)
  | "real"             (. ty = new BasicType(t, SimpleType.Real); .)
  | "bool"             (. ty = new BasicType(t, SimpleType.Bool); .)
  /* note: bitvectors and floats are handled in UnresolvedTypeIdentifier */
  |
  "("
  Type<out ty>
  ")"
  )
  .

MapType<. unique_ptr<Type>& type .>
= (. Token* tok = nullptr;
     Token nnTok;
     List<Bpl.Type>/*!*/ arguments = new List<Bpl.Type>();
     Bpl.Type/*!*/ result;
     list<TypeVariable> typeParameters;
   .)
  [ TypeParams<tok, typeParameters> ]
  "["                                         (.  if (tok == nullptr) tok = t;  .)
    [ Types<arguments> ]
  "]"
  Type<out result>
  (.
    ty = new MapType(tok, typeParameters, arguments, result);
  .)
  .

TypeParams<. Token& startToken, list<TypeVariable>& typeParams .>
=  (. list<Identifier> typeParamIds; .)
  "<"                         (.  startToken = t;  .)
    Identifiers<typeParamIds>
  ">"                         (. for (auto& id : typeParamIds ) typeParams.push_back(new TypeVariable(id)); .)
  .

Types<.List<Bpl.Type>/*!*/ ts.>
= (. Contract.Requires(ts != null); Bpl.Type/*!*/ ty; .)
  Type<out ty>                 (. ts.Add(ty); .)
  { "," Type<out ty>           (. ts.Add(ty); .)
  }
  .


/*------------------------------------------------------------------------*/

VarOrType<. unique_ptr<TypedIdentifier>& tid .>
= (.
    unique_ptr<Type> type;
    Token idToken;
    Contract.Ensures(Contract.ValueAtReturn(out tyd) != null);
    string/*!*/ varName = TypedIdent.NoName;
    kv = null;
  .)
  { Attributes<ref kv> }
  Type<type>        (. idToken = type.token; .)
  [ ":"           (. { UTI uti; 
  							   if (uti=dynamic_cast<UnresolvedTypeIdentifier>(type) && uti.arguments.size()==0)
  							   	varName = uti.name;
  							   else
  									this.SemErr("expected identifier before ':'");
  							}
/*  							var uti = ty as UnresolvedTypeIdentifier;
                     if (uti != null && uti.Arguments.Count == 0) {
                       varName = uti.Name;
                     } else {
                       this.SemErr("expected identifier before ':'");
                     }*/
                  .)
    Type<type>
  ]
  (. tyd = new TypedIdent(tok, varName, ty); .)
  .

/*------------------------------------------------------------------------*/
Axiom<Scope& scope>
= (. unique_ptr<Expression> e; unique_ptr<Attributes> attributes; .)
  "axiom"
   { Attributes<Attributes> }
   (. Token tok = t; .)
  Proposition<e> ";"  (. scope.addAxiom(new Axiom(tok, attributes, e)); .)
  .

/*------------------------------------------------------------------------*/
TypeDefs<. Scope& scope .>
= (. unique_ptr<Attributes> attributes; .)
  "type"
  { Attributes<attributes> }
  UserDefinedType<scope, attributes>          
  { "," UserDefinedType<scope, attributes> }    
  ";"
  .

UserDefinedType<. Scope& scope, unique_ptr<Attributes> attributes .>
= (. Token id; list<Token> paramTokens;;
     //Bpl.Type/*!*/ body = dummyType; bool synonym = false; 
.)
  Identifier<id>
  [ WhiteSpaceIdentifiers<paramTokens> ]
  [
    "=" Type<out body>
    (. synonym = true; .)
  ]
  (.
     if (synonym) {
       List<TypeVariable>/*!*/ typeParams = new List<TypeVariable>();
       foreach(Token/*!*/ t in paramTokens){
         Contract.Assert(t != null);
         typeParams.Add(new TypeVariable(t, t.val));}
       decl = new TypeSynonymDecl(id, id.val, typeParams, body, kv);
     } else {
       decl = new TypeCtorDecl(id, id.val, paramTokens.Count, kv);
     }
   .)
  .


/*------------------------------------------------------------------------*/
Procedure<. Scope& scope .>
= (. Contract.Ensures(Contract.ValueAtReturn(out proc) != null); IToken/*!*/ x;
     List<TypeVariable>/*!*/ typeParams;
     List<Variable>/*!*/ ins, outs;
     List<Requires>/*!*/ pre = new List<Requires>();
     List<IdentifierExpr>/*!*/ mods = new List<IdentifierExpr>();
     List<Ensures>/*!*/ post = new List<Ensures>();

     List<Variable>/*!*/ locals = new List<Variable>();
     StmtList/*!*/ stmtList;
     QKeyValue kv = null;
     impl = null;
  .)

  "procedure"
  ProcSignature<true, out x, out typeParams, out ins, out outs, out kv>
  ( ";"
    { Spec<pre, mods, post> }
  | { Spec<pre, mods, post> }
    ImplBody<out locals, out stmtList>
    (.
      impl = new Implementation(x, x.val, typeParams,
                                Formal.StripWhereClauses(ins), Formal.StripWhereClauses(outs), locals, stmtList, kv == null ? null : (QKeyValue)kv.Clone(), this.errors);
    .)
  )
  (. proc = new Procedure(x, x.val, typeParams, ins, outs, pre, mods, post, kv); .)
  .


Implementation<. Scope& scope .>
= (. Contract.Ensures(Contract.ValueAtReturn(out impl) != null); IToken/*!*/ x;
     List<TypeVariable>/*!*/ typeParams;
     List<Variable>/*!*/ ins, outs;
     List<Variable>/*!*/ locals;
     StmtList/*!*/ stmtList;
     QKeyValue kv;
  .)

  "implementation"
  ProcSignature<false, out x, out typeParams, out ins, out outs, out kv>
  ImplBody<out locals, out stmtList>
    (. impl = new Implementation(x, x.val, typeParams, ins, outs, locals, stmtList, kv, this.errors); .)
  .


ProcSignature<.bool allowWhereClausesOnFormals, out IToken/*!*/ name, out List<TypeVariable>/*!*/ typeParams,
              out List<Variable>/*!*/ ins, out List<Variable>/*!*/ outs, out QKeyValue kv.>
= (. Contract.Ensures(Contract.ValueAtReturn(out name) != null); Contract.Ensures(Contract.ValueAtReturn(out typeParams) != null); Contract.Ensures(Contract.ValueAtReturn(out ins) != null); Contract.Ensures(Contract.ValueAtReturn(out outs) != null);
     IToken/*!*/ typeParamTok; typeParams = new List<TypeVariable>();
     outs = new List<Variable>(); kv = null; .)
  { Attributes<ref kv> }
  Identifier<out name>
  [ TypeParams<out typeParamTok, out typeParams> ]
  ProcFormals<true, allowWhereClausesOnFormals, out ins>
  [ "returns" ProcFormals<false, allowWhereClausesOnFormals, out outs> ]
  .


Spec<.List<Requires>/*!*/ pre, List<IdentifierExpr>/*!*/ mods, List<Ensures>/*!*/ post.>
= (.Contract.Requires(pre != null); Contract.Requires(mods != null); Contract.Requires(post != null); List<IToken>/*!*/ ms; .)
  ( "modifies"
    [ Identifiers<out ms>        (. foreach(IToken/*!*/ m in ms){
                                 Contract.Assert(m != null);
                                 mods.Add(new IdentifierExpr(m, m.val));
                               }
                            .)
    ] ";"
  | "free" SpecPrePost<true, pre, post>
  | SpecPrePost<false, pre, post>
  )
  .

SpecPrePost<.bool free, List<Requires>/*!*/ pre, List<Ensures>/*!*/ post.>
= (. Contract.Requires(pre != null); Contract.Requires(post != null); Expr/*!*/ e; Token tok = null; QKeyValue kv = null; .)
  ( "requires"              (. tok = t; .)
    { Attributes<ref kv> }
    Proposition<out e> ";"  (. pre.Add(new Requires(tok, free, e, null, kv)); .)
  | "ensures"               (. tok = t; .)
    { Attributes<ref kv> }
    Proposition<out e> ";"  (. post.Add(new Ensures(tok, free, e, null, kv)); .)
  )
  .

/*------------------------------------------------------------------------*/

ImplBody<.out List<Variable>/*!*/ locals, out StmtList/*!*/ stmtList.>
= (. Contract.Ensures(Contract.ValueAtReturn(out locals) != null); Contract.Ensures(Contract.ValueAtReturn(out stmtList) != null); locals = new List<Variable>(); .)
  "{"
  { LocalVars<locals> }
  StmtList<out stmtList>
  .

/* the StmtList also reads the final curly brace */
StmtList<out StmtList/*!*/ stmtList>
= (. Contract.Ensures(Contract.ValueAtReturn(out stmtList) != null); List<BigBlock/*!*/> bigblocks = new List<BigBlock/*!*/>();
     /* built-up state for the current BigBlock: */
     IToken startToken = null;  string currentLabel = null;
     List<Cmd> cs = null;  /* invariant: startToken != null ==> cs != null */
     /* temporary variables: */
     IToken label;  Cmd c;  BigBlock b;
     StructuredCmd ec = null;  StructuredCmd/*!*/ ecn;
     TransferCmd tc = null;  TransferCmd/*!*/ tcn;
  .)

  {
  ( LabelOrCmd<out c, out label>
    (. if (c != null) {
         // LabelOrCmd read a Cmd
         Contract.Assert(label == null);
         if (startToken == null) { startToken = c.tok;  cs = new List<Cmd>(); }
         Contract.Assert(cs != null);
         cs.Add(c);
       } else {
         // LabelOrCmd read a label
         Contract.Assert(label != null);
         if (startToken != null) {
           Contract.Assert(cs != null);
           // dump the built-up state into a BigBlock
           b = new BigBlock(startToken, currentLabel, cs, null, null);
           bigblocks.Add(b);
           cs = null;
         }
         startToken = label;
         currentLabel = label.val;
         cs = new List<Cmd>();
       }
    .)

  | StructuredCmd<out ecn>
    (. ec = ecn;
       if (startToken == null) { startToken = ec.tok;  cs = new List<Cmd>(); }
       Contract.Assert(cs != null);
       b = new BigBlock(startToken, currentLabel, cs, ec, null);
       bigblocks.Add(b);
       startToken = null;  currentLabel = null;  cs = null;
    .)

  | TransferCmd<out tcn>
    (. tc = tcn;
       if (startToken == null) { startToken = tc.tok;  cs = new List<Cmd>(); }
       Contract.Assert(cs != null);
       b = new BigBlock(startToken, currentLabel, cs, null, tc);
       bigblocks.Add(b);
       startToken = null;  currentLabel = null;  cs = null;
    .)

  )
  }
  "}"
  (. IToken/*!*/ endCurly = t;
     if (startToken == null && bigblocks.Count == 0) {
       startToken = t;  cs = new List<Cmd>();
     }
     if (startToken != null) {
       Contract.Assert(cs != null);
       b = new BigBlock(startToken, currentLabel, cs, null, null);
       bigblocks.Add(b);
     }

     stmtList = new StmtList(bigblocks, endCurly);
  .)
  .

TransferCmd<out TransferCmd/*!*/ tc>
= (. Contract.Ensures(Contract.ValueAtReturn(out tc) != null); tc = dummyTransferCmd;
     Token y;  List<IToken>/*!*/ xs;
     List<String> ss = new List<String>();
  .)
  ( "goto"             (. y = t; .)
    Identifiers<out xs>     (. foreach(IToken/*!*/ s in xs){
                            Contract.Assert(s != null);
                            ss.Add(s.val); }
                          tc = new GotoCmd(y, ss);
                       .)
  | "return"           (. tc = new ReturnCmd(t); .)
  ) ";"
  .

StructuredCmd<out StructuredCmd/*!*/ ec>
= (. Contract.Ensures(Contract.ValueAtReturn(out ec) != null); ec = dummyStructuredCmd;  Contract.Assume(cce.IsPeerConsistent(ec));
     IfCmd/*!*/ ifcmd;  WhileCmd/*!*/ wcmd;  BreakCmd/*!*/ bcmd;
  .)
  ( IfCmd<out ifcmd>    (. ec = ifcmd; .)
  | WhileCmd<out wcmd>  (. ec = wcmd; .)
  | BreakCmd<out bcmd>  (. ec = bcmd; .)
  )
  .

IfCmd<out IfCmd/*!*/ ifcmd>
= (. Contract.Ensures(Contract.ValueAtReturn(out ifcmd) != null); IToken/*!*/ x;
     Expr guard;
     StmtList/*!*/ thn;
     IfCmd/*!*/ elseIf;  IfCmd elseIfOption = null;
     StmtList/*!*/ els;  StmtList elseOption = null;
  .)
  "if"                       (. x = t; .)
  Guard<out guard>
  "{" StmtList<out thn>
  [ "else"
    ( IfCmd<out elseIf>      (. elseIfOption = elseIf; .)
    | "{"
      StmtList<out els>      (. elseOption = els; .)
    )
  ]
  (. ifcmd = new IfCmd(x, guard, thn, elseIfOption, elseOption); .)
  .

WhileCmd<out WhileCmd/*!*/ wcmd>
= (. Contract.Ensures(Contract.ValueAtReturn(out wcmd) != null); IToken/*!*/ x;  Token z;
     Expr guard;  Expr/*!*/ e;  bool isFree;
     List<PredicateCmd/*!*/> invariants = new List<PredicateCmd/*!*/>();
     StmtList/*!*/ body;
     QKeyValue kv = null;
  .)
  "while"             (. x = t; .)
  Guard<out guard>    (. Contract.Assume(guard == null || cce.Owner.None(guard)); .)
  {                   (. isFree = false; z = la/*lookahead token*/; .)
    [ "free"          (. isFree = true;  .)
    ]
    "invariant"
    { Attributes<ref kv> }
    Expression<out e> (. if (isFree) {
                           invariants.Add(new AssumeCmd(z, e, kv));
                         } else {
                           invariants.Add(new AssertCmd(z, e, kv));
                         }
						 kv = null;
                      .)
    ";"
  }
  "{"
  StmtList<out body>  (. wcmd = new WhileCmd(x, guard, invariants, body); .)
  .

Guard<out Expr e>
= (. Expr/*!*/ ee;  e = null; .)
  "("
  ( "*"                   (. e = null; .)
  | Expression<out ee>    (. e = ee; .)
  )
  ")"
  .

BreakCmd<out BreakCmd/*!*/ bcmd>
= (.Contract.Ensures(Contract.ValueAtReturn(out bcmd) != null); IToken/*!*/ x;  IToken/*!*/ y;
     string breakLabel = null;
  .)
  "break"             (. x = t; .)
  [ Identifier<out y>      (. breakLabel = y.val; .)
  ] ";"               (. bcmd = new BreakCmd(x, breakLabel); .)
  .

/*------------------------------------------------------------------------*/

LabelOrCmd<out Cmd c, out IToken label>
/* ensures (c == null) != (label != null) */
= (. IToken/*!*/ x; Expr/*!*/ e;
     List<IToken>/*!*/ xs;
     List<IdentifierExpr> ids;
     c = dummyCmd;  label = null;
     Cmd/*!*/ cn;
     QKeyValue kv = null;
  .)
  ( LabelOrAssign<out c, out label>
  | "assert"              (. x = t; .)
    { Attributes<ref kv> }
    Proposition<out e>    (. c = new AssertCmd(x, e, kv); .)
    ";"
  | "assume"              (. x = t; .)
    { Attributes<ref kv> }
    Proposition<out e>    (. c = new AssumeCmd(x, e, kv); .)
    ";"
  | "havoc"               (. x = t; .)
    Identifiers<out xs> ";"    (. ids = new List<IdentifierExpr>();
                             foreach(IToken/*!*/ y in xs){
                               Contract.Assert(y != null);
                               ids.Add(new IdentifierExpr(y, y.val));
                             }
                             c = new HavocCmd(x,ids);
                          .)
  | CallCmd<out cn> ";"   (. c = cn; .)
  | ParCallCmd<out cn>    (. c = cn; .)
  | "yield"               (. x = t; .)
    ";"                   (. c = new YieldCmd(x); .)
  )
  .

/*------------------------------------------------------------------------*/

LabelOrAssign<out Cmd c, out IToken label>
/* ensures (c == null) != (label != null) */
= (. IToken/*!*/ id; IToken/*!*/ x, y; Expr/*!*/ e0;
     c = dummyCmd;  label = null;
     AssignLhs/*!*/ lhs;
     List<AssignLhs/*!*/>/*!*/ lhss;
     List<Expr/*!*/>/*!*/ rhss;
     List<Expr/*!*/>/*!*/ indexes;
  .)
  Identifier<out id>              (. x = t; .)
  ( ":"                      (. c = null;  label = x; .)

  | (. lhss = new List<AssignLhs/*!*/>(); .)
    (. lhs = new SimpleAssignLhs(id, new IdentifierExpr(id, id.val)); .)

    { MapAssignIndex<out y, out indexes>    (. lhs = new MapAssignLhs(y, lhs, indexes); .) }
    (. lhss.Add(lhs); .)

    { ","
      Identifier<out id>
      (. lhs = new SimpleAssignLhs(id, new IdentifierExpr(id, id.val)); .)
      { MapAssignIndex<out y, out indexes>    (. lhs = new MapAssignLhs(y, lhs, indexes); .) }
      (. lhss.Add(lhs); .)
    }

    ":="                     (. x = t; /* use location of := */ .)
    Expression<out e0>       (. rhss = new List<Expr/*!*/> ();
                                rhss.Add(e0); .)
    { ","
      Expression<out e0>     (. rhss.Add(e0); .)
    }
    ";"                      (. c = new AssignCmd(x, lhss, rhss); .)
  )
  .

MapAssignIndex<.out IToken/*!*/ x, out List<Expr/*!*/>/*!*/ indexes.>
= (.Contract.Ensures(Contract.ValueAtReturn(out x) != null); Contract.Ensures(cce.NonNullElements(Contract.ValueAtReturn(out indexes))); indexes = new List<Expr/*!*/> ();
     Expr/*!*/ e;
  .)
  "["                        (. x = t; .)
    [
      Expression<out e>      (. indexes.Add(e); .)
      { ","
        Expression<out e>    (. indexes.Add(e); .)
      }
    ]
  "]"
  .

/*------------------------------------------------------------------------*/
CallCmd<out Cmd c>
= (. Contract.Ensures(Contract.ValueAtReturn(out c) != null); 
     IToken x; 
     bool isAsync = false;
     bool isFree = false;
     QKeyValue kv = null;
     c = null;
  .)
  [ "async"          (. isAsync = true;  .)
  ]
  [ "free"          (. isFree = true;  .)
  ]
  "call"                          (. x = t; .)
  { Attributes<ref kv> }
  CallParams<isAsync, isFree, kv, x, out c> (. .)
  .

ParCallCmd<out Cmd d>
= (. Contract.Ensures(Contract.ValueAtReturn(out d) != null); 
     IToken x; 
     QKeyValue kv = null;
	 Cmd c = null;
     List<CallCmd> callCmds = new List<CallCmd>();
  .)
  "par"                          (. x = t; .)
  { Attributes<ref kv> }
  CallParams<false, false, kv, x, out c> (. callCmds.Add((CallCmd)c); .) 
  { "|" CallParams<false, false, kv, x, out c> (. callCmds.Add((CallCmd)c); .) 
  }
  ";" (. d = new ParCallCmd(x, callCmds, kv); .)
  .

CallParams<bool isAsync, bool isFree, QKeyValue kv, IToken x, out Cmd c>
= (. 
    List<IdentifierExpr> ids = new List<IdentifierExpr>();
    List<Expr> es = new List<Expr>();
    Expr en;
    IToken first; 
    IToken p;
	c = null;
  .)
  Identifier<out first>
    ( "("
      [ Expression<out en>       (. es.Add(en); .)
        { "," Expression<out en> (. es.Add(en); .)
        }
      ]
      ")"                         (. c = new CallCmd(x, first.val, es, ids, kv); ((CallCmd) c).IsFree = isFree; ((CallCmd) c).IsAsync = isAsync; .)
    |
                                  (. ids.Add(new IdentifierExpr(first, first.val)); .)
      [ "," Identifier<out p>  (. ids.Add(new IdentifierExpr(p, p.val)); .)
        { "," Identifier<out p>  (. ids.Add(new IdentifierExpr(p, p.val)); .)
        }
      ] ":="
      Identifier<out first> "("
      [ Expression<out en>       (. es.Add(en); .)
        { "," Expression<out en> (. es.Add(en); .)
        }
      ]
      ")"                         (. c = new CallCmd(x, first.val, es, ids, kv); ((CallCmd) c).IsFree = isFree; ((CallCmd) c).IsAsync = isAsync; .)
    )
  .

/*------------------------------------------------------------------------*/
Proposition<out Expr/*!*/ e>
=(.Contract.Ensures(Contract.ValueAtReturn(out e) != null);.)
  Expression<out e>
  .

/*------------------------------------------------------------------------*/
Identifiers<. list<Identifier>& ids .>
= (.Contract.Ensures(Contract.ValueAtReturn(out xs) != null); IToken/*!*/ id; xs = new List<IToken>(); .)
  Identifier<out id>                 (. xs.Add(id); .)
  { "," Identifier<out id>           (. xs.Add(id); .)
  }
  .

/*------------------------------------------------------------------------*/
WhiteSpaceIdentifiers<.out List<IToken>/*!*/ xs.>
= (. Contract.Ensures(Contract.ValueAtReturn(out xs) != null); IToken/*!*/ id; xs = new List<IToken>(); .)
  Identifier<out id>                 (. xs.Add(id); .)
  { Identifier<out id>               (. xs.Add(id); .)
  }
  .

/*------------------------------------------------------------------------*/
Expressions<.out List<Expr>/*!*/ es.>
= (. Contract.Ensures(Contract.ValueAtReturn(out es) != null); Expr/*!*/ e; es = new List<Expr>(); .)
  Expression<out e>             (. es.Add(e); .)
  { "," Expression<out e>       (. es.Add(e); .)
  }
  .

/*------------------------------------------------------------------------*/
Expression<. unique_ptr<Expression>& e0.>
= (. IToken tok; unique_ptr<Expression> e1; .)
  ImpliesExpression<false, e0>
  { EquivOp        (. tok = t; .)
    ImpliesExpression<false, e1>
                   (. e0 = Expression.make(tok, BinaryOperator.Opcode.Iff, e0, e1); .)
  }
  .

EquivOp = "<==>" | '\u21d4'.

/*------------------------------------------------------------------------*/
ImpliesExpression<bool noExplies, out Expr/*!*/ e0>
= (. Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x; Expr/*!*/ e1; .)
  LogicalExpression<out e0>
  [
    ImpliesOp      (. x = t; .)
    /* recurse because implication is right-associative */
    ImpliesExpression<true, out e1>
                   (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Imp, e0, e1); .)
  |
    ExpliesOp      (. if (noExplies)
                        this.SemErr("illegal mixture of ==> and <==, use parentheses to disambiguate");
                      x = t; .)
    LogicalExpression<out e1>
                   (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Imp, e1, e0); .)
    /* loop because explies is left-associative */
    {
      ExpliesOp    (. x = t; .)
      LogicalExpression<out e1>
                   (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Imp, e1, e0); .)
    }
  ]
  .

ImpliesOp = "==>" | '\u21d2'.
ExpliesOp = "<==" | '\u21d0'.

/*------------------------------------------------------------------------*/
LogicalExpression<out Expr/*!*/ e0>
= (. Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x; Expr/*!*/ e1; .)
  RelationalExpression<out e0>
  [ AndOp          (. x = t; .)
    RelationalExpression<out e1>
    (. e0 = Expr.Binary(x, BinaryOperator.Opcode.And, e0, e1); .)
    { AndOp        (. x = t; .)
      RelationalExpression<out e1>
      (. e0 = Expr.Binary(x, BinaryOperator.Opcode.And, e0, e1); .)
    }
  | OrOp           (. x = t; .)
    RelationalExpression<out e1>
    (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Or, e0, e1); .)
    { OrOp         (. x = t; .)
      RelationalExpression<out e1>
      (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Or, e0, e1); .)
    }
  ]
  .

AndOp = "&&" | '\u2227'.
OrOp = "||" | '\u2228'.

/*------------------------------------------------------------------------*/
RelationalExpression<out Expr/*!*/ e0>
= (. Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x; Expr/*!*/ e1; BinaryOperator.Opcode op; .)
  BvTerm<out e0>
  [ RelOp<out x, out op>
    BvTerm<out e1>            (. e0 = Expr.Binary(x, op, e0, e1); .)
  ]
  .

RelOp<out IToken/*!*/ x, out BinaryOperator.Opcode op>
=                  (.Contract.Ensures(Contract.ValueAtReturn(out x) != null); x = Token.NoToken; op=BinaryOperator.Opcode.Add/*(dummy)*/; .)
  ( "=="           (. x = t; op=BinaryOperator.Opcode.Eq; .)
  | "<"            (. x = t; op=BinaryOperator.Opcode.Lt; .)
  | ">"            (. x = t; op=BinaryOperator.Opcode.Gt; .)
  | "<="           (. x = t; op=BinaryOperator.Opcode.Le; .)
  | ">="           (. x = t; op=BinaryOperator.Opcode.Ge; .)
  | "!="           (. x = t; op=BinaryOperator.Opcode.Neq; .)
  | "<:"           (. x = t; op=BinaryOperator.Opcode.Subtype; .)
  | '\u2260'       (. x = t; op=BinaryOperator.Opcode.Neq; .)
  | '\u2264'       (. x = t; op=BinaryOperator.Opcode.Le; .)
  | '\u2265'       (. x = t; op=BinaryOperator.Opcode.Ge; .)
  )
  .

/*------------------------------------------------------------------------*/
BvTerm<out Expr/*!*/ e0>
= (. Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x; Expr/*!*/ e1; .)
  Term<out e0>
  { "++"                  (. x = t; .)
    Term<out e1>          (. e0 = new BvConcatExpr(x, e0, e1); .)
  }
  .


/*------------------------------------------------------------------------*/
Term<out Expr/*!*/ e0>
= (.Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x; Expr/*!*/ e1; BinaryOperator.Opcode op; .)
  Factor<out e0>
  { AddOp<out x, out op>
    Factor<out e1>          (. e0 = Expr.Binary(x, op, e0, e1); .)
  }
  .

AddOp<out IToken/*!*/ x, out BinaryOperator.Opcode op>
=                  (.Contract.Ensures(Contract.ValueAtReturn(out x) != null); x = Token.NoToken; op=BinaryOperator.Opcode.Add/*(dummy)*/; .)
  ( "+"            (. x = t; op=BinaryOperator.Opcode.Add; .)
  | "-"            (. x = t; op=BinaryOperator.Opcode.Sub; .)
  )
  .

/*------------------------------------------------------------------------*/
Factor<out Expr/*!*/ e0>
= (.Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x; Expr/*!*/ e1; BinaryOperator.Opcode op; .)
  Power<out e0>
  { MulOp<out x, out op>
    Power<out e1> (. e0 = Expr.Binary(x, op, e0, e1); .)
  }
  .

MulOp<out IToken/*!*/ x, out BinaryOperator.Opcode op>
=                  (. Contract.Ensures(Contract.ValueAtReturn(out x) != null); x = Token.NoToken; op=BinaryOperator.Opcode.Add/*(dummy)*/; .)
  ( "*"            (. x = t; op=BinaryOperator.Opcode.Mul; .)
  | "div"          (. x = t; op=BinaryOperator.Opcode.Div; .)
  | "mod"          (. x = t; op=BinaryOperator.Opcode.Mod; .)
  | "/"            (. x = t; op=BinaryOperator.Opcode.RealDiv; .)
  )
  .

/*------------------------------------------------------------------------*/
Power<out Expr/*!*/ e0>
= (.Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x; Expr/*!*/ e1; .)
  UnaryExpression<out e0>
  [
    "**"           (. x = t; .)
    /* recurse because exponentation is right-associative */
    Power<out e1>  (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Pow, e0, e1); .)
  ]
  .

/*------------------------------------------------------------------------*/
UnaryExpression<out Expr/*!*/ e>
= (. Contract.Ensures(Contract.ValueAtReturn(out e) != null); IToken/*!*/ x;
     e = dummyExpr;
  .)
  ( "-"                        (. x = t; .)
    UnaryExpression<out e>     (. e = Expr.Unary(x, UnaryOperator.Opcode.Neg, e); .)
  | NegOp                      (. x = t; .)
    UnaryExpression<out e>     (. e = Expr.Unary(x, UnaryOperator.Opcode.Not, e); .)
  | CoercionExpression<out e>
  )
  .

NegOp = "!" | '\u00ac'.

/*------------------------------------------------------------------------*/

/* This production creates ambiguities, because types can start with "<"
   (polymorphic map types), but can also be followed by "<" (inequalities).
   Coco deals with these ambiguities in a reasonable way by preferring to read
   further types (type arguments) over relational symbols. E.g., "5 : C < 0"
   will cause a parse error because "<" is treated as the beginning of a
   map type. */

CoercionExpression<out Expr/*!*/ e>
= (. Contract.Ensures(Contract.ValueAtReturn(out e) != null); IToken/*!*/ x;
     Bpl.Type/*!*/ coercedTo;
     BigNum bn;
    .)
  ArrayExpression<out e>
  { ":"                     (. x = t; .)
    (
      Type<out coercedTo>   (. e = Expr.CoerceType(x, e, coercedTo); .)
    |
      Nat<out bn>           /* This means that we really look at a bitvector
                               expression t[a:b] */
                            (. if (!(e is LiteralExpr) || !((LiteralExpr)e).isBigNum) {
                                 this.SemErr("arguments of extract need to be integer literals");
                                 e = new BvBounds(x, bn, BigNum.ZERO);
                               } else {
                                 e = new BvBounds(x, bn, ((LiteralExpr)e).asBigNum);
                               }
                             .)
    )
  }
  .

/*------------------------------------------------------------------------*/
ArrayExpression<. unique_ptr<Expression>& e .>
= (. Token tok;
     Expr/*!*/ index0 = dummyExpr; Expr/*!*/ e1;
     bool store; bool bvExtract;
     List<Expr>/*!*/ allArgs = dummyExprSeq;
  .)
  AtomExpression<e>
  { "["        (. x = t; allArgs = new List<Expr> ();
                  allArgs.Add(e);
                  store = false; bvExtract = false; .)
      [
        Expression<out index0>
               (. if (index0 is BvBounds)
                    bvExtract = true;
                  else
                    allArgs.Add(index0);
               .)
        { "," Expression<out e1>
               (. if (bvExtract || e1 is BvBounds)
                    this.SemErr("bitvectors only have one dimension");
                  allArgs.Add(e1);
               .)
        }
        [ ":=" Expression<out e1>
               (. if (bvExtract || e1 is BvBounds)
                    this.SemErr("assignment to bitvectors is not possible");
                  allArgs.Add(e1); store = true;
               .)
        ]
      | ":=" Expression<out e1>       (. allArgs.Add(e1); store = true; .)
      ]
    "]"
    (. if (store)
         e = new NAryExpr(x, new MapStore(x, allArgs.Count - 2), allArgs);
       else if (bvExtract)
         e = new BvExtractExpr(x, e,
                               ((BvBounds)index0).Upper.ToIntSafe,
                               ((BvBounds)index0).Lower.ToIntSafe);
       else
         e = new NAryExpr(x, new MapSelect(x, allArgs.Count - 1), allArgs);
    .)
  }
  .


/*------------------------------------------------------------------------*/
AtomExpression<. unique_ptr<Expression>& e .>
= (. TextPosition pos;
     list<Expression> args;
     unique_ptr<IdentifierExpression> ide;
     unique_ptr<Identifier> id;
     unique_ptr<Function>   func;
     Binder b;
  .)
( 
    "false"           (. e = new LiteralExpression(toTextPos(t), false); .)
  | "true"            (. e = new LiteralExpression(toTextPos(t), true); .)
  | NatE<e>
  | Dec<e>            
  | Float<e>
  | BvLit<e>

  | IdentifierE<ide>            (. id = ide->identifier->clone(); e = move(ide) .)
    [ "(" Expressions<args> ")" (. e = new FAExpression(e.pos, new FunctionCall(id), move(args)); .) ]

  | "old"                    (. pos = toTextPos(t); .)
    "(" Expression<e> ")"    (. e = new OldExpression(pos, e); .)

  | ("int" |                 (. func = new ArithmeticCoercion(toTextPos(t), ArithmeticCoercion.CoercionType.ToInt)  .)
     "real" )                (. func = new ArithmeticCoercion(toTextPos(t), ArithmeticCoercion.CoercionType.ToReal) .)
    "(" Expression<e> ")"    (. e = new FAExpression(func.pos, func, e); .)

  | "(" (
      Expression<e>                 (. if (e is BvBounds) this.SemErr("parentheses around bitvector bounds are not allowed"); .)
      | ( 
          ( Forall                            (. binder = Binder::forall; .)
          | Exists                            (. binder = Binder::exists; .)
          | Lambda                            (. binder = Binder::lambda; .)
        )                                     (. pos = toTextPos(t); .)
        QuantifierBody<tok,binder,e> )
    ) ")"

  | IfThenElseExpression<e>
  | CodeExpression<e>
)
.

CodeExpression<.out List<Variable>/*!*/ locals, out List<Block/*!*/>/*!*/ blocks.>
= (. Contract.Ensures(Contract.ValueAtReturn(out locals) != null); Contract.Ensures(cce.NonNullElements(Contract.ValueAtReturn(out blocks))); locals = new List<Variable>(); Block/*!*/ b;
     blocks = new List<Block/*!*/>();
  .)
  "|{"
  { LocalVars<locals> }
  SpecBlock<out b>          (. blocks.Add(b); .)
  { SpecBlock<out b>        (. blocks.Add(b); .)
  }
  "}|"
  .

SpecBlock<out Block/*!*/ b>
= (. Contract.Ensures(Contract.ValueAtReturn(out b) != null); IToken/*!*/ x; IToken/*!*/ y;
     Cmd c;  IToken label;
     List<Cmd> cs = new List<Cmd>();
     List<IToken>/*!*/ xs;
     List<String> ss = new List<String>();
     b = dummyBlock;
     Expr/*!*/ e;
  .)
  Identifier<out x> ":"
  { LabelOrCmd<out c, out label>
                       (. if (c != null) {
                            Contract.Assert(label == null);
                            cs.Add(c);
                          } else {
                            Contract.Assert(label != null);
                            SemErr("SpecBlock's can only have one label");
                          }
                       .)
  }
  ( "goto"             (. y = t; .)
    Identifiers<out xs>     (. foreach(IToken/*!*/ s in xs){
                            Contract.Assert(s != null);
                            ss.Add(s.val); }
                          b = new Block(x,x.val,cs,new GotoCmd(y,ss));
                       .)
  | "return" Expression<out e>
                       (. b = new Block(x,x.val,cs,new ReturnExprCmd(t,e)); .)
  )
  ";"
  .

Attributes<. unique_ptr<Attributes>& .>
= (. Trigger trig = null; .)
  AttributeOrTrigger<ref kv, ref trig> (.  if (trig != null) this.SemErr("only attributes, not triggers, allowed here"); .)
.

AttributeOrTrigger<ref QKeyValue kv, ref Trigger trig>
= (. IToken/*!*/ tok;  Expr/*!*/ e;  List<Expr>/*!*/ es;
     string key;
     List<object/*!*/> parameters;  object/*!*/ param;
  .)
  "{"                                         (. tok = t; .)
     (
       ":" ident                              (. key = t.val;  parameters = new List<object/*!*/>(); .)
       [ AttributeParameter<out param>        (. parameters.Add(param); .)
         { "," AttributeParameter<out param>  (. parameters.Add(param); .)
         }
       ]
       (. if (key == "nopats") {
            if (parameters.Count == 1 && parameters[0] is Expr) {
              e = (Expr)parameters[0];
              if(trig==null){
                trig = new Trigger(tok, false, new List<Expr> { e }, null);
              } else {
                trig.AddLast(new Trigger(tok, false, new List<Expr> { e }, null));
              }
            } else {
              this.SemErr("the 'nopats' quantifier attribute expects a string-literal parameter");
            }
          } else {
            if (kv==null) {
              kv = new QKeyValue(tok, key, parameters, null);
            } else {
              kv.AddLast(new QKeyValue(tok, key, parameters, null));
            }
          }
       .)
     |
       Expression<out e>       (. es = new List<Expr> { e }; .)
       { "," Expression<out e> (. es.Add(e); .)
       }                       (. if (trig==null) {
                                    trig = new Trigger(tok, true, es, null);
                                  } else {
                                    trig.AddLast(new Trigger(tok, true, es, null));
                                  }
                               .)
     )
  "}"
  .

AttributeParameter<out object/*!*/ o>
= (. Contract.Ensures(Contract.ValueAtReturn(out o) != null);
     o = "error";
     Expr/*!*/ e;
  .)
  ( string                (. o = t.val.Substring(1, t.val.Length-2); .)
  | Expression<out e>     (. o = e; .)
  )
  .

IfThenElseExpression<. unique_ptr<Expression>& e>
= (. Token tok;
     unique_ptr<Expression> e0, e1, e2; .)
  "if" (. tok = t; .) Expression<e0> "then" Expression<e1> "else" Expression<e2>
  (. e = new FAExpression(tok, new IfThenElse(tok), new List<Expr>{ e0, e1, e2 }); .)
  .


QuantifierBody<. TextPosition pos, Binder binder, unique_ptr<Expression>& e .>
= (. TextPosition pos2;
     list<TypeVariable>         typeVars;
     list<Variable>             vars;
     unique_ptr<Attributes>     attributes;
     unique_ptr<Triggers>       triggers;    
     unique_ptr<Expression>     ie                 .)
  (
    (   TypeParams<pos2,typeParams> [ BoundVars<pos, vars> ]
      | BoundVars<pos, vars> )
    QSep
    { AttributeOrTrigger<attributes, triggers> }
    Expression<ie>
  ) (. e = new BinderExpression(pos, binder, move(attributes), move(triggers), move(typeVars), move(vars), move(ie)); .)
  .

Forall = "forall" | '\u2200'.
Exists = "exists" | '\u2203'.
Lambda = "lambda" | '\u03bb'.
QSep = "::" | '\u2022'.

/*------------------------------------------------------------------------*/
IdentifierExpression<. unique_ptr<Expression>& e .> = 
(. unique_ptr<Identifier> id .)
Identifier< id >  (. e = new IdentifierExpression(id); .)
.
Identifier<. unique_ptr<Identifier>& id .> = 
ident (. id = new Identifier(toTextPos(t),toIdentifier(t.val)); .)
.

/*------------------------------------------------------------------------*/
NatE<. unique_ptr<LiteralExpression>& le .>
= (. Integer i; Token tok.)
  Nat<i,t>  (. le = new LiteralExpression(tok,i); .)
  .

Nat<. Integer& n .>
=
  digits
  (. try {
       n = Integer(t.val);
     } catch (std::runtime_exception&) {
       this.SemErr("incorrectly formatted number");
       n = 0;
     }
  .)
  .

/*------------------------------------------------------------------------*/
Dec<. unique_ptr<LiteralExpression>& le .>
= (. string s = ""; .)
  (   decimal     (. s = t.val; .)
    | dec_float   (. s = t.val; .)
  )
  (. try {
       n = BigDec.FromString(s);
     } catch (FormatException) {
       this.SemErr("incorrectly formatted number");
       n = BigDec.ZERO;
     }
  .)
  .

/*------------------------------------------------------------------------*/
BvLit<. unique_ptr<LiteralExpression>& le .>
=
  bvlit
  (.
     string s = t.val;
     auto pos = s.find("bv");
     assert(pos>=0);
     string a = s.substring(0,pos);
     string b = s.substring(pos + 2);
     Integer n;
     try {
       n = Integer(a);
       m = Integer(b);
     } catch (std::runtime_exception& ) {
       this.SemErr("incorrectly formatted bitvector");
       n = 0;
       m = 0;
     }
    le = new LiteralExpression(toTextPos(t), new BitVectorLiteral(n,m));
  .)
  .

FloatE<. unique_ptr<LiteralExpression>& le .> = 
(. Rational r; TextPosition pos .)
Float<r> (. return new LiteralExpression(pos,r); .)
.

Float<. Rational& r, TextPosition& pos .>
= (. string s = ""; .)
  (
    float   (. s = t.val; pos = toTextPos(t); .)
  )
  (. try {
       r = Rational(s);
     } catch (std::runtime_exception& e) {
       this.SemErr("incorrectly formatted floating point, " + e.Message);
       r = 0;
     }
  .)
  .


END BoogiePL.
