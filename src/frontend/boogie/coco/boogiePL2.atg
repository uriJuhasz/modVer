
/*---------------------------------------------------------------------------
// BoogiePL -
//--------------------------------------------------------------------------*/
#include <vector>
#include <list>
#include <string>
#include <memory>
#include <functional>
#include <typeinfo>
#include "frontend/boogie/ParseTree.h"

using namespace frontend::boogie::ParseTree;
using std::vector;
using std::list;
using std::string;
using std::function;
using std::make_unique;

COMPILER BoogiePL

/*--------------------------------------------------------------------------*/
    Program program;

    Parser(const std::basic_string<unsigned char>& buf)
        : Parser(new Scanner(buf.c_str(),buf.size())){}

    void parse(){
        BoogiePL();
    }

    static void parse(const std::basic_string<unsigned char>& input){
        Parser parser(input);
        parser.parse();
    }

    void SemErr(const wstring& s) {
        SemErr(s.c_str());
        errDist = 0;
    }
    void SemErr(const string& s) {
        SemErr(wstring(s.begin(),s.end()).c_str());
        errDist = 0;
    }

    static TextPosition toPos(const Token* t){ return TextPosition(t->line,t->col); }

    static wstring toIdentifier(const wstring& s){
        return (s[0]=='\\') ? s.substr(1) : s;
    }

    bool isLabel() {
      return (la->kind == _ident && scanner->Peek()->kind == _colon );
    }

    bool isIdColon() {
      return (la->kind == _ident && scanner->Peek()->kind == _colon );
    }

    bool isBVBound() {
      if (la->kind != _digits)
        return false;
      if (scanner->Peek()->kind != _colon )
        return false;
      if (scanner->Peek()->kind != _digits )
        return false;
      return true;
    }

    bool isUnaryITEExpression() {
      auto t = la;
      while (t->kind==_not || t->kind==_minus)
        t=scanner->Peek();
      return t->kind==_ifKW;
    }

    typedef function< void(Attributes&&, pIdentifier&&, pType&&, pExpression&&) > ActionAITW;
    typedef function< void(              pIdentifier&&, pType&&, pExpression&&) > ActionITW;
    typedef function< void(              pIdentifier&&, pType&&               ) > ActionIT;
    typedef function< void(Attributes&&, pIdentifier&&, pType&&               ) > ActionAIT;

/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  special = "'~#$^_.?`".
  glyph = "`~!@#$%^&*()-_=+[{]}|;:',<.>/?\\".

  cr        = '\r'.
  lf        = '\n'.
  tab       = '\t'.
  
  space = ' '.
  quote = '"'.

  newLine = cr + lf.
  regularStringChar = ANY - quote - newLine.

  nondigit = letter + special.
  nonquote = letter + digit + space + glyph.

  leftBracket = '['.

$namespace=frontend::boogie::parser

/*------------------------------------------------------------------------*/
TOKENS
  ident =  [ '\\' ] nondigit {nondigit | digit}.
  bvlit = digit {digit} 'b' 'v' digit {digit}.
  digits = digit {digit}.

  colon = ':'.

  string = quote { regularStringChar | "\\\"" } quote.

  decimal =  digit {digit} 'e' [ '-' ] digit {digit} .
  dec_float = digit {digit} '.' digit {digit} [ 'e' [ '-' ] digit {digit} ] .
  float = [ '-' ] digit {digit} 'e' [ '-' ] digit {digit} 'f' digit {digit} 'e' digit {digit}
                                    | '0' 'N' 'a' 'N' digit {digit} 'e' digit {digit}
                                    | '0' 'n' 'a' 'n' digit {digit} 'e' digit {digit}
                                    | '0' '+' 'o' 'o' digit {digit} 'e' digit {digit}
                                    | '0' '-' 'o' 'o' digit {digit} 'e' digit {digit} .

  not = '!' | '\u00ac'.
  minus = '-'.
  ifKW = "if".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab


/*------------------------------------------------------------------------*/
PRODUCTIONS


/*------------------------------------------------------------------------*/
BoogiePL
= (. auto program = make_unique<Program>(); .)
  { ConstantsDef  <. *program .>
  | FunctionDef   <. *program .>
  | AxiomP        <. *program .>
  | TypeDefs      <. *program .>
  | GlobalVarDefs <. *program .>
  | ProcedureP     <. *program .>
  | ImplementationP<. *program .>
  }
  EOF
  .

/*------------------------------------------------------------------------*/
TypeDefs<. Program& prog .>
= (. Attributes attributes; .)
  "type"
  AttributesP<attributes>
        UserDefinedType<. prog, cloneC(attributes) .>
  { "," UserDefinedType<. prog, cloneC(attributes) .> }    
  ";"
  .

UserDefinedType<. Program& prog, Attributes&& attributes .>
= (. pIdentifier id; 
     Identifiers params;
     pType body;
  .)
  IdentifierP<id>
  [ IdentifiersWS<params> ]
  [ "=" TypeP<body> ]
  (. TypeParameters tParams;
     for (auto& pid : params) tParams.push_back(make_unique<TypeVariable>(move(pid)));
     if (body) prog.addTypeDef(make_unique<TypeSynonymDef>    (move(id),move(tParams),move(body)));
          else prog.addTypeDef(make_unique<TypeConstructorDef>(move(id),move(tParams)) ); .)
.

/*------------------------------------------------------------------------*/
ConstantsDef<. Program& scope .>
= (. TextPosition pos; 
     Attributes   attributes;
     bool         unique = false; 
     Identifiers  ids;
     pType        type;
     pConstantOrderSpec orderSpec(new ConstantOrderSpec()); .)
  
  "const"                                   (. pos = toPos(t); .)
  AttributesP<attributes>
  [ "unique"                                (. unique = true;  .) ]
  IdsType<ids,type>
  [ OrderSpec<*orderSpec> ]
  ";"
                                            (.  for (auto& id : ids) 
                                                    scope.addVariableDef(
                                                        make_unique<Constant>(
                                                            pos, 
                                                            cloneC(attributes), 
                                                            move(id), 
                                                            type->clone(),
                                                            unique, 
                                                            orderSpec->clone())); 
                                            .)
  .

OrderSpec<. ConstantOrderSpec& orderSpec.>
= "extends"                                                          (. orderSpec.specified = true; .) 
  [ OrderSpecParent<orderSpec> { ","  OrderSpecParent<orderSpec> } ]
  [ "complete"                                                       (. orderSpec.complete  = true; .) ] 
  .

OrderSpecParent<. ConstantOrderSpec& orderSpec .>
= (. bool unique = false;
     pIdentifier id;  .)
    [ "unique"             (. unique = true; .) ]
    IdentifierP<id>         (. orderSpec.parents.push_back(ConstantParentSpec(move(id), unique)); .)
.
  
/*------------------------------------------------------------------------*/
GlobalVarDefs<. Scope& scope .>
= (. TextPosition pos;
     Attributes attributes; .)
  "var"                                     (. pos = toPos(t); .)
  AttributesP<attributes>
  IdsTypeWheres<. [&attributes,&scope](auto&& id, auto&& type, auto&& e){
        scope.addVariableDef( make_unique<GlobalVariable>(
            id->pos, cloneC(attributes), move(id), move(type), move(e) )); } .> 
  ";"
  .

/*------------------------------------------------------------------------*/
FunctionDef<. Scope& scope .>
= (. TextPosition   pos;
     Attributes     attributes;
     pIdentifier    id;
     TypeParameters typeParams;
     Types          argTypes;
     Identifiers    argNames;
     pType          resultType;
     pExpression    body;
  .)
  "function"                         (. pos=toPos(t); .) 
  AttributesP<attributes> 
  IdentifierP<id>
  [ TypeParams<typeParams> ]
  "(" [ VarOrTypeArgC<argTypes,argNames> { "," VarOrTypeArgC<argTypes,argNames> } ] ")"
  (   "returns" "(" VarOrTypeAsType<resultType> ")"
    | ":" TypeP<resultType> )
  ( "{" Expression<body> "}" | ";" )
  (. scope.addFunctionDef( make_unique<Function>(
    	pos, 
    	move(attributes), 
    	move(id),
        move(typeParams),
    	move(argTypes),
    	move(resultType),
      move(argNames),
    	move(body)));
    	//Boogie makes func(a,b:T) into func(a:T,b:T) but func(a,b) as func(<anon0>:a,<anon1>:b)
    	//Boogie adds body as axiom if "inline" attribute is present 
        //We ignore the return variable name - not usable anywhere - Boogie has a bug
  .)
.

VarOrTypeAsType<. pType& type .>
  = 
    IF (isIdColon()) ( ident colon TypeP<type> )
    | TypeP<type>
.

VarOrTypeArgC<. Types& argTypes, Identifiers& argNames .>
= (. pType type; pIdentifier id; .)
    VarOrTypeArg<type,id> (. argTypes.push_back(move(type)); argNames.push_back(move(id)); .)
.

VarOrTypeArg<. pType& type, pIdentifier& id .>
= (   ( IF (isIdColon()) IdentifierP<id> ":" TypeP<type> )
    | (                                      TypeP<type> ))
.


/*------------------------------------------------------------------------*/
AxiomP<. Program& prog .>
= (. TextPosition pos;
     Attributes attributes; 
     pExpression e; .)
  "axiom"                  (. pos = toPos(t); .)
   AttributesP<attributes>
   Proposition<e> ";"      (. prog.addAxiom(make_unique<Axiom>(pos, move(attributes), move(e))); .)
 .

/*------------------------------------------------------------------------*/
ProcedureP<. Program& prog .>
= (. Attributes     attributes;
     pIdentifier    id;
     pProcSignature sig;
     auto           spec(make_unique<ProcSpec>());
  .)

  "procedure"
  AttributesP<attributes>
  IdentifierP<id>
  ProcSignature<sig>
  (   ";"  
      { ProcSpecP<*spec> }
    | { ProcSpecP<*spec> }
      ImplBody<. prog, id->clone(), cloneC(attributes), sig->cloneWOWhere(), spec->clone() .>
  )
  (. prog.addProcedure( make_unique<Procedure>(move(id), move(attributes), move(sig), move(spec))); .)
.

ProcSignature<. pProcSignature& sig .>
= (. TypeParameters typeParameters;
     Formals formals;.)
  [ TypeParams<typeParameters> ]
              ProcFormals<FormalDir::In,  formals>
  [ "returns" ProcFormals<FormalDir::Out, formals> ]
.

ProcFormals<. FormalDir dir, Formals& formals .>
= "("
  [ AttrsIdsTypeWheres<. [dir,&formals](auto&& attrs, auto&& id, auto&& type, auto&& e)
      {formals.push_back(make_unique<Formal>(move(attrs),move(id),move(type),move(e),dir));} .> ]
  ")"
.

ProcSpecP<. ProcSpec& spec .>
= (. bool _free; .)
  ["free"                   (. _free=true; .)        ]
  (  ModifiesP<_free,spec>
  | SpecPrePost<_free,spec> )
.

ModifiesP<. bool _free, ProcSpec& spec .>
= (. TextPosition pos; Identifiers ids; .)
  "modifies" (. pos = toPos(t); .)
    [ IdentifiersCS<ids>  (. for (auto& id : ids) spec.mod.push_back(make_unique<Modifies>(pos,_free, move(id))); .) ]
    ";"
.

SpecPrePost<. bool _free, ProcSpec& spec .>
= (. TextPosition pos; 
     SpecExpressions* dest;
     pExpression e; .)
  (   "requires"            (. dest = &spec.req;  .)
    | "ensures"             (. dest = &spec.ens; .)
  )                         (. pos = toPos(t);    .)
  Proposition<e> ";"        (. dest->push_back(make_unique<SpecExpression>(pos,_free,move(e))); .)
.


ImplementationP<. Program& prog .>
= (. Attributes     attributes;
     pIdentifier    id;
     pProcSignature sig;
     auto           spec(make_unique<ProcSpec>());
  .)

  "implementation"
  AttributesP<attributes>
  IdentifierP<id>
  ImplSignature<sig>
  { ProcSpecP<*spec> }  
  ImplBody<. prog, move(id), move(attributes), move(sig), move(spec) .>
.

ImplSignature<. pProcSignature& sig .>
= (. TypeParameters typeParameters;
     Formals formals;
     .)
  [ TypeParams<typeParameters> ]
              ImplFormals<FormalDir::In,  formals>
  [ "returns" ImplFormals<FormalDir::Out, formals> ]
.

ImplFormals<. FormalDir dir, Formals& formals .>
= "("
  [ IdsTypeS<. [dir,&formals](auto&& id, auto&& type)
      {formals.push_back(make_unique<Formal>(Attributes(),move(id),move(type),pExpression(),dir));} .> ]
  ")"
.

ImplBody<. Program& prog, pIdentifier&& id, Attributes&& attributes, pProcSignature&& sig, pProcSpec&& spec .>
= (. pScopedBlock body = make_unique<ScopedBlock>(); .) 
  ScopedBlocksP<*body>
  (. prog.addImplementation( make_unique<Implementation>(move(id), move(attributes), move(sig), move(spec), move(body))); .)
.

ScopedBlocksP<. ScopedBlock& b .>
= "{"
  { LocalVar<b.locals> }
  StmtList<b.bs> //eats up "}"
.


/*------------------------------------------------------------------------*/
BoundVarsP<. BoundVariables& vars .>
= 
  AttrsIdsTypes<. [&vars](auto&& attrs, auto&& id, auto&& type){ 
    vars.push_back(make_unique<BoundVariable>(move(attrs),move(id),move(type))); } .>
  .

/*------------------------------------------------------------------------*/
LocalVar<. Locals& locals .>
= (. Attributes attributes; .)
  "var"
  AttributesP<attributes>
  IdsTypeWheres<. [&attributes,&locals](auto&& id, auto&& type, auto&& e){ 
    locals.push_back(make_unique<LocalVariable>( cloneC(attributes), move(id), move(type) )); } .> 
  ";"
  .

/*------------------------------------------------------------------------*/
//IdsType variants

IdsTypeS<. ActionIT action .>
  = IdsTypeF<action> { "," IdsTypeF<action> }
.

IdsTypeF<. ActionIT action .>
  = (. Identifiers ids;
       pType type; .)
  IdentifiersCS<ids> ":" TypeP<type> (. for (auto& id : ids) action(move(id),type->clone()); .)
.

IdsType<. Identifiers& ids, pType& type .>
  = IdentifiersCS<ids> ":" TypeP<type>
.

IdsTypeWheres<. ActionITW action .>
	= IdsTypeWhere<action> { "," IdsTypeWhere<action> }
.

IdsTypeWhere<.  ActionITW action .>
= (. vector<pIdentifier> ids;  
     pType               type;  
     pExpression         e; 
  .)
  IdsType<ids,type>
  [ "where" Expression<e>  ]
	  (. for (auto& id : ids)
	       action(move(id), type->clone(), e->clone());
	  .)
  .


AttrsIdsTypeWheres<. ActionAITW action .>
= AttrsIdsTypeWhere<action> { "," AttrsIdsTypeWhere<action> }
.

AttrsIdsTypeWhere<. ActionAITW action .>
= (. Attributes attributes; .)
  AttributesP<attributes>
  IdsTypeWhere<.[action,&attributes](auto id, auto type, auto e){action(cloneC(attributes),move(id),move(type),move(e));}.>
.

AttrsIdsTypes<. ActionAIT action .>
= AttrsIdsType<action> { "," AttrsIdsType<action> }
.

AttrsIdsType<. ActionAIT action .>
= (. Attributes attributes; .)
  AttributesP<attributes>
  IdsTypeF<.[action,&attributes](auto&& id, auto&& type){action(cloneC(attributes),move(id),move(type));}.>
.

/*------------------------------------------------------------------------*/
//Types
TypeP<. pType& type .>
= (  TypeAtom<type>
  | TypeConstructor<type>
  | MapTypeP<type>)
.

TypeAtom<. pType& type .>
=   "int"              (. type = make_unique<IntegerType>(toPos(t)); .)
  | "real"             (. type = make_unique<RationalType>(toPos(t)); .)
  | "bool"             (. type = make_unique<BooleanType>(toPos(t)); .)
  | "(" TypeP<type> ")"
 .

TypeConstructor<. pType& type .>
=(. pIdentifier id;
    Types       args;
 .)
   IdentifierP<id> [ TypeArgs<args> ]   (. type = make_unique<UnresolvedType>(id->pos,move(id), move(args)); .)
.

TypeArgs<. Types& types .>
= (. pIdentifier id;
     pType       type;  .)
  (
    ((  TypeAtom<type>    (. types.push_back(move(type)); .)
      | IdentifierP<id>    (. types.push_back(make_unique<UnresolvedType>(id->pos,move(id),Types())); .)
    )
    [ TypeArgs<types> ] )
  | MapTypeP<type>      (. types.push_back(move(type)); .)
  )
  .


MapTypeP<. pType& type .>
= (. TextPosition pos;
     TypeParameters typeParameters;
     vector<pType> arguments;
     pType result;
   .)
  [ TypeParams<typeParameters> ]
  "[" (. pos = toPos(t); .) [ TypesCS<arguments> ] "]"
  TypeP<result>
  (. type = make_unique<MapType>(pos, move(typeParameters), move(arguments), move(result)); .)
.


TypeC<. Types& types .>
= (. pType t; .)
  TypeP<t>                 (. types.push_back(move(t)); .)
.

TypesCS<. Types& types .>
  = TypeC<types> { "," TypeC<types>}
.

TypeParams<. TypeParameters& typeParams .>
=  (. Identifiers ids; .)
  "<"                         //(.  startToken = t;  .)
    IdentifiersCS<ids>
  ">"                         (. for (auto& id : ids ) typeParams.push_back(make_unique<TypeVariable>(move(id))); .)
  .

/*------------------------------------------------------------------------*/
/* the StmtList also reads the final curly brace */
StmtList<. pBlockStatement& bs .>
= { (. Labels            labels;
     SimpleStatements  cmds;
     pNSStatement      endCmd;
  .)
    { IF(isLabel()) LabelC<labels> | ()}
    { CmdC<cmds> }
    [ NSCmd<endCmd> ]               (. bs->bs.push_back(make_unique<SBlock>(move(labels),move(cmds),move(endCmd))); .)
  }
    "}" 
.

LabelC<. Labels& labels .>
= (. pLabel label; .) LabelP<label> (. labels.push_back(move(label)); .)
.

BlockStmt<. pBlockStatement& bs .>
= "{" StmtList<bs>
.

NSCmd<. pNSStatement& s .>
=   ControlCmd<s>
  | StructuredCmd<s>
.

ControlCmd<. pNSStatement& cs .>
=   GotoCmdNS<cs>
  | ReturnCmd<cs>
  | BreakCmd<cs>
.

ReturnCmd<. pNSStatement& cs .>
= (. TextPosition pos; .)
  "return" (. pos = toPos(t); .)
  ";" (. cs = make_unique<ReturnStatement>(pos); .)
.


GotoCmdNS<. pNSStatement& cs .>
= (. pGotoStatement cc; .) GotoCmd<cc> (. pControlStatement css = move(cc); cs = move(css); .)
.

GotoCmdCB<. pCBControlStatement& cs .>
= (. pGotoStatement cc; .) GotoCmd<cc> (. cs = move(cc); .)
.

GotoCmd<. pGotoStatement& cs .>
= (. TextPosition pos; Identifiers ids; .)
  "goto"               (. pos = toPos(t); .)
  IdentifiersCS<ids>   (. cs = make_unique<GotoStatement>(pos, move(ids)); .)
  ";"
.

BreakCmd<. pNSStatement& c .>
= (. TextPosition pos;
     pIdentifier id;
  .)
  "break"                (. pos = toPos(t); .)
  [ IdentifierP<id> ]      
  ";"                  (. c = make_unique<BreakStatement>(pos, move(id)); .)
  .



StructuredCmd<. pNSStatement& cmd .>
=   IfCmd<cmd>
  | WhileCmd<cmd>
  .

IfCmd<. pNSStatement& c .>
= (. TextPosition pos;
     pWExpression guard;
     pBlockStatement  thn;
     pBlockStatement  els;
  .)
  "if"                       (. pos = toPos(t); .)
  Guard<guard>
  BlockStmt<thn>
  [ "else"                   (. pNSStatement elseIf; .)
    ( IfCmd<elseIf>          (. SBlocks bs; bs.push_back(make_unique<SBlock>(move(elseIf))); els = make_unique<BlockStatement>(elseIf->pos, move(bs)); .)
    | BlockStmt<els>         
    )
  ]
  (. c = make_unique<ITEStatement>(pos, move(guard), move(thn), move(els)); .)
.

WhileCmd<. pNSStatement& c .>
= (. TextPosition pos;
     pWExpression guard;
     SpecExpressions invariants;
     pBlockStatement body;
  .)
  "while"             (. pos = toPos(t); .)
  Guard<guard>        
  {                   (. bool isFree = false; TextPosition pos2 = toPos(la); pExpression inv; .)
    [ "free"          (. isFree = true;  .) ]
    "invariant"       (. Attributes attributes; .)
    AttributesP<attributes>
    Expression<inv>   (. invariants.push_back(make_unique<SpecExpression>(pos2,isFree,move(inv),move(attributes))); .)
    ";"
  }
  BlockStmt<body>     (. c = make_unique<WhileStatement>(pos, move(guard), move(invariants), move(body)); .)
.

Guard<. pWExpression& e .>
= (. pExpression ee; .)
  "("
  ( "*"               (. e = make_unique<WildCardExpression>(toPos(t)); .)
  | Expression<ee>    (. e = move(ee); .)
  )
  ")"
  .

/*------------------------------------------------------------------------*/

CmdC<. SimpleStatements& s .>
= (. pSimpleStatement c; .)
  SimpleCmd<c>             (. s.push_back(move(c)); .)
.

SimpleCmd<. pSimpleStatement& c .>
=   AssignCmd<c>
  | PredicateCmd<c>
  | HavocCmd<c>
  | CallCmd<c>
  | ParCallCmd<c>
  | YieldCmd<c>
.

PredicateCmd<. pSimpleStatement& c .>
= (. TextPosition pos; 
     Attributes attributes;
     pExpression e;
     bool isAssert;
  .)
  (   "assert"                       (. isAssert=true;      .) 
    | "assume"                       (. isAssert=false;     .)
  )                                  (. pos = toPos(t); .)
  AttributesP<attributes>
  Proposition<e>    
  ";"                                 (. c = isAssert ? static_cast<pPredicateStatement>(make_unique<AssertStatement>(pos, move(attributes), move(e))) 
                                                      : static_cast<pPredicateStatement>(make_unique<AssumeStatement>(pos, move(attributes), move(e))); .)
.

HavocCmd<. pSimpleStatement& c .>
= (. TextPosition pos;
     Identifiers ids; 
  .)
  "havoc"                 (. pos = toPos(t); .)
  IdentifiersCS<ids> ";"  (. c = make_unique<HavocStatement>(pos,move(ids)); .)
  .

YieldCmd<. pSimpleStatement& c .>
= (. TextPosition pos; .)
  "yield"               (. pos = toPos(t); .)
  ";"                   (. c = make_unique<YieldStatement>(pos); .)
  .

/*------------------------------------------------------------------------*/

LabelP<. pLabel& label .>
= (. pIdentifier id; .)
  IdentifierP<id> ":" (. label = make_unique<Label>(move(id)); .)
  .

AssignCmd<. pSimpleStatement& c .>
= (. AssignLHSs   lhss;
     Expressions  rhss;
     TextPosition pos;                   
  .)
    AssignLHS<lhss> { "," AssignLHS<lhss> }
    ":="                                   (. pos = toPos(t); .)
    ExpressionsCS<rhss>
    ";"                                    (. c = make_unique<AssignStatement>(pos, move(lhss), move(rhss)); .)
.

AssignLHS<. AssignLHSs& lhss .>
= (. pIdentifier id; 
     MapSelects mss;
  .)
    ( IdentifierP<id>
      { AssignLHSMapP<mss> }
    ) (. lhss.push_back((mss.empty()) ? static_cast<pAssignLHS>(make_unique<AssignLHSVar>(move(id)))
                                      : static_cast<pAssignLHS>(make_unique<AssignLHSMap>(move(id),move(mss)))); .)
.

AssignLHSMapP<. MapSelects& mss .>
= (.  TextPosition pos;
      Expressions indices; .)
  ( "["                          (. pos = toPos(t); .)
    [ ExpressionsCS<indices> ]
  "]" )                          (. mss.push_back(make_unique<MapSelect>(pos,move(indices))); .)
  .

/*------------------------------------------------------------------------*/
CallCmd<. pSimpleStatement& c .>
= (. pCallStatement cc; .) CallCmdI<cc> (. c = move(cc); .).

CallCmdI<. pCallStatement& c .>
= (. TextPosition pos;
     bool isAsync = false;
     bool isFree = false;
     Attributes attributes;
  .)
  [ "async"          (. isAsync = true;  .) ]
  [ "free"           (. isFree  = true;  .) ]
  "call"             (. pos = toPos(t); .)
  AttributesP<attributes>
  CallParams<c, pos, isAsync, isFree, attributes>
  .

ParCallCmd<. pSimpleStatement& pc .>
= (. TextPosition pos;
     Attributes attributes;
     CallStatements cs;
  .)
  "par"                              (. pos = toPos(t); .)
  AttributesP<attributes>
        CallParamsC<cs, pos, false, false, attributes> 
  { "|" CallParamsC<cs, pos, false, false, attributes> }
  ";" (. pc = make_unique<ParallelCallStatement>(pos,move(attributes),move(cs)); .)
  .

CallParamsC<. CallStatements& cs, TextPosition pos, bool isAsync, bool isFree, Attributes& attributes .>
= (. pCallStatement c; .)
  CallParams<c,pos,isAsync,isFree,attributes> (. cs.push_back(move(c)); .)
.

CallParams<. pCallStatement& c, TextPosition pos, bool isAsync, bool isFree, Attributes& attributes .>
= (. pIdentifier mId;
     Expressions args;
     Identifiers lhss;
  .)
  IdentifierP<mId>
    ( "(" [ ExpressionsCS<args> ] ")" 
    |                                 (. lhss.push_back(move(mId));  .)
      [ "," IdentifiersCS<lhss> ]
      ":="
      IdentifierP<mId> "(" [ ExpressionsCS<args> ] ")" 
    ) (. c = make_unique<CallStatement>(pos, move(mId), move(lhss), move(args), isFree, isAsync); .)
  .

/*------------------------------------------------------------------------*/
//Identifiers
IdentifiersCS<. Identifiers& ids .>
  =  IdentifierC<ids> { "," IdentifierC<ids> }
.

IdentifiersWS<. Identifiers& ids .>
  = IdentifierC<ids> { IdentifierC<ids> }
.

IdentifierC<. Identifiers& ids .>
= (. pIdentifier id; .)
  IdentifierP<id> (. ids.push_back(move(id)); .)
.

/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
//Expressions
Proposition<. pExpression& e .>
  = Expression<e>
.

ExpressionsCS<. Expressions& es.>
= ExpressionC<es> { "," ExpressionC<es> }
.

ExpressionC<. Expressions& es.>
= (. pExpression e; .)
  Expression<e> (. es.push_back(move(e)); .)
.

Expression<. pExpression& e .>
= 
    (IF (isUnaryITEExpression()) UnaryITEExpression<e> )
  | ( ImpliesExpression<e> { ExpressionR<e> } )
.

ExpressionR<. pExpression& e0 .>
= (. TextPosition pos; 
     pExpression e1;
 .)
  EquivOp                (. pos = toPos(t); .)
  ImpliesExpression<e1>  (. e0 = FAExpression::make( OpC::equiv(pos), move(e0), move(e1) ); .)
  .

EquivOp = "<==>" | '\u21d4'.


/*------------------------------------------------------------------------*/
ImpliesExpression<. pExpression& e0 .>
// = "ab" LogicalExpression<e0> "ba".
= LogicalExpression<e0>
  [ ImpliesExpressionR<e0> | ExpliesExpressionR<e0> ]
.

ImpliesExpressionR<. pExpression& e0 .>
=   (. TextPosition pos;
       pExpression e1; .)
    /* recurse because implication is right-associative */
    ImpliesOp               (. pos = toPos(t); .)
    ImpliesExpressionRR<e1> (. e0 = FAExpression::make(OpC::implies(pos), move(e0), move(e1)); .)
.

ImpliesExpressionRR<. pExpression& e1 .>
=   LogicalExpression<e1>      
    [ ImpliesExpressionR<e1> ] 
.

ImpliesOp = "==>" | '\u21d2'.

ExpliesExpressionR<. pExpression& e0 .>
= ExpliesExpressionRR<e0> { ExpliesExpressionRR<e0> }
.

ExpliesExpressionRR<. pExpression& e0 .>
=(. TextPosition pos;
    pExpression e1; 
 .)
  ExpliesOp               (. pos = toPos(t); .)
  LogicalExpression<e1>   (. e0 = FAExpression::make(OpC::explies(pos), move(e0), move(e1)); .)
.

ExpliesOp = "<==" | '\u21d0'.

/*------------------------------------------------------------------------*/
LogicalExpression<pExpression& e>
= RelationalExpression<e> 
  [ LogicalExpressionAnd<e> | LogicalExpressionOr<e> ]
.

LogicalExpressionAnd<pExpression& e>
  = LogicalExpressionAndR<e> { LogicalExpressionAndR<e> }
.

LogicalExpressionAndR<pExpression& e0>
  = (. pOperator op;
       pExpression e1; .)
  AndOp                    (. op = OpC::andOp(toPos(t)); .)
  RelationalExpression<e1> (. e0 = FAExpression::make(move(op),move(e0),move(e1)); .)
.

LogicalExpressionOr<pExpression& e>
  = LogicalExpressionOrR<e> { LogicalExpressionOrR<e> }
.

LogicalExpressionOrR<pExpression& e0>
  = (. pOperator op;
       pExpression e1; .)
  OrOp                     (. op = OpC::orOp(toPos(t)); .)
  RelationalExpression<e1> (. e0 = FAExpression::make(move(op),move(e0),move(e1)); .)
.


AndOp = "&&" | '\u2227'.
OrOp = "||" | '\u2228'.

/*------------------------------------------------------------------------*/
RelationalExpression<. pExpression& e0 .>
= (. pOperator op;
     pExpression e1;
  .)
  BvTerm<e0>
  [ RelOp<op> BvTerm<e1>            (. e0 = FAExpression::make(move(op),move(e0),move(e1)); .)  ]
.

RelOp<. pOperator& op .>
=                  
   "=="                (. op = OpC::eq(toPos(t)); .)
  | "<"                (. op = OpC::lt(toPos(t)); .)
  | ">"                (. op = OpC::gt(toPos(t)); .)
  | ( "<=" | '\u2264') (. op = OpC::le(toPos(t)); .)
  | ( ">=" | '\u2265') (. op = OpC::ge(toPos(t)); .)
  | ("!=" | '\u2260')  (. op = OpC::ne(toPos(t)); .)
  | "<:"               (. op = OpC::subType(toPos(t)); .)
  
 .

/*------------------------------------------------------------------------*/
BvTerm<. pExpression& e0 .>
= (. pOperator op;
     pExpression e1;
  .)
  Term<e0>
  { "++"                  (. op = OpC::bvConcat(toPos(t)); .)
    Term<e1>              (. e0 = FAExpression::make(move(op), move(e0), move(e1)); .)
  }
.


/*------------------------------------------------------------------------*/
Term<. pExpression& e0 .>
= (. pExpression e1; 
     pOperator   op;
  .)
  Factor<e0>
  { AddOp<op>
    Factor<e1>      (. e0 = FAExpression::make(move(op), move(e0), move(e1)); .)
  }
.

AddOp<. pOperator& op .>
=                  
    "+"            (. op = OpC::add(toPos(t)); .)
  | "-"            (. op = OpC::sub(toPos(t)); .)
  .

/*------------------------------------------------------------------------*/
Factor<. pExpression& e0 .>
= (. pOperator op; pExpression e1; .)
  Power<e0>
  { MulOp<op> Power<e1> (. e0 = FAExpression::make(move(op), move(e0), move(e1)); .) }
.

MulOp<. pOperator& op .>
=                  
    "*"            (. op = OpC::mul(toPos(t)); .)
  | "div"          (. op = OpC::div(toPos(t)); .)
  | "mod"          (. op = OpC::mod(toPos(t)); .)
  | "/"            (. op = OpC::divR(toPos(t)); .)
.

/*------------------------------------------------------------------------*/
Power<. pExpression& e0 .>
=  (. pOperator op; pExpression e1; .)
  UnaryExpression<e0>
  [ /* recurse because exponentation is right-associative */
    "**"           (. op = OpC::pow(toPos(t)); .)
    Power<e1>      (. e0 = FAExpression::make(move(op), move(e0), move(e1)); .)
  ]
  .

/*------------------------------------------------------------------------*/
UnaryExpression<. pExpression& e .>
= (. TextPosition pos; pOperator op; .)
    UnaryOp<op> UnaryExpression<e>  (. e = FAExpression::make(move(op),move(e)); .)
  | CoercionExpression<e>
.

UnaryITEExpression<. pExpression& e .>
= (. pOperator op; .)
    ( UnaryOp<op> UnaryITEExpression<e>  (. e = FAExpression::make(move(op),move(e)); .) )
  | IfThenElseExpression<e>
.

UnaryOp<. pOperator& op .>
=                  
  ( minus (. op = OpC::minus(toPos(t)); .)
  | not   (. op = OpC::notOp(toPos(t)); .)
  )                    
.

/*------------------------------------------------------------------------*/

/* This production creates ambiguities, because types can start with "<"
   (polymorphic map types), but can also be followed by "<" (inequalities).
   Coco deals with these ambiguities in a reasonable way by preferring to read
   further types (type arguments) over relational symbols. E.g., "5 : C < 0"
   will cause a parse error because "<" is treated as the beginning of a
   map type. */

CoercionExpression<. pExpression& e .>
= (. TextPosition pos;
     pType type;
    .)
  ArrayExpression<e> 
  { ":" (. pos = toPos(t); .) TypeP<type> (. e = FAExpression::make(make_unique<CastOp>(pos,move(type)),move(e)); .) }
.

/*------------------------------------------------------------------------*/
ArrayExpression<. pExpression& e .>
= AtomExpression<e>
  { ArrayExpressionR<e> }
.

ArrayExpressionR<. pExpression& e .>
= "["                                       (. TextPosition pos = toPos(t); .)
      [   IF (isBVBound()) BvBoundP<pos,e>
        | MapReadOrWrite<pos,e> 
      ]
  "]"
.

MapReadOrWrite<. TextPosition pos, pExpression& e .>
= (. Expressions  args;
     pOperator    op = OpC::mapRead(pos); 
  .)
  ( ( ExpressionsCS<args> [ MapWrite<op,args> ] )
    |                       MapWrite<op,args> 
  )                                                  (. e = FAExpression::make(move(op),move(args)); .)
.
        
MapWrite<. pOperator& op, Expressions& args .>
  =  ":="                  (. op = OpC::mapWrite(toPos(t)); .)  
      ExpressionC<args> 
.

BvBoundP<. TextPosition pos, pExpression& e .>
= (. pExpression l,h; .)
  NatE<l> ":" NatE<h> (. e = FAExpression::make(OpC::bvSelect(pos), move(l), move(h) ); .)
.

/*------------------------------------------------------------------------*/
AtomExpression<. pExpression& e .>
=   LiteralExpression<e>
  | FAExpressionP<e>
  | OldExpressionP<e>
  | CastExpression<e>
  | BinderOrParenExpression<e>
//  | IfThenElseExpression<e>
  | CodeExpressionP<e>
.

LiteralExpression<. pExpression& e .>
=   BooleanLiteralExpressionP<e>
  | NatE<e>
  | Dec<e>            
  | FloatE<e>
  | BvLit<e>
.

BooleanLiteralExpressionP<. pExpression& e .>
=   "false"           (. e = make_unique<BooleanLiteralExpression>(toPos(t), false); .)
  | "true"            (. e = make_unique<BooleanLiteralExpression>(toPos(t), true); .)
.
FAExpressionP<. pExpression& e .>
= (. Expressions args;
     pVariableExpression ide;
     pIdentifier id; 
  .)
  IdentifierExpressionP<ide>      (. id = ide->id->clone(); e = move(ide); .)
  [ "(" ExpressionsCS<args> ")"  (. e = FAExpression::make(UserDefinedOp::make(move(id)), move(args)); .) ]
.

OldExpressionP<. pExpression& e .>
= (.  TextPosition pos; .)
  "old"                    (. pos = toPos(t); .)
  "(" Expression<e> ")"    (. e = make_unique<OldExpression>(pos, move(e)); .)
.

BinderOrParenExpression<. pExpression& e .>
= (. TextPosition pos;
     Binder b;
  .)
  ("(" 
      (  Expression<e>                 //(. if (typeid(e)==typeid(BvBounds)) this->SemErr("parentheses around bitvector bounds are not allowed"); .)
      | ( BinderP<pos,b> QuantifierBody<pos,b,e> ) )
   ")")
.

BinderP<. TextPosition& pos, Binder& binder .>
=
      Forall                            (. binder = Binder::forall; .)
    | Exists                            (. binder = Binder::exists; .)
    | Lambda                            (. binder = Binder::lambda; .)
                                        (. pos = toPos(t); .)
.

QuantifierBody<. TextPosition pos, Binder binder, pExpression& e .>
= (. TypeParameters  typeVars;
     BoundVariables  vars;
     Attributes      attributes;
     Triggers        triggers;
     pExpression     ie;                 .)
  (
    (   TypeParams<typeVars> [ BoundVarsP<vars> ]
      | BoundVarsP<vars> )
    QSep
    AttributesAndTriggers<attributes,triggers>
    Expression<ie>
  ) (. e = make_unique<QExpression>(pos, binder, move(attributes), move(triggers), move(typeVars), move(vars), move(ie)); .)
  .

Forall = "forall" | '\u2200'.
Exists = "exists" | '\u2203'.
Lambda = "lambda" | '\u03bb'.
QSep = "::" | '\u2022'.


CastExpression<. pExpression& e .>
= (. pOperator op; .)
    ("int" |               (. op = make_unique<CastOp>(toPos(t),make_unique<IntegerType>(toPos(t)));  .)
     "real"                (. op = make_unique<CastOp>(toPos(t),make_unique<RationalType>(toPos(t))); .) )
  "(" Expression<e> ")"    (. e = FAExpression::make(move(op),move(e)); .)
.


CodeExpressionP<. pExpression& e .>
= (. TextPosition pos;
     Locals       locals;
     CBSBlocks    bs;   
  .)
  "|{"   (. pos = toPos(t); .)
    { LocalVar<locals> } { CBSBlockP<bs> } 
  "}|" (. e = make_unique<CodeExpression>(pos, move(locals), make_unique<CBBlockStatement>(move(bs))); .)
  .

CBSBlockP<. CBSBlocks& bs .>
= (. pLabel              l;
     SimpleStatements    cs;
     pCBControlStatement cc;
  .)
  LabelP<l>
  { CmdC<cs> }
  CBControlCmd<cc>
  (. bs.push_back(make_unique<CBSBlock>(move(l),move(cs),move(cc))); .)
  ";"
  .

CBControlCmd<. pCBControlStatement& c .>
=   GotoCmdCB<c>
  | ReturnECmd<c>
.
ReturnECmd<. pCBControlStatement& cs .>
= (. TextPosition pos; pExpression e; .)
  "return" (. pos = toPos(t); .)
  Expression<e>
  ";" (. cs = make_unique<ReturnEStatement>(pos,move(e)); .)
.

AttributesP<. Attributes& attributes .>
= 
  { "{" AttributeI<attributes> "}" }
.

AttributesAndTriggers<. Attributes& attributes, Triggers& triggers .>
= 
  { "{" (AttributeI<attributes> | TriggerP<triggers>) "}" }
.

TriggerP<. Triggers& triggers .> 
= (. pTrigger trigger = make_unique<Trigger>(); .)
    ExpressionsCS<. trigger->es .> (. triggers.push_back(move(trigger)); .)
.

AttributeI<. Attributes& attributes .> 
= (. pAttribute attribute(make_unique<Attribute>()); .)
    ":" IdentifierP<. attribute->id .>
        [       AttributeParameter<. attribute->params .>
          { "," AttributeParameter<. attribute->params .> }
        ]       (. attributes.push_back(move(attribute)); .)
.  //Boogie takes { :nopats Expression } as a dis-unification constraint

AttributeParameter<. vector<pAttributeParam>& params .>
= (. pExpression e; .)
  ( (. wstring s; .) StringP<s>  (. params.push_back(make_unique<StringAttributeParam>    ( toPos(t), s )); .)
  | Expression<e>                (. params.push_back(make_unique<ExpressionAttributeParam>( move(e) )); .)
  )
.

StringP<. wstring& s .>
= string (. s = t->val+1; s = s.substr(0,s.length()-1); .)
.

IfThenElseExpression<. pExpression& e .>
= (. pOperator op;
     pExpression e0, e1, e2; 
  .)
  "if" (. op = OpC::ite(toPos(t)); .) Expression<e0> "then" Expression<e1> "else" Expression<e2>
  (. e = FAExpression::make(move(op), move(e0), move(e1), move(e2)); .)
.



/*------------------------------------------------------------------------*/
IdentifierExpressionP<. pVariableExpression& e .> = 
    (. pIdentifier id; .)
    IdentifierP<id>  (. e = make_unique<VariableExpression>(move(id)); .)
.

IdentifierP<. pIdentifier& id .> = 
    ident (. id = make_unique<Identifier>(toPos(t),toIdentifier(t->val)); .)
.

/*------------------------------------------------------------------------*/
NatE<. pExpression& e .>
= (. TextPosition pos; Integer n; .)
  Nat<pos,n>  (. e = make_unique<LiteralExpressionC<Integer>>(pos,move(n)); .)
  .

Nat<. TextPosition& pos, Integer& n .>
=
  digits
  (. try {
       n = common::string2Integer(t->val);
     } catch (std::exception&) {
       this->SemErr("incorrectly formatted number");
       n = 0;
     }
  .)
  .

/*------------------------------------------------------------------------*/
Dec<. pExpression& le .>
= (. wstring s; Integer n; .)
  (   decimal     (. s = t->val; .)
    | dec_float   (. s = t->val; .)
  )
  (. try {
       n = common::string2Integer(s);
     } catch (std::exception&) {
       this->SemErr(L"incorrectly formatted number " + s);
       n = 0;
     }
  .)
  .

/*------------------------------------------------------------------------*/
BvLit<. pExpression& le .>
=
  bvlit
  (.
     wstring s = t->val;
     auto pos = s.find(L"bv");
     assert(pos>=0);
     try {
       auto val   = common::string2Integer(s.substr(0,      pos               ));
       auto nbits = common::string2Int32  (s.substr(pos + 2,s.length()-(pos+2)));
       le = make_unique<BVLiteralExpression>(toPos(t), BVConstant(nbits,move(val)));
     } catch (std::exception& ) {
       this->SemErr("incorrectly formatted bitvector");
     }
  .)
  .

FloatE<. pExpression& le .>
= (. Float f; 
     TextPosition pos; 
  .)
  FloatP<f,pos> (. le = make_unique<LiteralExpressionC<Float>>(pos,move(f)); .)
.

FloatP<. Float& f, TextPosition& pos .>
= (. wstring s; .)
  float   (. s = t->val; pos = toPos(t); .)
  (. try {
       f = string2Float(s);
     } catch (std::exception& e) {
       this->SemErr(L"incorrectly formatted floating point number " + s);
     }
  .)
  .

END BoogiePL.
