
// Copyright (c) 2008, Microsoft

type Field a;
type HeapType = <a>[ref,Field a]a;
type MaskType = <a>[ref,Field a][PermissionComponent]int;
type CreditsType = [ref]int;
type ref;
const null: ref;

var Heap: HeapType;

type PermissionComponent;
const unique perm$R: PermissionComponent;
const unique perm$N: PermissionComponent;
var Mask: MaskType where IsGoodMask(Mask);
var SecMask: MaskType where IsGoodMask(SecMask);
const Permission$denominator: int;
axiom Permission$denominator > 0;
const Permission$FullFraction: int;
const Permission$Zero: [PermissionComponent]int;
axiom Permission$Zero[perm$R] == 0 && Permission$Zero[perm$N] == 0;
const Permission$Full: [PermissionComponent]int;
axiom Permission$Full[perm$R] == Permission$FullFraction && Permission$Full[perm$N] == 0;
const ZeroMask: MaskType;
axiom (forall<T> o: ref, f: Field T, pc: PermissionComponent :: ZeroMask[o,f][pc] == 0);
axiom IsGoodMask(ZeroMask);
const unique joinable: Field int;
axiom NonPredicateField(joinable);
const unique token#t: TypeName;
const unique forkK: Field int;
axiom NonPredicateField(forkK);
const channelK: int;
const monitorK: int;
const predicateK: int;

function Fractions(n: int) returns (int)
{
  n * Permission$denominator
}
axiom (forall x,y: int :: 0 <= x && x <= y ==> Fractions(x) <= Fractions(y));

axiom Permission$FullFraction  == Fractions(100);
axiom 0 < channelK && 1000*channelK < Fractions(1);
axiom 0 < monitorK && 1000*monitorK < Fractions(1);
axiom 0 < predicateK && 1000*predicateK < Fractions(1);
axiom predicateK == channelK && channelK == monitorK;

var Credits: CreditsType;

function IsGoodState(PartialHeapType) returns (bool);
function combine(PartialHeapType, PartialHeapType) returns (PartialHeapType);
function heapFragment<T>(T) returns (PartialHeapType);
type PartialHeapType;
const emptyPartialHeap: PartialHeapType;

axiom (forall a: PartialHeapType, b: PartialHeapType :: {IsGoodState(combine(a, b))} IsGoodState(combine(a, b)) <==> IsGoodState(a) && IsGoodState(b));
axiom IsGoodState(emptyPartialHeap);

type ModuleName;
const CurrentModule: ModuleName;
type TypeName;
function dtype(ref) returns (TypeName);
const CanAssumeFunctionDefs: bool;

type Mu;
const unique mu: Field Mu;
axiom NonPredicateField(mu);
function MuBelow(Mu, Mu) returns (bool);  // strict partial order
axiom (forall m: Mu, n: Mu ::
  { MuBelow(m,n), MuBelow(n,m) }
  !(MuBelow(m,n) && MuBelow(n,m)));
axiom (forall m: Mu, n: Mu, o: Mu ::
  { MuBelow(m,n), MuBelow(n,o) }
  MuBelow(m,n) && MuBelow(n,o) ==> MuBelow(m,o));
const $LockBottom: Mu;
axiom (forall m, n: Mu :: MuBelow(m, n) ==> n != $LockBottom);

const unique held: Field int;
function Acquire$Heap(int) returns (HeapType);
function Acquire$Mask(int) returns (MaskType);
function Acquire$SecMask(int) returns (MaskType);
function Acquire$Credits(int) returns (CreditsType);
axiom NonPredicateField(held);

function LastSeen$Heap(Mu, int) returns (HeapType);
function LastSeen$Mask(Mu, int) returns (MaskType);
function LastSeen$SecMask(Mu, int) returns (MaskType);
function LastSeen$Credits(Mu, int) returns (CreditsType);

const unique rdheld: Field bool;
axiom NonPredicateField(rdheld);
function wf(h: HeapType, m: MaskType, sm: MaskType) returns (bool);

function IsGoodInhaleState(ih: HeapType, h: HeapType,
                           m: MaskType, sm: MaskType) returns (bool)
{
  (forall<T> o: ref, f: Field T :: { ih[o, f] }  CanRead(m, sm, o, f) ==> ih[o, f] == h[o, f]) &&
  (forall o: ref :: { ih[o, held] }  (0<ih[o, held]) == (0<h[o, held])) &&
  (forall o: ref :: { ih[o, rdheld] }  ih[o, rdheld] == h[o, rdheld]) &&
  (forall o: ref :: { h[o, held] }  (0<h[o, held]) ==> ih[o, mu] == h[o, mu]) &&
  (forall o: ref :: { h[o, rdheld] }  h[o, rdheld] ==> ih[o, mu] == h[o, mu])
}
function IsGoodExhaleState(eh: HeapType, h: HeapType,
                           m: MaskType, sm: MaskType) returns (bool)
{
  (forall<T> o: ref, f: Field T :: { eh[o, f] }  CanRead(m, sm, o, f) ==> eh[o, f] == h[o, f]) &&
  (forall o: ref :: { eh[o, held] }  (0<eh[o, held]) == (0<h[o, held])) &&
  (forall o: ref :: { eh[o, rdheld] }  eh[o, rdheld] == h[o, rdheld]) &&
  (forall o: ref :: { h[o, held] }  (0<h[o, held]) ==> eh[o, mu] == h[o, mu]) &&
  (forall o: ref :: { h[o, rdheld] }  h[o, rdheld] ==> eh[o, mu] == h[o, mu]) &&
  (forall o: ref :: { h[o, forkK] } { eh[o, forkK] } h[o, forkK] == eh[o, forkK]) &&
  (forall o: ref :: { h[o, held] } { eh[o, held] } h[o, held] == eh[o, held]) &&
  (forall o: ref, f: Field int :: { eh[o, f], PredicateField(f) } PredicateField(f) ==> h[o, f] <= eh[o, f])
}

// ---------------------------------------------------------------
// -- Permissions ------------------------------------------------
// ---------------------------------------------------------------

function /*{:expand false}*/ CanRead<T>(m: MaskType, sm: MaskType, obj: ref, f: Field T) returns (bool)
{
  0 <  m[obj,f][perm$R] || 0 <  m[obj,f][perm$N] ||
  0 < sm[obj,f][perm$R] || 0 < sm[obj,f][perm$N]
}
function /*{:expand false}*/ CanReadForSure<T>(m: MaskType, obj: ref, f: Field T) returns (bool)
{
  0 < m[obj,f][perm$R] || 0 < m[obj,f][perm$N]
}
function /*{:expand false}*/ CanWrite<T>(m: MaskType, obj: ref, f: Field T) returns (bool)
{
  m[obj,f][perm$R] == Permission$FullFraction && m[obj,f][perm$N] == 0
}
function /*{:expand true}*/ IsGoodMask(m: MaskType) returns (bool)
{
  (forall<T> o: ref, f: Field T ::
      0 <= m[o,f][perm$R] && 
      (NonPredicateField(f) ==> 
        (m[o,f][perm$R]<=Permission$FullFraction &&
        (0 < m[o,f][perm$N] ==> m[o,f][perm$R] < Permission$FullFraction))) &&
      (m[o,f][perm$N] < 0 ==> 0 < m[o,f][perm$R]))
}

axiom (forall h: HeapType, m, sm: MaskType, o: ref, q: ref :: {wf(h, m, sm), h[o, mu], h[q, mu]} wf(h, m, sm) && o!=q && (0 < h[o, held] || h[o, rdheld]) && (0 < h[q, held] || h[q, rdheld]) ==> h[o, mu] != h[q, mu]);

function DecPerm<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {DecPerm(m, o, f, howMuch)[q, g][perm$R]}
      DecPerm(m, o, f, howMuch)[q, g][perm$R] == ite(o==q && f ==g, m[q, g][perm$R] - howMuch, m[q, g][perm$R])
);

function DecEpsilons<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {DecPerm(m, o, f, howMuch)[q, g][perm$N]}
         DecEpsilons(m, o, f, howMuch)[q, g][perm$N] == ite(o==q && f ==g, m[q, g][perm$N] - howMuch, m[q, g][perm$N])
);

function IncPerm<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {IncPerm(m, o, f, howMuch)[q, g][perm$R]}
         IncPerm(m, o, f, howMuch)[q, g][perm$R] == ite(o==q && f ==g, m[q, g][perm$R] + howMuch, m[q, g][perm$R])
);

function IncEpsilons<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {IncPerm(m, o, f, howMuch)[q, g][perm$N]}
         IncEpsilons(m, o, f, howMuch)[q, g][perm$N] == ite(o==q && f ==g, m[q, g][perm$N] + howMuch, m[q, g][perm$N])
);

function Havocing<T,U>(h: HeapType, o: ref, f: Field T, newValue: U) returns (HeapType);

axiom (forall<T,U> h: HeapType, o: ref, f: Field T, newValue: U, q: ref, g: Field U :: {Havocing(h, o, f, newValue)[q, g]}
         Havocing(h, o, f, newValue)[q, g] == ite(o==q && f ==g, newValue, h[q, g])
);

function Call$Heap(int) returns (HeapType);
function Call$Mask(int) returns (MaskType);
function Call$SecMask(int) returns (MaskType);
function Call$Credits(int) returns (CreditsType);
function Call$Args(int) returns (ArgSeq);
type ArgSeq = <T>[int]T;

function EmptyMask(m: MaskType) returns (bool);
axiom (forall m: MaskType :: {EmptyMask(m)} EmptyMask(m) <==> (forall<T> o: ref, f: Field T :: NonPredicateField(f) ==> m[o, f][perm$R]<=0 && m[o, f][perm$N]<=0));

const ZeroCredits: CreditsType;
axiom (forall o: ref :: ZeroCredits[o] == 0);
function EmptyCredits(c: CreditsType) returns (bool);
axiom (forall c: CreditsType :: {EmptyCredits(c)} EmptyCredits(c) <==> (forall o: ref :: o != null ==> c[o] == 0));

function NonPredicateField<T>(f: Field T) returns (bool);
function PredicateField<T>(f: Field T) returns (bool);
axiom (forall<T> f: Field T :: NonPredicateField(f) ==> ! PredicateField(f));
axiom (forall<T> f: Field T :: PredicateField(f) ==> ! NonPredicateField(f));

function submask(m1: MaskType, m2: MaskType) returns (bool);

axiom (forall m1: MaskType, m2: MaskType :: {submask(m1, m2)}
  submask(m1, m2) <==> (forall<T> o: ref, f: Field T :: (m1[o, f][perm$R] < m2[o, f][perm$R]) || (m1[o, f][perm$R] == m2[o, f][perm$R] && m1[o, f][perm$N] <= m2[o, f][perm$N]))
);

// ---------------------------------------------------------------
// -- If then else -----------------------------------------------
// ---------------------------------------------------------------

function ite<T>(bool, T, T) returns (T);
axiom (forall<T> con: bool, a: T, b: T :: {ite(con, a, b)} con ==> ite(con, a, b) == a);
axiom (forall<T> con: bool, a: T, b: T :: {ite(con, a, b)} ! con ==> ite(con, a, b) == b);

// ---------------------------------------------------------------
// -- Arithmetic -------------------------------------------------
// ---------------------------------------------------------------

// the connection between % and /
//axiom (forall x:int, y:int :: {x % y} {x / y}  x % y == x - x / y * y);

// sign of denominator determines sign of remainder
//axiom (forall x:int, y:int :: {x % y}  0 < y  ==>  0 <= x % y  &&  x % y < y);
//axiom (forall x:int, y:int :: {x % y}  y < 0  ==>  y < x % y  &&  x % y <= 0);

// the following axiom has some unfortunate matching, but it does state a property about % that
// is sometime useful
//axiom (forall a: int, b: int, d: int :: { a % d, b % d } 2 <= d && a % d == b % d && a < b  ==>  a + d <= b);

// ---------------------------------------------------------------
// -- Strings ----------------------------------------------------
// ---------------------------------------------------------------

type string = int;

// ---------------------------------------------------------------
// -- Axiomatization of sequences --------------------------------
// ---------------------------------------------------------------

type Seq T;

function Seq#Length<T>(Seq T) returns (int);
axiom (forall<T> s: Seq T :: { Seq#Length(s) } 0 <= Seq#Length(s));

function Seq#Empty<T>() returns (Seq T);
axiom (forall<T> :: Seq#Length(Seq#Empty(): Seq T) == 0);
axiom (forall<T> s: Seq T :: { Seq#Length(s) } Seq#Length(s) == 0 ==> s == Seq#Empty());

function Seq#Singleton<T>(T) returns (Seq T);
axiom (forall<T> t: T :: { Seq#Length(Seq#Singleton(t)) } Seq#Length(Seq#Singleton(t)) == 1);

function Seq#Build<T>(s: Seq T, index: int, val: T, newLength: int) returns (Seq T);
axiom (forall<T> s: Seq T, i: int, v: T, len: int :: { Seq#Length(Seq#Build(s,i,v,len)) }
  0 <= len ==> Seq#Length(Seq#Build(s,i,v,len)) == len);

function Seq#Append<T>(Seq T, Seq T) returns (Seq T);
axiom (forall<T> s0: Seq T, s1: Seq T :: { Seq#Length(Seq#Append(s0,s1)) }
  Seq#Length(Seq#Append(s0,s1)) == Seq#Length(s0) + Seq#Length(s1));

function Seq#Index<T>(Seq T, int) returns (T);
axiom (forall<T> t: T :: { Seq#Index(Seq#Singleton(t), 0) } Seq#Index(Seq#Singleton(t), 0) == t);
axiom (forall<T> s0: Seq T, s1: Seq T, n: int :: { Seq#Index(Seq#Append(s0,s1), n) }
  (n < Seq#Length(s0) ==> Seq#Index(Seq#Append(s0,s1), n) == Seq#Index(s0, n)) &&
  (Seq#Length(s0) <= n ==> Seq#Index(Seq#Append(s0,s1), n) == Seq#Index(s1, n - Seq#Length(s0))));
axiom (forall<T> s: Seq T, i: int, v: T, len: int, n: int :: { Seq#Index(Seq#Build(s,i,v,len),n) }
  0 <= n && n < len ==>
    (i == n ==> Seq#Index(Seq#Build(s,i,v,len),n) == v) &&
    (i != n ==> Seq#Index(Seq#Build(s,i,v,len),n) == Seq#Index(s,n)));

function Seq#Contains<T>(Seq T, T) returns (bool);
axiom (forall<T> s: Seq T, x: T :: { Seq#Contains(s,x) }
  Seq#Contains(s,x) <==>
    (exists i: int :: { Seq#Index(s,i) } 0 <= i && i < Seq#Length(s) && Seq#Index(s,i) == x));
axiom (forall x: ref ::
  { Seq#Contains(Seq#Empty(), x) }
  !Seq#Contains(Seq#Empty(), x));
axiom (forall<T> s0: Seq T, s1: Seq T, x: T ::
  { Seq#Contains(Seq#Append(s0, s1), x) }
  Seq#Contains(Seq#Append(s0, s1), x) <==>
    Seq#Contains(s0, x) || Seq#Contains(s1, x));
axiom (forall<T> s: Seq T, i: int, v: T, len: int, x: T ::
  { Seq#Contains(Seq#Build(s, i, v, len), x) }
  Seq#Contains(Seq#Build(s, i, v, len), x) <==>
    (0 <= i && i < len && x == v)  ||  
    (exists j: int :: { Seq#Index(s,j) } 0 <= j && j < Seq#Length(s) && j < len && j!=i && Seq#Index(s,j) == x));
axiom (forall<T> s: Seq T, n: int, x: T ::
  { Seq#Contains(Seq#Take(s, n), x) }
  Seq#Contains(Seq#Take(s, n), x) <==>
    (exists i: int :: { Seq#Index(s, i) }
      0 <= i && i < n && i < Seq#Length(s) && Seq#Index(s, i) == x));
axiom (forall<T> s: Seq T, n: int, x: T ::
  { Seq#Contains(Seq#Drop(s, n), x) }
  Seq#Contains(Seq#Drop(s, n), x) <==>
    (exists i: int :: { Seq#Index(s, i) }
      0 <= n && n <= i && i < Seq#Length(s) && Seq#Index(s, i) == x));

function Seq#Equal<T>(Seq T, Seq T) returns (bool);
axiom (forall<T> s0: Seq T, s1: Seq T :: { Seq#Equal(s0,s1) }
  Seq#Equal(s0,s1) <==>
    Seq#Length(s0) == Seq#Length(s1) &&
    (forall j: int :: { Seq#Index(s0,j) } { Seq#Index(s1,j) }
        0 <= j && j < Seq#Length(s0) ==> Seq#Index(s0,j) == Seq#Index(s1,j)));
axiom(forall<T> a: Seq T, b: Seq T :: { Seq#Equal(a,b) }  // extensionality axiom for sequences
  Seq#Equal(a,b) ==> a == b);

function Seq#SameUntil<T>(Seq T, Seq T, int) returns (bool);
axiom (forall<T> s0: Seq T, s1: Seq T, n: int :: { Seq#SameUntil(s0,s1,n) }
  Seq#SameUntil(s0,s1,n) <==>
    (forall j: int :: { Seq#Index(s0,j) } { Seq#Index(s1,j) }
        0 <= j && j < n ==> Seq#Index(s0,j) == Seq#Index(s1,j)));

function Seq#Take<T>(s: Seq T, howMany: int) returns (Seq T);
axiom (forall<T> s: Seq T, n: int :: { Seq#Length(Seq#Take(s,n)) }
  0 <= n ==>
    (n <= Seq#Length(s) ==> Seq#Length(Seq#Take(s,n)) == n) &&
    (Seq#Length(s) < n ==> Seq#Length(Seq#Take(s,n)) == Seq#Length(s)));
axiom (forall<T> s: Seq T, n: int, j: int :: { Seq#Index(Seq#Take(s,n), j) } {:weight 25}
  0 <= j && j < n && j < Seq#Length(s) ==>
    Seq#Index(Seq#Take(s,n), j) == Seq#Index(s, j));

function Seq#Drop<T>(s: Seq T, howMany: int) returns (Seq T);
axiom (forall<T> s: Seq T, n: int :: { Seq#Length(Seq#Drop(s,n)) }
  0 <= n ==>
    (n <= Seq#Length(s) ==> Seq#Length(Seq#Drop(s,n)) == Seq#Length(s) - n) &&
    (Seq#Length(s) < n ==> Seq#Length(Seq#Drop(s,n)) == 0));
axiom (forall<T> s: Seq T, n: int, j: int :: { Seq#Index(Seq#Drop(s,n), j) } {:weight 25}
  0 <= n && 0 <= j && j < Seq#Length(s)-n ==>
    Seq#Index(Seq#Drop(s,n), j) == Seq#Index(s, j+n));

axiom (forall<T> s, t: Seq T ::
  { Seq#Append(s, t) }
  Seq#Take(Seq#Append(s, t), Seq#Length(s)) == s &&
  Seq#Drop(Seq#Append(s, t), Seq#Length(s)) == t);

function Seq#Range(min: int, max: int) returns (Seq int);

axiom (forall min: int, max: int :: { Seq#Length(Seq#Range(min, max)) } (min < max ==> Seq#Length(Seq#Range(min, max)) == max-min) && (max <= min ==> Seq#Length(Seq#Range(min, max)) == 0));
axiom (forall min: int, max: int, j: int :: { Seq#Index(Seq#Range(min, max), j) } 0<=j && j<max-min ==> Seq#Index(Seq#Range(min, max), j) == min + j);

axiom (forall<T> x, y: T ::
  { Seq#Contains(Seq#Singleton(x),y) }
    Seq#Contains(Seq#Singleton(x),y) <==> x==y);

// ---------------------------------------------------------------
// -- End of prelude ---------------------------------------------
// ---------------------------------------------------------------

const unique AVLTree#t: TypeName;
const unique module#default: ModuleName;
procedure AVLTree$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_9: int;
  var h0#_0: HeapType;
  var m0#_1: MaskType;
  var sm0#_2: MaskType;
  var c0#_3: CreditsType;
  var h1#_4: HeapType;
  var m1#_5: MaskType;
  var sm1#_6: MaskType;
  var c1#_7: CreditsType;
  var lk#_8: ref;
  assume (0 < methodK#_9) && ((1000 * methodK#_9) < Fractions(1));
  assume wf(h0#_0, m0#_1, sm0#_2);
  assume wf(h1#_4, m1#_5, sm1#_6);
  m1#_5 := ZeroMask;
  sm1#_6 := ZeroMask;
  c1#_7 := ZeroCredits;
  havoc h1#_4;
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  3.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique AVLTree.root: Field (ref);
axiom NonPredicateField(AVLTree.root);
const unique AVLTree.keys: Field (Seq (int));
axiom NonPredicateField(AVLTree.keys);
const unique AVLTree.valid: Field (int);
axiom PredicateField(AVLTree.valid);
function #AVLTree.valid#trigger(this: ref) returns ($myresult: bool);
procedure AVLTree.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var predicateK#_10: int;
  assume (0 < predicateK#_10) && ((1000 * predicateK#_10) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.root]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  12.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  12.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  12.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  12.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
    assert {:msg "  12.22: Receiver might be null."} Heap[this, AVLTree.root] != null;
    assert {:msg "  12.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  12.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  13.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  13.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  13.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  13.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  14.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  14.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  14.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  14.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  15.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  15.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  15.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  15.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  16.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  16.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  16.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  16.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.keys);
    assert {:msg "  16.30: Receiver might be null."} true ==> (this != null);
    assert {:msg "  16.30: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
    assert {:msg "  16.30: Receiver might be null."} true ==> (Heap[this, AVLTree.root] != null);
    assert {:msg "  16.30: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTree.root], AVLTreeNode.keys);
    assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  assert {:msg "  17.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  17.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  17.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  17.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.keys);
    assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTree.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_11: int;
  assume (0 < methodK#_11) && ((1000 * methodK#_11) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.root]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  25.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  27.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  27.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.keys);
  assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTree.init(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_11: int;
  var foldK#_15: int;
  var exhaleMask#_17: MaskType;
  var exhaleHeap#_16: HeapType;
  var predRec#_12: ref;
  var predVer#_13: int;
  var predFlag#_14: bool;
  var exhaleMask#_25: MaskType;
  var exhaleHeap#_24: HeapType;
  assume (0 < methodK#_11) && ((1000 * methodK#_11) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.root]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // update field root
  assert {:msg "  29.3: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
  Heap[this, AVLTree.root] := null;
  assume wf(Heap, Mask, SecMask);
  // update field keys
  assert {:msg "  30.3: Location might not be writable"} CanWrite(Mask, this, AVLTree.keys);
  Heap[this, AVLTree.keys] := Seq#Empty();
  assume wf(Heap, Mask, SecMask);
  // fold
  assume #AVLTree.valid#trigger(this);
  assume (0 < foldK#_15) && ((1000 * foldK#_15) < Fractions(1)) && ((1000 * foldK#_15) < methodK#_11);
  assert {:msg "  31.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_17 := Mask;
  havoc exhaleHeap#_16;
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 16.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 17.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 10.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} (Fractions(100) <= exhaleMask#_17[this, AVLTree.root][perm$R]) && ((Fractions(100) == exhaleMask#_17[this, AVLTree.root][perm$R]) ==> (0 <= exhaleMask#_17[this, AVLTree.root][perm$N]));
  exhaleMask#_17[this, AVLTree.root] := exhaleMask#_17[this, AVLTree.root][perm$R := exhaleMask#_17[this, AVLTree.root][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := SecMask[this, AVLTree.root][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_17);
  assume wf(Heap, exhaleMask#_17, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 11.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 11.6 for AVLTree.keys."} (Fractions(50) <= exhaleMask#_17[this, AVLTree.keys][perm$R]) && ((Fractions(50) == exhaleMask#_17[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_17[this, AVLTree.keys][perm$N]));
  exhaleMask#_17[this, AVLTree.keys] := exhaleMask#_17[this, AVLTree.keys][perm$R := exhaleMask#_17[this, AVLTree.keys][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := SecMask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_17);
  assume wf(Heap, exhaleMask#_17, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 12.22 might not be positive."} Fractions(100) > 0;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.valid] := exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - Fractions(100)];
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + Fractions(100)];
    if (!CanRead(exhaleMask#_17, SecMask, Heap[this, AVLTree.root], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTree.root], AVLTreeNode.valid] < exhaleHeap#_16[Heap[this, AVLTree.root], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_17);
    assume wf(Heap, exhaleMask#_17, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 13.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 13.22 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.height][perm$N]));
    exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.height] := exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_17);
    assume wf(Heap, exhaleMask#_17, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 14.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 14.22 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$N]));
    exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.keys] := exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_17);
    assume wf(Heap, exhaleMask#_17, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 15.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 15.22 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_17[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_17);
    assume wf(Heap, exhaleMask#_17, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_17;
  assume IsGoodExhaleState(exhaleHeap#_16, Heap, Mask, SecMask);
  Heap := exhaleHeap#_16;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  predRec#_12 := this;
  predVer#_13 := Heap[this, AVLTree.valid];
  predFlag#_14 := true;
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_25 := Mask;
  havoc exhaleHeap#_24;
  assert {:msg "  21.2: The postcondition at 27.11 might not hold. The expression at 27.11 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  assert {:msg "  21.2: The postcondition at 25.11 might not hold. The permission at 25.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  21.2: The postcondition at 25.11 might not hold. Insufficient fraction at 25.11 for AVLTree.valid."} (Fractions(100) <= exhaleMask#_25[this, AVLTree.valid][perm$R]) && ((Fractions(100) == exhaleMask#_25[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_25[this, AVLTree.valid][perm$N]));
  exhaleMask#_25[this, AVLTree.valid] := exhaleMask#_25[this, AVLTree.valid][perm$R := exhaleMask#_25[this, AVLTree.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_13 == Heap[this, AVLTree.valid]) && (predRec#_12 == this) && true && predFlag#_14)) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTree.root] == null)) {
      //  assert <undefined position>:  The expression at 16.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    }
    if (Heap[this, AVLTree.root] == null) {
      //  assert <undefined position>:  The expression at 17.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
    }
    SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := SecMask[this, AVLTree.root][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTree.root][perm$R] < 0) {
      SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := SecMask[this, AVLTree.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTree.keys][perm$R] < 0) {
      SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(exhaleMask#_25, SecMask, this, AVLTree.valid)) {
    assume Heap[this, AVLTree.valid] < exhaleHeap#_24[this, AVLTree.valid];
  }
  assume IsGoodMask(exhaleMask#_25);
  assume wf(Heap, exhaleMask#_25, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  21.2: The postcondition at 26.11 might not hold. The permission at 26.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  21.2: The postcondition at 26.11 might not hold. Insufficient fraction at 26.11 for AVLTree.keys."} (Fractions(50) <= exhaleMask#_25[this, AVLTree.keys][perm$R]) && ((Fractions(50) == exhaleMask#_25[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_25[this, AVLTree.keys][perm$N]));
  exhaleMask#_25[this, AVLTree.keys] := exhaleMask#_25[this, AVLTree.keys][perm$R := exhaleMask#_25[this, AVLTree.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_25);
  assume wf(Heap, exhaleMask#_25, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_25;
  assume IsGoodExhaleState(exhaleHeap#_24, Heap, Mask, SecMask);
  Heap := exhaleHeap#_24;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  21.2: Method might lock/unlock more than allowed."} (forall lk#_36: ref :: {Heap[lk#_36, held]} {Heap[lk#_36, rdheld]} (((0 < Heap[lk#_36, held]) == (0 < old(Heap)[lk#_36, held])) && (Heap[lk#_36, rdheld] == old(Heap)[lk#_36, rdheld])) || false);
  assert {:msg "  21.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTree.insert$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#0: int where true) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_37: int;
  var j#73#115: int where true;
  var j#74#117: int where true;
  assume (0 < methodK#_37) && ((1000 * methodK#_37) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  36.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  39.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  42.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  42.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.keys);
  assume Seq#Contains(Heap[this, AVLTree.keys], k#0);
  assert {:msg "  43.11: Receiver might be null."} true && (0 <= j#73#115) ==> (this != null);
  assert {:msg "  43.11: Location might not be readable."} true && (0 <= j#73#115) ==> CanRead(old(Mask), old(SecMask), this, AVLTree.keys);
  assert {:msg "  43.11: Receiver might be null."} true && (0 <= j#73#115) && (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  43.11: Location might not be readable."} true && (0 <= j#73#115) && (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> CanRead(old(Mask), old(SecMask), this, AVLTree.keys);
  assert {:msg "  43.36: Sequence index might be negative."} true && (0 <= j#73#115) && (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (0 <= j#73#115);
  assert {:msg "  43.36: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#73#115) && (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys]));
  assert {:msg "  43.41: Receiver might be null."} true && (0 <= j#73#115) && (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  43.41: Location might not be readable."} true && (0 <= j#73#115) && (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> CanRead(Mask, SecMask, this, AVLTree.keys);
  assume (forall j#73#114: int :: (0 <= j#73#114) && (j#73#114 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#73#114)));
  assert {:msg "  44.11: Receiver might be null."} true && (0 <= j#74#117) ==> (this != null);
  assert {:msg "  44.11: Location might not be readable."} true && (0 <= j#74#117) ==> CanRead(Mask, SecMask, this, AVLTree.keys);
  assert {:msg "  44.11: Receiver might be null."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  44.11: Location might not be readable."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> CanRead(Mask, SecMask, this, AVLTree.keys);
  assert {:msg "  44.33: Sequence index might be negative."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> (0 <= j#74#117);
  assert {:msg "  44.33: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> (j#74#117 < Seq#Length(Heap[this, AVLTree.keys]));
  assert {:msg "  44.42: Receiver might be null."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  44.42: Location might not be readable."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> CanRead(old(Mask), old(SecMask), this, AVLTree.keys);
  assert {:msg "  44.11: Receiver might be null."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) && (!Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#74#117))) ==> (this != null);
  assert {:msg "  44.11: Location might not be readable."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) && (!Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#74#117))) ==> CanRead(Mask, SecMask, this, AVLTree.keys);
  assert {:msg "  44.33: Sequence index might be negative."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) && (!Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#74#117))) ==> (0 <= j#74#117);
  assert {:msg "  44.33: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) && (!Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#74#117))) ==> (j#74#117 < Seq#Length(Heap[this, AVLTree.keys]));
  assume (forall j#74#116: int :: (0 <= j#74#116) && (j#74#116 < Seq#Length(Heap[this, AVLTree.keys])) ==> (Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#74#116)) || (Seq#Index(Heap[this, AVLTree.keys], j#74#116) == k#0)));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTree.insert(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#0: int where true) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_37: int;
  var unfoldK#_38: int;
  var oldVers#_50: int;
  var newVers#_51: int;
  var cond#_52: bool;
  var n#2: ref where (n#2 == null) || (dtype(n#2) == AVLTreeNode#t);
  var nw#_53: ref;
  var methodCallK#_58: int;
  var this#118: ref where (this#118 == null) || (dtype(this#118) == AVLTreeNode#t);
  var k#119: int where true;
  var callHeap#_54: HeapType;
  var callMask#_55: MaskType;
  var callSecMask#_56: MaskType;
  var callCredits#_57: CreditsType;
  var exhaleMask#_60: MaskType;
  var exhaleHeap#_59: HeapType;
  var isHeld#_67: int;
  var isRdHeld#_68: bool;
  var methodCallK#_73: int;
  var this#120: ref where (this#120 == null) || (dtype(this#120) == AVLTreeNode#t);
  var k#121: int where true;
  var r#122: ref where (r#122 == null) || (dtype(r#122) == AVLTreeNode#t);
  var callHeap#_69: HeapType;
  var callMask#_70: MaskType;
  var callSecMask#_71: MaskType;
  var callCredits#_72: CreditsType;
  var exhaleMask#_75: MaskType;
  var exhaleHeap#_74: HeapType;
  var isHeld#_80: int;
  var isRdHeld#_81: bool;
  var r#75: ref where (r#75 == null) || (dtype(r#75) == AVLTreeNode#t);
  var foldK#_85: int;
  var exhaleMask#_87: MaskType;
  var exhaleHeap#_86: HeapType;
  var predRec#_82: ref;
  var predVer#_83: int;
  var predFlag#_84: bool;
  var exhaleMask#_95: MaskType;
  var exhaleHeap#_94: HeapType;
  assume (0 < methodK#_37) && ((1000 * methodK#_37) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // unfold
  assume #AVLTree.valid#trigger(this);
  assume (0 < unfoldK#_38) && (unfoldK#_38 < Fractions(1)) && ((1000 * unfoldK#_38) < methodK#_37);
  assert {:msg "  46.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  46.3: unfold might fail because the predicate AVLTree.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  46.3: unfold might fail because the predicate AVLTree.valid does not hold. Insufficient fraction at <undefined position> for AVLTree.valid."} (Fractions(100) <= Mask[this, AVLTree.valid][perm$R]) && ((Fractions(100) == Mask[this, AVLTree.valid][perm$R]) ==> (0 <= Mask[this, AVLTree.valid][perm$N]));
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTree.root] == null)) {
      //  assert <undefined position>:  The expression at 16.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    }
    if (Heap[this, AVLTree.root] == null) {
      //  assert <undefined position>:  The expression at 17.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
    }
    SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := SecMask[this, AVLTree.root][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTree.root][perm$R] < 0) {
      SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := SecMask[this, AVLTree.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTree.keys][perm$R] < 0) {
      SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, this, AVLTree.valid)) {
    oldVers#_50 := Heap[this, AVLTree.valid];
    havoc newVers#_51;
    Heap[this, AVLTree.valid] := newVers#_51;
    assume oldVers#_50 < Heap[this, AVLTree.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.root]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_52 := Heap[this, AVLTree.root] == null;
  assert {:msg "  47.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  47.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
  if (cond#_52) {
    // local var n
    // assigment to n
    // new
    havoc nw#_53;
    assume (nw#_53 != null) && (dtype(nw#_53) == AVLTreeNode#t);
    assume (forall<T#_0> f: Field (T#_0) :: (Mask[nw#_53, f][perm$R] == 0) && (Mask[nw#_53, f][perm$N] == 0));
    assume Heap[nw#_53, mu] == $LockBottom;
    assume Heap[nw#_53, held] <= 0;
    assume Heap[nw#_53, rdheld] == false;
    Mask[nw#_53, AVLTreeNode.key] := Mask[nw#_53, AVLTreeNode.key][perm$R := Mask[nw#_53, AVLTreeNode.key][perm$R] + Fractions(100)];
    Mask[nw#_53, AVLTreeNode.height] := Mask[nw#_53, AVLTreeNode.height][perm$R := Mask[nw#_53, AVLTreeNode.height][perm$R] + Fractions(100)];
    Mask[nw#_53, AVLTreeNode.left] := Mask[nw#_53, AVLTreeNode.left][perm$R := Mask[nw#_53, AVLTreeNode.left][perm$R] + Fractions(100)];
    Mask[nw#_53, AVLTreeNode.right] := Mask[nw#_53, AVLTreeNode.right][perm$R := Mask[nw#_53, AVLTreeNode.right][perm$R] + Fractions(100)];
    Mask[nw#_53, AVLTreeNode.keys] := Mask[nw#_53, AVLTreeNode.keys][perm$R := Mask[nw#_53, AVLTreeNode.keys][perm$R] + Fractions(100)];
    Mask[nw#_53, AVLTreeNode.balanceFactor] := Mask[nw#_53, AVLTreeNode.balanceFactor][perm$R := Mask[nw#_53, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
    Mask[nw#_53, mu] := Mask[nw#_53, mu][perm$R := Mask[nw#_53, mu][perm$R] + Fractions(100)];
    n#2 := nw#_53;
    assume (0 < methodCallK#_58) && ((1000 * methodCallK#_58) < Fractions(1)) && ((1000 * methodCallK#_58) < methodK#_37);
    // call init
    callHeap#_54 := Heap;
    callMask#_55 := Mask;
    callSecMask#_56 := SecMask;
    callCredits#_57 := Credits;
    assume wf(callHeap#_54, callMask#_55, callSecMask#_56);
    assert {:msg "  49.4: The target of the method call might be null."} n#2 != null;
    this#118 := n#2;
    k#119 := k#0;
    // begin exhale (precondition)
    exhaleMask#_60 := Mask;
    havoc exhaleHeap#_59;
    assert {:msg "  49.4: The precondition at 155.12 might not hold. The permission at 155.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  49.4: The precondition at 155.12 might not hold. Insufficient fraction at 155.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_60[this#118, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_60[this#118, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_60[this#118, AVLTreeNode.key][perm$N]));
    exhaleMask#_60[this#118, AVLTreeNode.key] := exhaleMask#_60[this#118, AVLTreeNode.key][perm$R := exhaleMask#_60[this#118, AVLTreeNode.key][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_60);
    assume wf(Heap, exhaleMask#_60, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  49.4: The precondition at 156.12 might not hold. The permission at 156.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  49.4: The precondition at 156.12 might not hold. Insufficient fraction at 156.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_60[this#118, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_60[this#118, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_60[this#118, AVLTreeNode.height][perm$N]));
    exhaleMask#_60[this#118, AVLTreeNode.height] := exhaleMask#_60[this#118, AVLTreeNode.height][perm$R := exhaleMask#_60[this#118, AVLTreeNode.height][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_60);
    assume wf(Heap, exhaleMask#_60, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  49.4: The precondition at 157.12 might not hold. The permission at 157.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  49.4: The precondition at 157.12 might not hold. Insufficient fraction at 157.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_60[this#118, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_60[this#118, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_60[this#118, AVLTreeNode.left][perm$N]));
    exhaleMask#_60[this#118, AVLTreeNode.left] := exhaleMask#_60[this#118, AVLTreeNode.left][perm$R := exhaleMask#_60[this#118, AVLTreeNode.left][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_60);
    assume wf(Heap, exhaleMask#_60, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  49.4: The precondition at 158.12 might not hold. The permission at 158.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  49.4: The precondition at 158.12 might not hold. Insufficient fraction at 158.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_60[this#118, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_60[this#118, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_60[this#118, AVLTreeNode.right][perm$N]));
    exhaleMask#_60[this#118, AVLTreeNode.right] := exhaleMask#_60[this#118, AVLTreeNode.right][perm$R := exhaleMask#_60[this#118, AVLTreeNode.right][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_60);
    assume wf(Heap, exhaleMask#_60, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  49.4: The precondition at 160.12 might not hold. The permission at 160.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  49.4: The precondition at 160.12 might not hold. Insufficient fraction at 160.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_60[this#118, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_60[this#118, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_60[this#118, AVLTreeNode.keys][perm$N]));
    exhaleMask#_60[this#118, AVLTreeNode.keys] := exhaleMask#_60[this#118, AVLTreeNode.keys][perm$R := exhaleMask#_60[this#118, AVLTreeNode.keys][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_60);
    assume wf(Heap, exhaleMask#_60, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  49.4: The precondition at 161.12 might not hold. The permission at 161.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  49.4: The precondition at 161.12 might not hold. Insufficient fraction at 161.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_60[this#118, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_60[this#118, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_60[this#118, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_60[this#118, AVLTreeNode.balanceFactor] := exhaleMask#_60[this#118, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_60[this#118, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_60);
    assume wf(Heap, exhaleMask#_60, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_60;
    assume IsGoodExhaleState(exhaleHeap#_59, Heap, Mask, SecMask);
    Heap := exhaleHeap#_59;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    // inhale (postcondition)
    assume this#118 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[this#118, AVLTreeNode.valid] := Mask[this#118, AVLTreeNode.valid][perm$R := Mask[this#118, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#118, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#118 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[this#118, AVLTreeNode.keys] := Mask[this#118, AVLTreeNode.keys][perm$R := Mask[this#118, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#118, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#118 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[this#118, AVLTreeNode.height] := Mask[this#118, AVLTreeNode.height][perm$R := Mask[this#118, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#118, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#118 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[this#118, AVLTreeNode.balanceFactor] := Mask[this#118, AVLTreeNode.balanceFactor][perm$R := Mask[this#118, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#118, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Heap[this#118, AVLTreeNode.height] == 1;
    assume Seq#Equal(Heap[this#118, AVLTreeNode.keys], Seq#Singleton(k#119));
    assume Heap[this#118, AVLTreeNode.balanceFactor] == 0;
    assume Seq#Contains(Heap[this#118, AVLTreeNode.keys], k#119);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    // update field root
    assert {:msg "  50.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
    Heap[this, AVLTree.root] := n#2;
    assume wf(Heap, Mask, SecMask);
  } else {
    assume (0 < methodCallK#_73) && ((1000 * methodCallK#_73) < Fractions(1)) && ((1000 * methodCallK#_73) < methodK#_37);
    // call insert
    callHeap#_69 := Heap;
    callMask#_70 := Mask;
    callSecMask#_71 := SecMask;
    callCredits#_72 := Credits;
    assume wf(callHeap#_69, callMask#_70, callSecMask#_71);
    assert {:msg "  52.14: Receiver might be null."} true ==> (this != null);
    assert {:msg "  52.14: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
    assert {:msg "  52.4: The target of the method call might be null."} Heap[this, AVLTree.root] != null;
    this#120 := Heap[this, AVLTree.root];
    k#121 := k#0;
    // begin exhale (precondition)
    exhaleMask#_75 := Mask;
    havoc exhaleHeap#_74;
    assert {:msg "  52.4: The precondition at 185.12 might not hold. The permission at 185.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  52.4: The precondition at 185.12 might not hold. Insufficient fraction at 185.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_75[this#120, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_75[this#120, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_75[this#120, AVLTreeNode.valid][perm$N]));
    exhaleMask#_75[this#120, AVLTreeNode.valid] := exhaleMask#_75[this#120, AVLTreeNode.valid][perm$R := exhaleMask#_75[this#120, AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_75, SecMask, this#120, AVLTreeNode.valid)) {
      assume Heap[this#120, AVLTreeNode.valid] < exhaleHeap#_74[this#120, AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_75);
    assume wf(Heap, exhaleMask#_75, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  52.4: The precondition at 186.12 might not hold. The permission at 186.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  52.4: The precondition at 186.12 might not hold. Insufficient fraction at 186.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_75[this#120, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_75[this#120, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_75[this#120, AVLTreeNode.keys][perm$N]));
    exhaleMask#_75[this#120, AVLTreeNode.keys] := exhaleMask#_75[this#120, AVLTreeNode.keys][perm$R := exhaleMask#_75[this#120, AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_75);
    assume wf(Heap, exhaleMask#_75, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  52.4: The precondition at 187.12 might not hold. The permission at 187.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  52.4: The precondition at 187.12 might not hold. Insufficient fraction at 187.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_75[this#120, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_75[this#120, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_75[this#120, AVLTreeNode.height][perm$N]));
    exhaleMask#_75[this#120, AVLTreeNode.height] := exhaleMask#_75[this#120, AVLTreeNode.height][perm$R := exhaleMask#_75[this#120, AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_75);
    assume wf(Heap, exhaleMask#_75, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  52.4: The precondition at 188.12 might not hold. The permission at 188.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  52.4: The precondition at 188.12 might not hold. Insufficient fraction at 188.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_75[this#120, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_75[this#120, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_75[this#120, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_75[this#120, AVLTreeNode.balanceFactor] := exhaleMask#_75[this#120, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_75[this#120, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_75);
    assume wf(Heap, exhaleMask#_75, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_75;
    assume IsGoodExhaleState(exhaleHeap#_74, Heap, Mask, SecMask);
    Heap := exhaleHeap#_74;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#122;
    // inhale (postcondition)
    assume !(r#122 == null);
    assume r#122 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[r#122, AVLTreeNode.valid] := Mask[r#122, AVLTreeNode.valid][perm$R := Mask[r#122, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#122, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#122 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#122, AVLTreeNode.keys] := Mask[r#122, AVLTreeNode.keys][perm$R := Mask[r#122, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#122, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#122 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#122, AVLTreeNode.height] := Mask[r#122, AVLTreeNode.height][perm$R := Mask[r#122, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#122, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#122 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#122, AVLTreeNode.balanceFactor] := Mask[r#122, AVLTreeNode.balanceFactor][perm$R := Mask[r#122, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#122, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Seq#Contains(Heap[r#122, AVLTreeNode.keys], k#121);
    assume (forall i#82#123: int :: (0 <= i#82#123) && (i#82#123 < Seq#Length(callHeap#_69[this#120, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#122, AVLTreeNode.keys], Seq#Index(callHeap#_69[this#120, AVLTreeNode.keys], i#82#123)));
    assume (forall i#83#124: int :: (0 <= i#83#124) && (i#83#124 < Seq#Length(Heap[r#122, AVLTreeNode.keys])) ==> (Seq#Contains(callHeap#_69[this#120, AVLTreeNode.keys], Seq#Index(Heap[r#122, AVLTreeNode.keys], i#83#124)) || (Seq#Index(Heap[r#122, AVLTreeNode.keys], i#83#124) == k#121)));
    if (Seq#Contains(callHeap#_69[this#120, AVLTreeNode.keys], k#121)) {
      assume Seq#Equal(Heap[r#122, AVLTreeNode.keys], callHeap#_69[this#120, AVLTreeNode.keys]);
    }
    if (!Seq#Contains(callHeap#_69[this#120, AVLTreeNode.keys], k#121)) {
      assume Seq#Length(Heap[r#122, AVLTreeNode.keys]) == (Seq#Length(callHeap#_69[this#120, AVLTreeNode.keys]) + 1);
    }
    assume (Heap[r#122, AVLTreeNode.height] == callHeap#_69[this#120, AVLTreeNode.height]) || (Heap[r#122, AVLTreeNode.height] == (callHeap#_69[this#120, AVLTreeNode.height] + 1));
    if (Seq#Contains(callHeap#_69[this#120, AVLTreeNode.keys], k#121)) {
      assume Heap[r#122, AVLTreeNode.height] == callHeap#_69[this#120, AVLTreeNode.height];
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    r#75 := r#122;
    // update field root
    assert {:msg "  53.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
    Heap[this, AVLTree.root] := r#75;
    assume wf(Heap, Mask, SecMask);
  }
  // update field keys
  assert {:msg "  55.3: Location might not be writable"} CanWrite(Mask, this, AVLTree.keys);
  assert {:msg "  55.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  55.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
  assert {:msg "  55.11: Receiver might be null."} true ==> (Heap[this, AVLTree.root] != null);
  assert {:msg "  55.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTree.root], AVLTreeNode.keys);
  Heap[this, AVLTree.keys] := Heap[Heap[this, AVLTree.root], AVLTreeNode.keys];
  assume wf(Heap, Mask, SecMask);
  // fold
  assume #AVLTree.valid#trigger(this);
  assume (0 < foldK#_85) && ((1000 * foldK#_85) < Fractions(1)) && ((1000 * foldK#_85) < methodK#_37);
  assert {:msg "  56.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_87 := Mask;
  havoc exhaleHeap#_86;
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 16.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 17.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 10.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} (Fractions(100) <= exhaleMask#_87[this, AVLTree.root][perm$R]) && ((Fractions(100) == exhaleMask#_87[this, AVLTree.root][perm$R]) ==> (0 <= exhaleMask#_87[this, AVLTree.root][perm$N]));
  exhaleMask#_87[this, AVLTree.root] := exhaleMask#_87[this, AVLTree.root][perm$R := exhaleMask#_87[this, AVLTree.root][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := SecMask[this, AVLTree.root][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_87);
  assume wf(Heap, exhaleMask#_87, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 11.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 11.6 for AVLTree.keys."} (Fractions(50) <= exhaleMask#_87[this, AVLTree.keys][perm$R]) && ((Fractions(50) == exhaleMask#_87[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_87[this, AVLTree.keys][perm$N]));
  exhaleMask#_87[this, AVLTree.keys] := exhaleMask#_87[this, AVLTree.keys][perm$R := exhaleMask#_87[this, AVLTree.keys][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := SecMask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_87);
  assume wf(Heap, exhaleMask#_87, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 12.22 might not be positive."} Fractions(100) > 0;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.valid] := exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - Fractions(100)];
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + Fractions(100)];
    if (!CanRead(exhaleMask#_87, SecMask, Heap[this, AVLTree.root], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTree.root], AVLTreeNode.valid] < exhaleHeap#_86[Heap[this, AVLTree.root], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_87);
    assume wf(Heap, exhaleMask#_87, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 13.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 13.22 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.height][perm$N]));
    exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.height] := exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_87);
    assume wf(Heap, exhaleMask#_87, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 14.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 14.22 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$N]));
    exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.keys] := exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_87);
    assume wf(Heap, exhaleMask#_87, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 15.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 15.22 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_87[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_87);
    assume wf(Heap, exhaleMask#_87, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_87;
  assume IsGoodExhaleState(exhaleHeap#_86, Heap, Mask, SecMask);
  Heap := exhaleHeap#_86;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  predRec#_82 := this;
  predVer#_83 := Heap[this, AVLTree.valid];
  predFlag#_84 := true;
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_95 := Mask;
  havoc exhaleHeap#_94;
  assert {:msg "  35.2: The postcondition at 42.11 might not hold. The expression at 42.11 might not evaluate to true."} Seq#Contains(Heap[this, AVLTree.keys], k#0);
  assert {:msg "  35.2: The postcondition at 43.11 might not hold. The expression at 43.11 might not evaluate to true."} (forall j#73#125: int :: (0 <= j#73#125) && (j#73#125 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#73#125)));
  assert {:msg "  35.2: The postcondition at 44.11 might not hold. The expression at 44.11 might not evaluate to true."} (forall j#74#126: int :: (0 <= j#74#126) && (j#74#126 < Seq#Length(Heap[this, AVLTree.keys])) ==> (Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#74#126)) || (Seq#Index(Heap[this, AVLTree.keys], j#74#126) == k#0)));
  assert {:msg "  35.2: The postcondition at 39.11 might not hold. The permission at 39.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  35.2: The postcondition at 39.11 might not hold. Insufficient fraction at 39.11 for AVLTree.valid."} (Fractions(100) <= exhaleMask#_95[this, AVLTree.valid][perm$R]) && ((Fractions(100) == exhaleMask#_95[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_95[this, AVLTree.valid][perm$N]));
  exhaleMask#_95[this, AVLTree.valid] := exhaleMask#_95[this, AVLTree.valid][perm$R := exhaleMask#_95[this, AVLTree.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_83 == Heap[this, AVLTree.valid]) && (predRec#_82 == this) && true && (!cond#_52) && predFlag#_84)) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTree.root] == null)) {
      //  assert <undefined position>:  The expression at 16.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    }
    if (Heap[this, AVLTree.root] == null) {
      //  assert <undefined position>:  The expression at 17.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
    }
    SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := SecMask[this, AVLTree.root][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTree.root][perm$R] < 0) {
      SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := SecMask[this, AVLTree.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTree.keys][perm$R] < 0) {
      SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(exhaleMask#_95, SecMask, this, AVLTree.valid)) {
    assume Heap[this, AVLTree.valid] < exhaleHeap#_94[this, AVLTree.valid];
  }
  assume IsGoodMask(exhaleMask#_95);
  assume wf(Heap, exhaleMask#_95, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  35.2: The postcondition at 40.11 might not hold. The permission at 40.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  35.2: The postcondition at 40.11 might not hold. Insufficient fraction at 40.11 for AVLTree.keys."} (Fractions(50) <= exhaleMask#_95[this, AVLTree.keys][perm$R]) && ((Fractions(50) == exhaleMask#_95[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_95[this, AVLTree.keys][perm$N]));
  exhaleMask#_95[this, AVLTree.keys] := exhaleMask#_95[this, AVLTree.keys][perm$R := exhaleMask#_95[this, AVLTree.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_95);
  assume wf(Heap, exhaleMask#_95, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_95;
  assume IsGoodExhaleState(exhaleHeap#_94, Heap, Mask, SecMask);
  Heap := exhaleHeap#_94;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  35.2: Method might lock/unlock more than allowed."} (forall lk#_106: ref :: {Heap[lk#_106, held]} {Heap[lk#_106, rdheld]} (((0 < Heap[lk#_106, held]) == (0 < old(Heap)[lk#_106, held])) && (Heap[lk#_106, rdheld] == old(Heap)[lk#_106, rdheld])) || false);
  assert {:msg "  35.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTree.remove$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#3: int where true) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_107: int;
  var j#76#130: int where true;
  var j#77#132: int where true;
  assume (0 < methodK#_107) && ((1000 * methodK#_107) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  61.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  64.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  67.18: Receiver might be null."} true ==> (this != null);
  assert {:msg "  67.18: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.keys);
  assume !Seq#Contains(Heap[this, AVLTree.keys], k#3);
  assert {:msg "  68.11: Receiver might be null."} true && (0 <= j#76#130) ==> (this != null);
  assert {:msg "  68.11: Location might not be readable."} true && (0 <= j#76#130) ==> CanRead(old(Mask), old(SecMask), this, AVLTree.keys);
  assert {:msg "  68.11: Receiver might be null."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  68.11: Location might not be readable."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> CanRead(old(Mask), old(SecMask), this, AVLTree.keys);
  assert {:msg "  68.36: Sequence index might be negative."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (0 <= j#76#130);
  assert {:msg "  68.36: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys]));
  assert {:msg "  68.41: Receiver might be null."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  68.41: Location might not be readable."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> CanRead(Mask, SecMask, this, AVLTree.keys);
  assert {:msg "  68.11: Receiver might be null."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) && (!Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#76#130))) ==> (this != null);
  assert {:msg "  68.11: Location might not be readable."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) && (!Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#76#130))) ==> CanRead(old(Mask), old(SecMask), this, AVLTree.keys);
  assert {:msg "  68.36: Sequence index might be negative."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) && (!Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#76#130))) ==> (0 <= j#76#130);
  assert {:msg "  68.36: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) && (!Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#76#130))) ==> (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys]));
  assume (forall j#76#129: int :: (0 <= j#76#129) && (j#76#129 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#76#129)) || (Seq#Index(old(Heap)[this, AVLTree.keys], j#76#129) == k#3)));
  assert {:msg "  69.11: Receiver might be null."} true && (0 <= j#77#132) ==> (this != null);
  assert {:msg "  69.11: Location might not be readable."} true && (0 <= j#77#132) ==> CanRead(Mask, SecMask, this, AVLTree.keys);
  assert {:msg "  69.11: Receiver might be null."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  69.11: Location might not be readable."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) ==> CanRead(Mask, SecMask, this, AVLTree.keys);
  assert {:msg "  69.33: Sequence index might be negative."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) ==> (0 <= j#77#132);
  assert {:msg "  69.33: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) ==> (j#77#132 < Seq#Length(Heap[this, AVLTree.keys]));
  assert {:msg "  69.42: Receiver might be null."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  69.42: Location might not be readable."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) ==> CanRead(old(Mask), old(SecMask), this, AVLTree.keys);
  assert {:msg "  69.11: Receiver might be null."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) && Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#77#132)) ==> (this != null);
  assert {:msg "  69.11: Location might not be readable."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) && Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#77#132)) ==> CanRead(Mask, SecMask, this, AVLTree.keys);
  assert {:msg "  69.33: Sequence index might be negative."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) && Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#77#132)) ==> (0 <= j#77#132);
  assert {:msg "  69.33: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) && Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#77#132)) ==> (j#77#132 < Seq#Length(Heap[this, AVLTree.keys]));
  assume (forall j#77#131: int :: (0 <= j#77#131) && (j#77#131 < Seq#Length(Heap[this, AVLTree.keys])) ==> Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#77#131)) && (!(Seq#Index(Heap[this, AVLTree.keys], j#77#131) == k#3)));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTree.remove(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#3: int where true) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_107: int;
  var unfoldK#_108: int;
  var oldVers#_120: int;
  var newVers#_121: int;
  var cond#_122: bool;
  var methodCallK#_127: int;
  var this#133: ref where (this#133 == null) || (dtype(this#133) == AVLTreeNode#t);
  var k#134: int where true;
  var r#135: ref where (r#135 == null) || (dtype(r#135) == AVLTreeNode#t);
  var callHeap#_123: HeapType;
  var callMask#_124: MaskType;
  var callSecMask#_125: MaskType;
  var callCredits#_126: CreditsType;
  var exhaleMask#_129: MaskType;
  var exhaleHeap#_128: HeapType;
  var isHeld#_134: int;
  var isRdHeld#_135: bool;
  var r#78: ref where (r#78 == null) || (dtype(r#78) == AVLTreeNode#t);
  var foldK#_139: int;
  var exhaleMask#_141: MaskType;
  var exhaleHeap#_140: HeapType;
  var predRec#_136: ref;
  var predVer#_137: int;
  var predFlag#_138: bool;
  var exhaleMask#_149: MaskType;
  var exhaleHeap#_148: HeapType;
  assume (0 < methodK#_107) && ((1000 * methodK#_107) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // unfold
  assume #AVLTree.valid#trigger(this);
  assume (0 < unfoldK#_108) && (unfoldK#_108 < Fractions(1)) && ((1000 * unfoldK#_108) < methodK#_107);
  assert {:msg "  71.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  71.3: unfold might fail because the predicate AVLTree.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  71.3: unfold might fail because the predicate AVLTree.valid does not hold. Insufficient fraction at <undefined position> for AVLTree.valid."} (Fractions(100) <= Mask[this, AVLTree.valid][perm$R]) && ((Fractions(100) == Mask[this, AVLTree.valid][perm$R]) ==> (0 <= Mask[this, AVLTree.valid][perm$N]));
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTree.root] == null)) {
      //  assert <undefined position>:  The expression at 16.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    }
    if (Heap[this, AVLTree.root] == null) {
      //  assert <undefined position>:  The expression at 17.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
    }
    SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := SecMask[this, AVLTree.root][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTree.root][perm$R] < 0) {
      SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := SecMask[this, AVLTree.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTree.keys][perm$R] < 0) {
      SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, this, AVLTree.valid)) {
    oldVers#_120 := Heap[this, AVLTree.valid];
    havoc newVers#_121;
    Heap[this, AVLTree.valid] := newVers#_121;
    assume oldVers#_120 < Heap[this, AVLTree.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.root]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_122 := Heap[this, AVLTree.root] == null;
  assert {:msg "  72.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  72.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
  if (cond#_122) {
  } else {
    assume (0 < methodCallK#_127) && ((1000 * methodCallK#_127) < Fractions(1)) && ((1000 * methodCallK#_127) < methodK#_107);
    // call remove
    callHeap#_123 := Heap;
    callMask#_124 := Mask;
    callSecMask#_125 := SecMask;
    callCredits#_126 := Credits;
    assume wf(callHeap#_123, callMask#_124, callSecMask#_125);
    assert {:msg "  74.14: Receiver might be null."} true ==> (this != null);
    assert {:msg "  74.14: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
    assert {:msg "  74.4: The target of the method call might be null."} Heap[this, AVLTree.root] != null;
    this#133 := Heap[this, AVLTree.root];
    k#134 := k#3;
    // begin exhale (precondition)
    exhaleMask#_129 := Mask;
    havoc exhaleHeap#_128;
    assert {:msg "  74.4: The precondition at 254.12 might not hold. The permission at 254.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  74.4: The precondition at 254.12 might not hold. Insufficient fraction at 254.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_129[this#133, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_129[this#133, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_129[this#133, AVLTreeNode.valid][perm$N]));
    exhaleMask#_129[this#133, AVLTreeNode.valid] := exhaleMask#_129[this#133, AVLTreeNode.valid][perm$R := exhaleMask#_129[this#133, AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_129, SecMask, this#133, AVLTreeNode.valid)) {
      assume Heap[this#133, AVLTreeNode.valid] < exhaleHeap#_128[this#133, AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_129);
    assume wf(Heap, exhaleMask#_129, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  74.4: The precondition at 255.12 might not hold. The permission at 255.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  74.4: The precondition at 255.12 might not hold. Insufficient fraction at 255.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_129[this#133, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_129[this#133, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_129[this#133, AVLTreeNode.keys][perm$N]));
    exhaleMask#_129[this#133, AVLTreeNode.keys] := exhaleMask#_129[this#133, AVLTreeNode.keys][perm$R := exhaleMask#_129[this#133, AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_129);
    assume wf(Heap, exhaleMask#_129, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  74.4: The precondition at 256.12 might not hold. The permission at 256.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  74.4: The precondition at 256.12 might not hold. Insufficient fraction at 256.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_129[this#133, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_129[this#133, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_129[this#133, AVLTreeNode.height][perm$N]));
    exhaleMask#_129[this#133, AVLTreeNode.height] := exhaleMask#_129[this#133, AVLTreeNode.height][perm$R := exhaleMask#_129[this#133, AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_129);
    assume wf(Heap, exhaleMask#_129, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  74.4: The precondition at 257.12 might not hold. The permission at 257.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  74.4: The precondition at 257.12 might not hold. Insufficient fraction at 257.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_129[this#133, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_129[this#133, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_129[this#133, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_129[this#133, AVLTreeNode.balanceFactor] := exhaleMask#_129[this#133, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_129[this#133, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_129);
    assume wf(Heap, exhaleMask#_129, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_129;
    assume IsGoodExhaleState(exhaleHeap#_128, Heap, Mask, SecMask);
    Heap := exhaleHeap#_128;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#135;
    // inhale (postcondition)
    if (Seq#Equal(callHeap#_123[this#133, AVLTreeNode.keys], Seq#Singleton(k#134))) {
      assume r#135 == null;
    }
    if (!Seq#Equal(callHeap#_123[this#133, AVLTreeNode.keys], Seq#Singleton(k#134))) {
      assume !(r#135 == null);
    }
    if (!(r#135 == null)) {
      assume r#135 != null;
      assume wf(Heap, Mask, SecMask);
      assume Fractions(100) > 0;
      Mask[r#135, AVLTreeNode.valid] := Mask[r#135, AVLTreeNode.valid][perm$R := Mask[r#135, AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#135, AVLTreeNode.valid]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#135 == null)) {
      assume r#135 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#135, AVLTreeNode.keys] := Mask[r#135, AVLTreeNode.keys][perm$R := Mask[r#135, AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#135, AVLTreeNode.keys]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#135 == null)) {
      assume r#135 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#135, AVLTreeNode.height] := Mask[r#135, AVLTreeNode.height][perm$R := Mask[r#135, AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#135, AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#135 == null)) {
      assume r#135 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#135, AVLTreeNode.balanceFactor] := Mask[r#135, AVLTreeNode.balanceFactor][perm$R := Mask[r#135, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#135, AVLTreeNode.balanceFactor]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#135 == null)) {
      assume !Seq#Contains(Heap[r#135, AVLTreeNode.keys], k#134);
    }
    if (!(r#135 == null)) {
      assume (forall i#84#136: int :: (0 <= i#84#136) && (i#84#136 < Seq#Length(callHeap#_123[this#133, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#135, AVLTreeNode.keys], Seq#Index(callHeap#_123[this#133, AVLTreeNode.keys], i#84#136)) || (Seq#Index(callHeap#_123[this#133, AVLTreeNode.keys], i#84#136) == k#134)));
    }
    if (!(r#135 == null)) {
      assume (forall i#85#137: int :: (0 <= i#85#137) && (i#85#137 < Seq#Length(Heap[r#135, AVLTreeNode.keys])) ==> Seq#Contains(callHeap#_123[this#133, AVLTreeNode.keys], Seq#Index(Heap[r#135, AVLTreeNode.keys], i#85#137)) && (!(Seq#Index(Heap[r#135, AVLTreeNode.keys], i#85#137) == k#134)));
    }
    if (!Seq#Contains(callHeap#_123[this#133, AVLTreeNode.keys], k#134)) {
      assume !(r#135 == null);
    }
    if (!Seq#Contains(callHeap#_123[this#133, AVLTreeNode.keys], k#134)) {
      assume Seq#Equal(Heap[r#135, AVLTreeNode.keys], callHeap#_123[this#133, AVLTreeNode.keys]);
    }
    if (!(r#135 == null)) {
      if (Seq#Contains(callHeap#_123[this#133, AVLTreeNode.keys], k#134)) {
        assume Seq#Length(Heap[r#135, AVLTreeNode.keys]) == (Seq#Length(callHeap#_123[this#133, AVLTreeNode.keys]) - 1);
      }
    }
    if (callHeap#_123[this#133, AVLTreeNode.height] > 1) {
      assume !(r#135 == null);
    }
    if (!(r#135 == null)) {
      assume (Heap[r#135, AVLTreeNode.height] == callHeap#_123[this#133, AVLTreeNode.height]) || ((Heap[r#135, AVLTreeNode.height] + 1) == callHeap#_123[this#133, AVLTreeNode.height]);
    }
    if (!Seq#Contains(callHeap#_123[this#133, AVLTreeNode.keys], k#134)) {
      assume Heap[r#135, AVLTreeNode.height] == callHeap#_123[this#133, AVLTreeNode.height];
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    r#78 := r#135;
    // update field root
    assert {:msg "  75.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
    Heap[this, AVLTree.root] := r#78;
    assume wf(Heap, Mask, SecMask);
    // update field keys
    assert {:msg "  76.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.keys);
    assert {:msg "  76.13: Receiver might be null."} true ==> (this != null);
    assert {:msg "  76.13: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
    if (Heap[this, AVLTree.root] == null) {
    } else {
      assert {:msg "  76.33: Receiver might be null."} true ==> (this != null);
      assert {:msg "  76.33: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
      assert {:msg "  76.33: Receiver might be null."} true ==> (Heap[this, AVLTree.root] != null);
      assert {:msg "  76.33: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTree.root], AVLTreeNode.keys);
    }
    Heap[this, AVLTree.keys] := ite(Heap[this, AVLTree.root] == null, Seq#Empty(), Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    assume wf(Heap, Mask, SecMask);
  }
  // fold
  assume #AVLTree.valid#trigger(this);
  assume (0 < foldK#_139) && ((1000 * foldK#_139) < Fractions(1)) && ((1000 * foldK#_139) < methodK#_107);
  assert {:msg "  78.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_141 := Mask;
  havoc exhaleHeap#_140;
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 16.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 17.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 10.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} (Fractions(100) <= exhaleMask#_141[this, AVLTree.root][perm$R]) && ((Fractions(100) == exhaleMask#_141[this, AVLTree.root][perm$R]) ==> (0 <= exhaleMask#_141[this, AVLTree.root][perm$N]));
  exhaleMask#_141[this, AVLTree.root] := exhaleMask#_141[this, AVLTree.root][perm$R := exhaleMask#_141[this, AVLTree.root][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := SecMask[this, AVLTree.root][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_141);
  assume wf(Heap, exhaleMask#_141, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 11.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 11.6 for AVLTree.keys."} (Fractions(50) <= exhaleMask#_141[this, AVLTree.keys][perm$R]) && ((Fractions(50) == exhaleMask#_141[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_141[this, AVLTree.keys][perm$N]));
  exhaleMask#_141[this, AVLTree.keys] := exhaleMask#_141[this, AVLTree.keys][perm$R := exhaleMask#_141[this, AVLTree.keys][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := SecMask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_141);
  assume wf(Heap, exhaleMask#_141, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 12.22 might not be positive."} Fractions(100) > 0;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.valid] := exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - Fractions(100)];
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + Fractions(100)];
    if (!CanRead(exhaleMask#_141, SecMask, Heap[this, AVLTree.root], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTree.root], AVLTreeNode.valid] < exhaleHeap#_140[Heap[this, AVLTree.root], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_141);
    assume wf(Heap, exhaleMask#_141, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 13.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 13.22 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.height][perm$N]));
    exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.height] := exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_141);
    assume wf(Heap, exhaleMask#_141, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 14.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 14.22 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$N]));
    exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.keys] := exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_141);
    assume wf(Heap, exhaleMask#_141, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 15.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 15.22 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_141[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_141);
    assume wf(Heap, exhaleMask#_141, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_141;
  assume IsGoodExhaleState(exhaleHeap#_140, Heap, Mask, SecMask);
  Heap := exhaleHeap#_140;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  predRec#_136 := this;
  predVer#_137 := Heap[this, AVLTree.valid];
  predFlag#_138 := true;
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_149 := Mask;
  havoc exhaleHeap#_148;
  assert {:msg "  60.2: The postcondition at 67.11 might not hold. The expression at 67.11 might not evaluate to true."} !Seq#Contains(Heap[this, AVLTree.keys], k#3);
  assert {:msg "  60.2: The postcondition at 68.11 might not hold. The expression at 68.11 might not evaluate to true."} (forall j#76#138: int :: (0 <= j#76#138) && (j#76#138 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#76#138)) || (Seq#Index(old(Heap)[this, AVLTree.keys], j#76#138) == k#3)));
  assert {:msg "  60.2: The postcondition at 69.11 might not hold. The expression at 69.11 might not evaluate to true."} (forall j#77#139: int :: (0 <= j#77#139) && (j#77#139 < Seq#Length(Heap[this, AVLTree.keys])) ==> Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#77#139)) && (!(Seq#Index(Heap[this, AVLTree.keys], j#77#139) == k#3)));
  assert {:msg "  60.2: The postcondition at 64.11 might not hold. The permission at 64.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  60.2: The postcondition at 64.11 might not hold. Insufficient fraction at 64.11 for AVLTree.valid."} (Fractions(100) <= exhaleMask#_149[this, AVLTree.valid][perm$R]) && ((Fractions(100) == exhaleMask#_149[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_149[this, AVLTree.valid][perm$N]));
  exhaleMask#_149[this, AVLTree.valid] := exhaleMask#_149[this, AVLTree.valid][perm$R := exhaleMask#_149[this, AVLTree.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_137 == Heap[this, AVLTree.valid]) && (predRec#_136 == this) && true && (!cond#_122) && predFlag#_138)) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTree.root] == null)) {
      //  assert <undefined position>:  The expression at 16.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    }
    if (Heap[this, AVLTree.root] == null) {
      //  assert <undefined position>:  The expression at 17.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
    }
    SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := SecMask[this, AVLTree.root][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTree.root][perm$R] < 0) {
      SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := SecMask[this, AVLTree.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTree.keys][perm$R] < 0) {
      SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(exhaleMask#_149, SecMask, this, AVLTree.valid)) {
    assume Heap[this, AVLTree.valid] < exhaleHeap#_148[this, AVLTree.valid];
  }
  assume IsGoodMask(exhaleMask#_149);
  assume wf(Heap, exhaleMask#_149, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  60.2: The postcondition at 65.11 might not hold. The permission at 65.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  60.2: The postcondition at 65.11 might not hold. Insufficient fraction at 65.11 for AVLTree.keys."} (Fractions(50) <= exhaleMask#_149[this, AVLTree.keys][perm$R]) && ((Fractions(50) == exhaleMask#_149[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_149[this, AVLTree.keys][perm$N]));
  exhaleMask#_149[this, AVLTree.keys] := exhaleMask#_149[this, AVLTree.keys][perm$R := exhaleMask#_149[this, AVLTree.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_149);
  assume wf(Heap, exhaleMask#_149, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_149;
  assume IsGoodExhaleState(exhaleHeap#_148, Heap, Mask, SecMask);
  Heap := exhaleHeap#_148;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  60.2: Method might lock/unlock more than allowed."} (forall lk#_160: ref :: {Heap[lk#_160, held]} {Heap[lk#_160, rdheld]} (((0 < Heap[lk#_160, held]) == (0 < old(Heap)[lk#_160, held])) && (Heap[lk#_160, rdheld] == old(Heap)[lk#_160, rdheld])) || false);
  assert {:msg "  60.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTree.has$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#4: int where true) returns (b#5: bool where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_161: int;
  assume (0 < methodK#_161) && ((1000 * methodK#_161) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  83.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_161 > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + methodK#_161];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  86.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_161 > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + methodK#_161];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  88.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  88.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.keys);
  assume b#5 == Seq#Contains(Heap[this, AVLTree.keys], k#4);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTree.has(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#4: int where true) returns (b#5: bool where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_161: int;
  var unfoldK#_162: int;
  var oldVers#_174: int;
  var newVers#_175: int;
  var cond#_176: bool;
  var bb#7: bool where true;
  var methodCallK#_181: int;
  var this#142: ref where (this#142 == null) || (dtype(this#142) == AVLTreeNode#t);
  var k#143: int where true;
  var b#144: bool where true;
  var callHeap#_177: HeapType;
  var callMask#_178: MaskType;
  var callSecMask#_179: MaskType;
  var callCredits#_180: CreditsType;
  var exhaleMask#_183: MaskType;
  var exhaleHeap#_182: HeapType;
  var isHeld#_186: int;
  var isRdHeld#_187: bool;
  var foldK#_191: int;
  var exhaleMask#_193: MaskType;
  var exhaleHeap#_192: HeapType;
  var predRec#_188: ref;
  var predVer#_189: int;
  var predFlag#_190: bool;
  var exhaleMask#_201: MaskType;
  var exhaleHeap#_200: HeapType;
  assume (0 < methodK#_161) && ((1000 * methodK#_161) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_161 > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + methodK#_161];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // unfold
  assume #AVLTree.valid#trigger(this);
  assume (0 < unfoldK#_162) && (unfoldK#_162 < Fractions(1)) && ((1000 * unfoldK#_162) < methodK#_161);
  assert {:msg "  90.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  90.3: unfold might fail because the predicate AVLTree.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  90.3: unfold might fail because the predicate AVLTree.valid does not hold. Insufficient fraction at <undefined position> for AVLTree.valid."} (Fractions(100) <= Mask[this, AVLTree.valid][perm$R]) && ((Fractions(100) == Mask[this, AVLTree.valid][perm$R]) ==> (0 <= Mask[this, AVLTree.valid][perm$N]));
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTree.root] == null)) {
      //  assert <undefined position>:  The expression at 16.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    }
    if (Heap[this, AVLTree.root] == null) {
      //  assert <undefined position>:  The expression at 17.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
    }
    SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := SecMask[this, AVLTree.root][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTree.root][perm$R] < 0) {
      SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := SecMask[this, AVLTree.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTree.keys][perm$R] < 0) {
      SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, this, AVLTree.valid)) {
    oldVers#_174 := Heap[this, AVLTree.valid];
    havoc newVers#_175;
    Heap[this, AVLTree.valid] := newVers#_175;
    assume oldVers#_174 < Heap[this, AVLTree.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.root]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_176 := Heap[this, AVLTree.root] == null;
  assert {:msg "  91.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  91.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
  if (cond#_176) {
    // assigment to b
    b#5 := false;
  } else {
    // local var bb
    assume (0 < methodCallK#_181) && ((1000 * methodCallK#_181) < Fractions(1)) && ((1000 * methodCallK#_181) < methodK#_161);
    // call has
    callHeap#_177 := Heap;
    callMask#_178 := Mask;
    callSecMask#_179 := SecMask;
    callCredits#_180 := Credits;
    assume wf(callHeap#_177, callMask#_178, callSecMask#_179);
    assert {:msg "  95.14: Receiver might be null."} true ==> (this != null);
    assert {:msg "  95.14: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTree.root);
    assert {:msg "  95.4: The target of the method call might be null."} Heap[this, AVLTree.root] != null;
    this#142 := Heap[this, AVLTree.root];
    k#143 := k#4;
    // begin exhale (precondition)
    exhaleMask#_183 := Mask;
    havoc exhaleHeap#_182;
    assert {:msg "  95.4: The precondition at 458.12 might not hold. The permission at 458.12 might not be positive."} methodCallK#_181 > 0;
    assert {:msg "  95.4: The precondition at 458.12 might not hold. Insufficient fraction at 458.12 for AVLTreeNode.keys."} exhaleMask#_183[this#142, AVLTreeNode.keys][perm$R] > 0;
    assume methodCallK#_181 < exhaleMask#_183[this#142, AVLTreeNode.keys][perm$R];
    exhaleMask#_183[this#142, AVLTreeNode.keys] := exhaleMask#_183[this#142, AVLTreeNode.keys][perm$R := exhaleMask#_183[this#142, AVLTreeNode.keys][perm$R] - methodCallK#_181];
    assume IsGoodMask(exhaleMask#_183);
    assume wf(Heap, exhaleMask#_183, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  95.4: The precondition at 457.12 might not hold. The permission at 457.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  95.4: The precondition at 457.12 might not hold. Insufficient fraction at 457.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_183[this#142, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_183[this#142, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_183[this#142, AVLTreeNode.valid][perm$N]));
    exhaleMask#_183[this#142, AVLTreeNode.valid] := exhaleMask#_183[this#142, AVLTreeNode.valid][perm$R := exhaleMask#_183[this#142, AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_183, SecMask, this#142, AVLTreeNode.valid)) {
      assume Heap[this#142, AVLTreeNode.valid] < exhaleHeap#_182[this#142, AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_183);
    assume wf(Heap, exhaleMask#_183, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_183;
    assume IsGoodExhaleState(exhaleHeap#_182, Heap, Mask, SecMask);
    Heap := exhaleHeap#_182;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc b#144;
    // inhale (postcondition)
    assume this#142 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[this#142, AVLTreeNode.valid] := Mask[this#142, AVLTreeNode.valid][perm$R := Mask[this#142, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#142, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#142 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodCallK#_181 > 0;
    Mask[this#142, AVLTreeNode.keys] := Mask[this#142, AVLTreeNode.keys][perm$R := Mask[this#142, AVLTreeNode.keys][perm$R] + methodCallK#_181];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#142, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume b#144 == Seq#Contains(Heap[this#142, AVLTreeNode.keys], k#143);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    bb#7 := b#144;
    // assigment to b
    b#5 := bb#7;
  }
  // fold
  assume #AVLTree.valid#trigger(this);
  assume (0 < foldK#_191) && ((1000 * foldK#_191) < Fractions(1)) && ((1000 * foldK#_191) < methodK#_161);
  assert {:msg "  98.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_193 := Mask;
  havoc exhaleHeap#_192;
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 16.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 17.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 10.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} (Fractions(100) <= exhaleMask#_193[this, AVLTree.root][perm$R]) && ((Fractions(100) == exhaleMask#_193[this, AVLTree.root][perm$R]) ==> (0 <= exhaleMask#_193[this, AVLTree.root][perm$N]));
  exhaleMask#_193[this, AVLTree.root] := exhaleMask#_193[this, AVLTree.root][perm$R := exhaleMask#_193[this, AVLTree.root][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := SecMask[this, AVLTree.root][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_193);
  assume wf(Heap, exhaleMask#_193, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 11.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 11.6 for AVLTree.keys."} (Fractions(50) <= exhaleMask#_193[this, AVLTree.keys][perm$R]) && ((Fractions(50) == exhaleMask#_193[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_193[this, AVLTree.keys][perm$N]));
  exhaleMask#_193[this, AVLTree.keys] := exhaleMask#_193[this, AVLTree.keys][perm$R := exhaleMask#_193[this, AVLTree.keys][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := SecMask[this, AVLTree.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_193);
  assume wf(Heap, exhaleMask#_193, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 12.22 might not be positive."} Fractions(100) > 0;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.valid] := exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - Fractions(100)];
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + Fractions(100)];
    if (!CanRead(exhaleMask#_193, SecMask, Heap[this, AVLTree.root], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTree.root], AVLTreeNode.valid] < exhaleHeap#_192[Heap[this, AVLTree.root], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_193);
    assume wf(Heap, exhaleMask#_193, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 13.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 13.22 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.height][perm$N]));
    exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.height] := exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_193);
    assume wf(Heap, exhaleMask#_193, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 14.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 14.22 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$N]));
    exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.keys] := exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_193);
    assume wf(Heap, exhaleMask#_193, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 15.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 15.22 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_193[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_193);
    assume wf(Heap, exhaleMask#_193, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_193;
  assume IsGoodExhaleState(exhaleHeap#_192, Heap, Mask, SecMask);
  Heap := exhaleHeap#_192;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTree.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  predRec#_188 := this;
  predVer#_189 := Heap[this, AVLTree.valid];
  predFlag#_190 := true;
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_201 := Mask;
  havoc exhaleHeap#_200;
  assert {:msg "  82.2: The postcondition at 88.11 might not hold. The expression at 88.11 might not evaluate to true."} b#5 == Seq#Contains(Heap[this, AVLTree.keys], k#4);
  assert {:msg "  82.2: The postcondition at 86.11 might not hold. The permission at 86.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  82.2: The postcondition at 86.11 might not hold. Insufficient fraction at 86.11 for AVLTree.valid."} (Fractions(100) <= exhaleMask#_201[this, AVLTree.valid][perm$R]) && ((Fractions(100) == exhaleMask#_201[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_201[this, AVLTree.valid][perm$N]));
  exhaleMask#_201[this, AVLTree.valid] := exhaleMask#_201[this, AVLTree.valid][perm$R := exhaleMask#_201[this, AVLTree.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_189 == Heap[this, AVLTree.valid]) && (predRec#_188 == this) && true && (!cond#_176) && predFlag#_190)) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTree.root] == null)) {
      //  assert <undefined position>:  The expression at 16.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    }
    if (Heap[this, AVLTree.root] == null) {
      //  assert <undefined position>:  The expression at 17.22 might not evaluate to true.
      assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
    }
    SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := SecMask[this, AVLTree.root][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTree.root][perm$R] < 0) {
      SecMask[this, AVLTree.root] := SecMask[this, AVLTree.root][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := SecMask[this, AVLTree.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTree.keys][perm$R] < 0) {
      SecMask[this, AVLTree.keys] := SecMask[this, AVLTree.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.height] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTree.root] == null)) {
      SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(exhaleMask#_201, SecMask, this, AVLTree.valid)) {
    assume Heap[this, AVLTree.valid] < exhaleHeap#_200[this, AVLTree.valid];
  }
  assume IsGoodMask(exhaleMask#_201);
  assume wf(Heap, exhaleMask#_201, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  82.2: The postcondition at 87.11 might not hold. The permission at 87.11 might not be positive."} methodK#_161 > 0;
  assert {:msg "  82.2: The postcondition at 87.11 might not hold. Insufficient fraction at 87.11 for AVLTree.keys."} (methodK#_161 <= exhaleMask#_201[this, AVLTree.keys][perm$R]) && ((methodK#_161 == exhaleMask#_201[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_201[this, AVLTree.keys][perm$N]));
  exhaleMask#_201[this, AVLTree.keys] := exhaleMask#_201[this, AVLTree.keys][perm$R := exhaleMask#_201[this, AVLTree.keys][perm$R] - methodK#_161];
  assume IsGoodMask(exhaleMask#_201);
  assume wf(Heap, exhaleMask#_201, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_201;
  assume IsGoodExhaleState(exhaleHeap#_200, Heap, Mask, SecMask);
  Heap := exhaleHeap#_200;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  82.2: Method might lock/unlock more than allowed."} (forall lk#_212: ref :: {Heap[lk#_212, held]} {Heap[lk#_212, rdheld]} (((0 < Heap[lk#_212, held]) == (0 < old(Heap)[lk#_212, held])) && (Heap[lk#_212, rdheld] == old(Heap)[lk#_212, rdheld])) || false);
  assert {:msg "  82.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique AVLTreeNode#t: TypeName;
procedure AVLTreeNode$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_222: int;
  var h0#_213: HeapType;
  var m0#_214: MaskType;
  var sm0#_215: MaskType;
  var c0#_216: CreditsType;
  var h1#_217: HeapType;
  var m1#_218: MaskType;
  var sm1#_219: MaskType;
  var c1#_220: CreditsType;
  var lk#_221: ref;
  assume (0 < methodK#_222) && ((1000 * methodK#_222) < Fractions(1));
  assume wf(h0#_213, m0#_214, sm0#_215);
  assume wf(h1#_217, m1#_218, sm1#_219);
  m1#_218 := ZeroMask;
  sm1#_219 := ZeroMask;
  c1#_220 := ZeroCredits;
  havoc h1#_217;
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  104.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique AVLTreeNode.key: Field (int);
axiom NonPredicateField(AVLTreeNode.key);
const unique AVLTreeNode.height: Field (int);
axiom NonPredicateField(AVLTreeNode.height);
const unique AVLTreeNode.left: Field (ref);
axiom NonPredicateField(AVLTreeNode.left);
const unique AVLTreeNode.right: Field (ref);
axiom NonPredicateField(AVLTreeNode.right);
const unique AVLTreeNode.keys: Field (Seq (int));
axiom NonPredicateField(AVLTreeNode.keys);
const unique AVLTreeNode.balanceFactor: Field (int);
axiom NonPredicateField(AVLTreeNode.balanceFactor);
const unique AVLTreeNode.valid: Field (int);
axiom PredicateField(AVLTreeNode.valid);
function #AVLTreeNode.valid#trigger(this: ref) returns ($myresult: bool);
procedure AVLTreeNode.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var predicateK#_223: int;
  var lk#79#147: int where true;
  var rk#80#148: int where true;
  var kk#149: int where true;
  assume (0 < predicateK#_223) && ((1000 * predicateK#_223) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  125.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  125.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  125.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  125.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  125.22: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  125.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  125.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  126.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  126.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  126.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  126.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  127.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  127.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  127.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  127.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  128.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  128.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  128.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  128.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  129.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  129.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= lk#79#147) ==> (this != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= lk#79#147) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= lk#79#147) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= lk#79#147) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  129.48: Sequence index might be negative."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= lk#79#147);
    assert {:msg "  129.48: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  129.53: Receiver might be null."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  129.53: Location might not be readable."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    assume (forall lk#79#145: int :: (0 <= lk#79#145) && (lk#79#145 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#145) < Heap[this, AVLTreeNode.key]));
  }
  assert {:msg "  130.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  130.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  130.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  130.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  130.22: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  130.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  assert {:msg "  132.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  132.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  132.23: Receiver might be null."} true ==> (this != null);
    assert {:msg "  132.23: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  132.23: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  132.23: Receiver might be null."} true ==> (this != null);
    assert {:msg "  132.23: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  133.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  133.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  133.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  133.27: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  134.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  134.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  134.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  134.27: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  135.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  135.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  135.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  135.27: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  136.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  136.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= rk#80#148) ==> (this != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= rk#80#148) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= rk#80#148) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= rk#80#148) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  136.51: Receiver might be null."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  136.51: Location might not be readable."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  136.57: Sequence index might be negative."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= rk#80#148);
    assert {:msg "  136.57: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall rk#80#146: int :: (0 <= rk#80#146) && (rk#80#146 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#146)));
  }
  assert {:msg "  137.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  137.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  137.23: Receiver might be null."} true ==> (this != null);
    assert {:msg "  137.23: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  137.23: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  137.23: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assert {:msg "  139.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.6: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.keys);
  assert {:msg "  139.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.25: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  139.49: Receiver might be null."} true ==> (this != null);
    assert {:msg "  139.49: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  139.49: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  139.49: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  139.65: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.65: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  assert {:msg "  139.75: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.75: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  139.100: Receiver might be null."} true ==> (this != null);
    assert {:msg "  139.100: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  139.100: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  139.100: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  140.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  140.6: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  assert {:msg "  140.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  140.13: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.keys);
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assert {:msg "  142.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  142.13: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.keys);
  assert {:msg "  144.9: Receiver might be null."} true ==> (this != null);
  assert {:msg "  144.9: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  144.30: Receiver might be null."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> (this != null);
  assert {:msg "  144.30: Location might not be readable."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  144.30: Receiver might be null."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  144.30: Location might not be readable."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  144.48: Receiver might be null."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149))) ==> (this != null);
  assert {:msg "  144.48: Location might not be readable."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149))) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  144.69: Receiver might be null."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149))) && (!(Heap[this, AVLTreeNode.right] == null)) ==> (this != null);
  assert {:msg "  144.69: Location might not be readable."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149))) && (!(Heap[this, AVLTreeNode.right] == null)) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  144.69: Receiver might be null."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149))) && (!(Heap[this, AVLTreeNode.right] == null)) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  144.69: Location might not be readable."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149))) && (!(Heap[this, AVLTreeNode.right] == null)) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  144.91: Receiver might be null."} true && (!(((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#149)))) ==> (this != null);
  assert {:msg "  144.91: Location might not be readable."} true && (!(((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#149)))) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
  assert {:msg "  146.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  146.6: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.height);
  assert {:msg "  146.26: Receiver might be null."} true ==> (this != null);
  assert {:msg "  146.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  146.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  146.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  146.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  146.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  146.53: Receiver might be null."} true ==> (this != null);
  assert {:msg "  146.53: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  146.67: Receiver might be null."} true ==> (this != null);
    assert {:msg "  146.67: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  146.67: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  146.67: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  if (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) {
    assert {:msg "  146.84: Receiver might be null."} true ==> (this != null);
    assert {:msg "  146.84: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    if (Heap[this, AVLTreeNode.left] == null) {
    } else {
      assert {:msg "  146.97: Receiver might be null."} true ==> (this != null);
      assert {:msg "  146.97: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
      assert {:msg "  146.97: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
      assert {:msg "  146.97: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
    }
  } else {
    assert {:msg "  146.115: Receiver might be null."} true ==> (this != null);
    assert {:msg "  146.115: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    if (Heap[this, AVLTreeNode.right] == null) {
    } else {
      assert {:msg "  146.129: Receiver might be null."} true ==> (this != null);
      assert {:msg "  146.129: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
      assert {:msg "  146.129: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
      assert {:msg "  146.129: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
    }
  }
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  147.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  147.6: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.balanceFactor);
  assert {:msg "  147.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  147.24: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  147.37: Receiver might be null."} true ==> (this != null);
    assert {:msg "  147.37: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  147.37: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  147.37: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  147.53: Receiver might be null."} true ==> (this != null);
  assert {:msg "  147.53: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  147.67: Receiver might be null."} true ==> (this != null);
    assert {:msg "  147.67: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  147.67: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  147.67: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  148.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  148.6: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.balanceFactor);
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assert {:msg "  149.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  149.6: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.balanceFactor);
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assert {:msg "  150.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  150.6: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.height);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#8: int where true) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_224: int;
  assume (0 < methodK#_224) && ((1000 * methodK#_224) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  163.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  168.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  168.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.height);
  assume Heap[this, AVLTreeNode.height] == 1;
  assert {:msg "  169.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  169.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.keys);
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Singleton(k#8));
  assert {:msg "  170.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  170.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.balanceFactor);
  assume Heap[this, AVLTreeNode.balanceFactor] == 0;
  assert {:msg "  172.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  172.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.keys);
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], k#8);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.init(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#8: int where true) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_224: int;
  var assertHeap#_225: HeapType;
  var assertMask#_226: MaskType;
  var assertSecMask#_227: MaskType;
  var assertCredits#_228: CreditsType;
  var exhaleMask#_230: MaskType;
  var exhaleHeap#_229: HeapType;
  var methodCallK#_235: int;
  var this#150: ref where (this#150 == null) || (dtype(this#150) == AVLTreeNode#t);
  var callHeap#_231: HeapType;
  var callMask#_232: MaskType;
  var callSecMask#_233: MaskType;
  var callCredits#_234: CreditsType;
  var exhaleMask#_237: MaskType;
  var exhaleHeap#_236: HeapType;
  var isHeld#_252: int;
  var isRdHeld#_253: bool;
  var exhaleMask#_255: MaskType;
  var exhaleHeap#_254: HeapType;
  assume (0 < methodK#_224) && ((1000 * methodK#_224) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // update field left
  assert {:msg "  174.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
  Heap[this, AVLTreeNode.left] := null;
  assume wf(Heap, Mask, SecMask);
  // update field right
  assert {:msg "  175.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
  Heap[this, AVLTreeNode.right] := null;
  assume wf(Heap, Mask, SecMask);
  // update field key
  assert {:msg "  176.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.key);
  Heap[this, AVLTreeNode.key] := k#8;
  assume wf(Heap, Mask, SecMask);
  // assert
  assertHeap#_225 := Heap;
  assertMask#_226 := Mask;
  assertSecMask#_227 := SecMask;
  assertCredits#_228 := Credits;
  assume wf(assertHeap#_225, assertMask#_226, assertSecMask#_227);
  // begin exhale (assert)
  exhaleMask#_230 := assertMask#_226;
  havoc exhaleHeap#_229;
  assert {:msg "  178.10: Sequence index might be negative."} true ==> (0 <= 0);
  assert {:msg "  178.10: Sequence index might be larger than or equal to the length of the sequence."} true ==> (0 < Seq#Length(Seq#Singleton(k#8)));
  assert {:msg "  178.3: Assertion might not hold. The expression at 178.10 might not evaluate to true."} Seq#Index(Seq#Singleton(k#8), 0) == k#8;
  assertMask#_226 := exhaleMask#_230;
  assume IsGoodExhaleState(exhaleHeap#_229, assertHeap#_225, assertMask#_226, assertSecMask#_227);
  assertHeap#_225 := exhaleHeap#_229;
  assume IsGoodMask(assertMask#_226);
  assume wf(assertHeap#_225, assertMask#_226, assertSecMask#_227);
  // end exhale
  assume (0 < methodCallK#_235) && ((1000 * methodCallK#_235) < Fractions(1)) && ((1000 * methodCallK#_235) < methodK#_224);
  // call close
  callHeap#_231 := Heap;
  callMask#_232 := Mask;
  callSecMask#_233 := SecMask;
  callCredits#_234 := Credits;
  assume wf(callHeap#_231, callMask#_232, callSecMask#_233);
  assert {:msg "  179.3: The target of the method call might be null."} this != null;
  this#150 := this;
  // begin exhale (precondition)
  exhaleMask#_237 := Mask;
  havoc exhaleHeap#_236;
  if (!(Heap[this#150, AVLTreeNode.left] == null)) {
    assert {:msg "  179.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#151: int :: (0 <= k#92#151) && (k#92#151 < Seq#Length(Heap[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys], k#92#151) < Heap[this#150, AVLTreeNode.key]));
  }
  if (!(Heap[this#150, AVLTreeNode.right] == null)) {
    assert {:msg "  179.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#152: int :: (0 <= k#93#152) && (k#93#152 < Seq#Length(Heap[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#150, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys], k#93#152)));
  }
  assert {:msg "  179.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#150, AVLTreeNode.left] == null, 0, Heap[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#150, AVLTreeNode.right] == null, 0, Heap[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  179.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#150, AVLTreeNode.left] == null, 0, Heap[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#150, AVLTreeNode.right] == null, 0, Heap[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  179.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  179.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_237[this#150, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_237[this#150, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_237[this#150, AVLTreeNode.key][perm$N]));
  exhaleMask#_237[this#150, AVLTreeNode.key] := exhaleMask#_237[this#150, AVLTreeNode.key][perm$R := exhaleMask#_237[this#150, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_237);
  assume wf(Heap, exhaleMask#_237, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  179.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  179.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_237[this#150, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_237[this#150, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_237[this#150, AVLTreeNode.height][perm$N]));
  exhaleMask#_237[this#150, AVLTreeNode.height] := exhaleMask#_237[this#150, AVLTreeNode.height][perm$R := exhaleMask#_237[this#150, AVLTreeNode.height][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_237);
  assume wf(Heap, exhaleMask#_237, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  179.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  179.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_237[this#150, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_237[this#150, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_237[this#150, AVLTreeNode.left][perm$N]));
  exhaleMask#_237[this#150, AVLTreeNode.left] := exhaleMask#_237[this#150, AVLTreeNode.left][perm$R := exhaleMask#_237[this#150, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_237);
  assume wf(Heap, exhaleMask#_237, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  179.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  179.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_237[this#150, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_237[this#150, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_237[this#150, AVLTreeNode.right][perm$N]));
  exhaleMask#_237[this#150, AVLTreeNode.right] := exhaleMask#_237[this#150, AVLTreeNode.right][perm$R := exhaleMask#_237[this#150, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_237);
  assume wf(Heap, exhaleMask#_237, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  179.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  179.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_237[this#150, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_237[this#150, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_237[this#150, AVLTreeNode.keys][perm$N]));
  exhaleMask#_237[this#150, AVLTreeNode.keys] := exhaleMask#_237[this#150, AVLTreeNode.keys][perm$R := exhaleMask#_237[this#150, AVLTreeNode.keys][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_237);
  assume wf(Heap, exhaleMask#_237, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  179.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  179.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_237[this#150, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_237[this#150, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_237[this#150, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_237[this#150, AVLTreeNode.balanceFactor] := exhaleMask#_237[this#150, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_237[this#150, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_237);
  assume wf(Heap, exhaleMask#_237, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#150, AVLTreeNode.left] == null)) {
    assert {:msg "  179.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
    assert {:msg "  179.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_237, SecMask, Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_236[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_237);
    assume wf(Heap, exhaleMask#_237, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.left] == null)) {
    assert {:msg "  179.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  179.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_237);
    assume wf(Heap, exhaleMask#_237, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.left] == null)) {
    assert {:msg "  179.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  179.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_237);
    assume wf(Heap, exhaleMask#_237, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.left] == null)) {
    assert {:msg "  179.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  179.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_237[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_237);
    assume wf(Heap, exhaleMask#_237, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.right] == null)) {
    assert {:msg "  179.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
    assert {:msg "  179.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_237, SecMask, Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_236[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_237);
    assume wf(Heap, exhaleMask#_237, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.right] == null)) {
    assert {:msg "  179.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  179.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_237);
    assume wf(Heap, exhaleMask#_237, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.right] == null)) {
    assert {:msg "  179.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  179.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_237);
    assume wf(Heap, exhaleMask#_237, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.right] == null)) {
    assert {:msg "  179.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  179.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_237[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_237);
    assume wf(Heap, exhaleMask#_237, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_237;
  assume IsGoodExhaleState(exhaleHeap#_236, Heap, Mask, SecMask);
  Heap := exhaleHeap#_236;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#150 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#150, AVLTreeNode.valid] := Mask[this#150, AVLTreeNode.valid][perm$R := Mask[this#150, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#150, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#150 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#150, AVLTreeNode.height] := Mask[this#150, AVLTreeNode.height][perm$R := Mask[this#150, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#150, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#150 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#150, AVLTreeNode.keys] := Mask[this#150, AVLTreeNode.keys][perm$R := Mask[this#150, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#150, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#150 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#150, AVLTreeNode.balanceFactor] := Mask[this#150, AVLTreeNode.balanceFactor][perm$R := Mask[this#150, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#150, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#150, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_231[this#150, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_231[callHeap#_231[this#150, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_231[this#150, AVLTreeNode.key])), ite(callHeap#_231[this#150, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_231[callHeap#_231[this#150, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#150, AVLTreeNode.height] == ite(ite(callHeap#_231[this#150, AVLTreeNode.left] == null, 0, callHeap#_231[callHeap#_231[this#150, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_231[this#150, AVLTreeNode.right] == null, 0, callHeap#_231[callHeap#_231[this#150, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_231[this#150, AVLTreeNode.left] == null, 0, callHeap#_231[callHeap#_231[this#150, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_231[this#150, AVLTreeNode.right] == null, 0, callHeap#_231[callHeap#_231[this#150, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#150, AVLTreeNode.balanceFactor] == (ite(callHeap#_231[this#150, AVLTreeNode.left] == null, 0, callHeap#_231[callHeap#_231[this#150, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_231[this#150, AVLTreeNode.right] == null, 0, callHeap#_231[callHeap#_231[this#150, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_255 := Mask;
  havoc exhaleHeap#_254;
  assert {:msg "  154.2: The postcondition at 168.11 might not hold. The expression at 168.11 might not evaluate to true."} Heap[this, AVLTreeNode.height] == 1;
  assert {:msg "  154.2: The postcondition at 169.11 might not hold. The expression at 169.11 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Singleton(k#8));
  assert {:msg "  154.2: The postcondition at 170.11 might not hold. The expression at 170.11 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == 0;
  assert {:msg "  154.2: The postcondition at 172.11 might not hold. The expression at 172.11 might not evaluate to true."} Seq#Contains(Heap[this, AVLTreeNode.keys], k#8);
  assert {:msg "  154.2: The postcondition at 163.11 might not hold. The permission at 163.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  154.2: The postcondition at 163.11 might not hold. Insufficient fraction at 163.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_255[this, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_255[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_255[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_255[this, AVLTreeNode.valid] := exhaleMask#_255[this, AVLTreeNode.valid][perm$R := exhaleMask#_255[this, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (!CanRead(exhaleMask#_255, SecMask, this, AVLTreeNode.valid)) {
    assume Heap[this, AVLTreeNode.valid] < exhaleHeap#_254[this, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_255);
  assume wf(Heap, exhaleMask#_255, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  154.2: The postcondition at 164.11 might not hold. The permission at 164.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  154.2: The postcondition at 164.11 might not hold. Insufficient fraction at 164.11 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_255[this, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_255[this, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_255[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_255[this, AVLTreeNode.keys] := exhaleMask#_255[this, AVLTreeNode.keys][perm$R := exhaleMask#_255[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_255);
  assume wf(Heap, exhaleMask#_255, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  154.2: The postcondition at 165.11 might not hold. The permission at 165.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  154.2: The postcondition at 165.11 might not hold. Insufficient fraction at 165.11 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_255[this, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_255[this, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_255[this, AVLTreeNode.height][perm$N]));
  exhaleMask#_255[this, AVLTreeNode.height] := exhaleMask#_255[this, AVLTreeNode.height][perm$R := exhaleMask#_255[this, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_255);
  assume wf(Heap, exhaleMask#_255, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  154.2: The postcondition at 166.11 might not hold. The permission at 166.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  154.2: The postcondition at 166.11 might not hold. Insufficient fraction at 166.11 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_255[this, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_255[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_255[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_255[this, AVLTreeNode.balanceFactor] := exhaleMask#_255[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_255[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_255);
  assume wf(Heap, exhaleMask#_255, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_255;
  assume IsGoodExhaleState(exhaleHeap#_254, Heap, Mask, SecMask);
  Heap := exhaleHeap#_254;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  154.2: Method might lock/unlock more than allowed."} (forall lk#_260: ref :: {Heap[lk#_260, held]} {Heap[lk#_260, rdheld]} (((0 < Heap[lk#_260, held]) == (0 < old(Heap)[lk#_260, held])) && (Heap[lk#_260, rdheld] == old(Heap)[lk#_260, rdheld])) || false);
  assert {:msg "  154.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.insert$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#9: int where true) returns (r#10: ref where (r#10 == null) || (dtype(r#10) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_261: int;
  var i#82#156: int where true;
  var i#83#158: int where true;
  assume (0 < methodK#_261) && ((1000 * methodK#_261) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  185.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#10 == null);
  assert {:msg "  191.11: Receiver might be null."} r#10 != null;
  assume r#10 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[r#10, AVLTreeNode.valid] := Mask[r#10, AVLTreeNode.valid][perm$R := Mask[r#10, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#10, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#10 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#10, AVLTreeNode.keys] := Mask[r#10, AVLTreeNode.keys][perm$R := Mask[r#10, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#10, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#10 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#10, AVLTreeNode.height] := Mask[r#10, AVLTreeNode.height][perm$R := Mask[r#10, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#10, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#10 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#10, AVLTreeNode.balanceFactor] := Mask[r#10, AVLTreeNode.balanceFactor][perm$R := Mask[r#10, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#10, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  196.16: Receiver might be null."} true ==> (r#10 != null);
  assert {:msg "  196.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#10, AVLTreeNode.keys);
  assume Seq#Contains(Heap[r#10, AVLTreeNode.keys], k#9);
  assert {:msg "  197.11: Receiver might be null."} true && (0 <= i#82#156) ==> (this != null);
  assert {:msg "  197.11: Location might not be readable."} true && (0 <= i#82#156) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  assert {:msg "  197.11: Receiver might be null."} true && (0 <= i#82#156) && (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  197.11: Location might not be readable."} true && (0 <= i#82#156) && (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  assert {:msg "  197.36: Sequence index might be negative."} true && (0 <= i#82#156) && (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (0 <= i#82#156);
  assert {:msg "  197.36: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#82#156) && (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys]));
  assert {:msg "  197.41: Receiver might be null."} true && (0 <= i#82#156) && (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (r#10 != null);
  assert {:msg "  197.41: Location might not be readable."} true && (0 <= i#82#156) && (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, r#10, AVLTreeNode.keys);
  assume (forall i#82#155: int :: (0 <= i#82#155) && (i#82#155 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#10, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#82#155)));
  assert {:msg "  198.11: Receiver might be null."} true && (0 <= i#83#158) ==> (r#10 != null);
  assert {:msg "  198.11: Location might not be readable."} true && (0 <= i#83#158) ==> CanRead(Mask, SecMask, r#10, AVLTreeNode.keys);
  assert {:msg "  198.11: Receiver might be null."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (r#10 != null);
  assert {:msg "  198.11: Location might not be readable."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, r#10, AVLTreeNode.keys);
  assert {:msg "  198.35: Sequence index might be negative."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (0 <= i#83#158);
  assert {:msg "  198.35: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys]));
  assert {:msg "  198.44: Receiver might be null."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  198.44: Location might not be readable."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  assert {:msg "  198.11: Receiver might be null."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) && (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#158))) ==> (r#10 != null);
  assert {:msg "  198.11: Location might not be readable."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) && (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#158))) ==> CanRead(Mask, SecMask, r#10, AVLTreeNode.keys);
  assert {:msg "  198.35: Sequence index might be negative."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) && (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#158))) ==> (0 <= i#83#158);
  assert {:msg "  198.35: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) && (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#158))) ==> (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys]));
  assume (forall i#83#157: int :: (0 <= i#83#157) && (i#83#157 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#157)) || (Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#157) == k#9)));
  assert {:msg "  199.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  199.20: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  199.30: Receiver might be null."} true ==> (r#10 != null);
    assert {:msg "  199.30: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#10, AVLTreeNode.keys);
    assert {:msg "  199.42: Receiver might be null."} true ==> (this != null);
    assert {:msg "  199.42: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
    assume Seq#Equal(Heap[r#10, AVLTreeNode.keys], old(Heap)[this, AVLTreeNode.keys]);
  }
  assert {:msg "  200.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  200.22: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  200.34: Receiver might be null."} true ==> (r#10 != null);
    assert {:msg "  200.34: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#10, AVLTreeNode.keys);
    assert {:msg "  200.50: Receiver might be null."} true ==> (this != null);
    assert {:msg "  200.50: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
    assume Seq#Length(Heap[r#10, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this, AVLTreeNode.keys]) + 1);
  }
  assert {:msg "  202.13: Receiver might be null."} true ==> (r#10 != null);
  assert {:msg "  202.13: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#10, AVLTreeNode.height);
  assert {:msg "  202.29: Receiver might be null."} true ==> (this != null);
  assert {:msg "  202.29: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
  assert {:msg "  202.44: Receiver might be null."} true && (!(Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#10 != null);
  assert {:msg "  202.44: Location might not be readable."} true && (!(Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask, SecMask, r#10, AVLTreeNode.height);
  assert {:msg "  202.60: Receiver might be null."} true && (!(Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  202.60: Location might not be readable."} true && (!(Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
  assume (Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap[r#10, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] + 1));
  assert {:msg "  203.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  203.20: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  203.30: Receiver might be null."} true ==> (r#10 != null);
    assert {:msg "  203.30: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#10, AVLTreeNode.height);
    assert {:msg "  203.44: Receiver might be null."} true ==> (this != null);
    assert {:msg "  203.44: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
    assume Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.insert(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#9: int where true) returns (r#10: ref where (r#10 == null) || (dtype(r#10) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_261: int;
  var unfoldK#_262: int;
  var oldVers#_282: int;
  var newVers#_283: int;
  var cond#_284: bool;
  var assertHeap#_285: HeapType;
  var assertMask#_286: MaskType;
  var assertSecMask#_287: MaskType;
  var assertCredits#_288: CreditsType;
  var exhaleMask#_290: MaskType;
  var exhaleHeap#_289: HeapType;
  var methodCallK#_295: int;
  var this#165: ref where (this#165 == null) || (dtype(this#165) == AVLTreeNode#t);
  var callHeap#_291: HeapType;
  var callMask#_292: MaskType;
  var callSecMask#_293: MaskType;
  var callCredits#_294: CreditsType;
  var exhaleMask#_297: MaskType;
  var exhaleHeap#_296: HeapType;
  var isHeld#_312: int;
  var isRdHeld#_313: bool;
  var cond#_314: bool;
  var nl#12: ref where (nl#12 == null) || (dtype(nl#12) == AVLTreeNode#t);
  var cond#_315: bool;
  var nw#_316: ref;
  var methodCallK#_321: int;
  var this#170: ref where (this#170 == null) || (dtype(this#170) == AVLTreeNode#t);
  var k#171: int where true;
  var callHeap#_317: HeapType;
  var callMask#_318: MaskType;
  var callSecMask#_319: MaskType;
  var callCredits#_320: CreditsType;
  var exhaleMask#_323: MaskType;
  var exhaleHeap#_322: HeapType;
  var isHeld#_330: int;
  var isRdHeld#_331: bool;
  var methodCallK#_336: int;
  var this#172: ref where (this#172 == null) || (dtype(this#172) == AVLTreeNode#t);
  var k#173: int where true;
  var r#174: ref where (r#174 == null) || (dtype(r#174) == AVLTreeNode#t);
  var callHeap#_332: HeapType;
  var callMask#_333: MaskType;
  var callSecMask#_334: MaskType;
  var callCredits#_335: CreditsType;
  var exhaleMask#_338: MaskType;
  var exhaleHeap#_337: HeapType;
  var isHeld#_343: int;
  var isRdHeld#_344: bool;
  var bf#14: int where true;
  var methodCallK#_349: int;
  var this#177: ref where (this#177 == null) || (dtype(this#177) == AVLTreeNode#t);
  var bf#178: int where true;
  var callHeap#_345: HeapType;
  var callMask#_346: MaskType;
  var callSecMask#_347: MaskType;
  var callCredits#_348: CreditsType;
  var exhaleMask#_351: MaskType;
  var exhaleHeap#_350: HeapType;
  var isHeld#_358: int;
  var isRdHeld#_359: bool;
  var cond#_360: bool;
  var methodCallK#_365: int;
  var this#179: ref where (this#179 == null) || (dtype(this#179) == AVLTreeNode#t);
  var r#180: ref where (r#180 == null) || (dtype(r#180) == AVLTreeNode#t);
  var callHeap#_361: HeapType;
  var callMask#_362: MaskType;
  var callSecMask#_363: MaskType;
  var callCredits#_364: CreditsType;
  var exhaleMask#_367: MaskType;
  var exhaleHeap#_366: HeapType;
  var isHeld#_382: int;
  var isRdHeld#_383: bool;
  var methodCallK#_388: int;
  var this#185: ref where (this#185 == null) || (dtype(this#185) == AVLTreeNode#t);
  var callHeap#_384: HeapType;
  var callMask#_385: MaskType;
  var callSecMask#_386: MaskType;
  var callCredits#_387: CreditsType;
  var exhaleMask#_390: MaskType;
  var exhaleHeap#_389: HeapType;
  var isHeld#_405: int;
  var isRdHeld#_406: bool;
  var nr#16: ref where (nr#16 == null) || (dtype(nr#16) == AVLTreeNode#t);
  var cond#_407: bool;
  var nw#_408: ref;
  var methodCallK#_413: int;
  var this#190: ref where (this#190 == null) || (dtype(this#190) == AVLTreeNode#t);
  var k#191: int where true;
  var callHeap#_409: HeapType;
  var callMask#_410: MaskType;
  var callSecMask#_411: MaskType;
  var callCredits#_412: CreditsType;
  var exhaleMask#_415: MaskType;
  var exhaleHeap#_414: HeapType;
  var isHeld#_422: int;
  var isRdHeld#_423: bool;
  var methodCallK#_428: int;
  var this#192: ref where (this#192 == null) || (dtype(this#192) == AVLTreeNode#t);
  var k#193: int where true;
  var r#194: ref where (r#194 == null) || (dtype(r#194) == AVLTreeNode#t);
  var callHeap#_424: HeapType;
  var callMask#_425: MaskType;
  var callSecMask#_426: MaskType;
  var callCredits#_427: CreditsType;
  var exhaleMask#_430: MaskType;
  var exhaleHeap#_429: HeapType;
  var isHeld#_435: int;
  var isRdHeld#_436: bool;
  var bf#18: int where true;
  var methodCallK#_441: int;
  var this#197: ref where (this#197 == null) || (dtype(this#197) == AVLTreeNode#t);
  var bf#198: int where true;
  var callHeap#_437: HeapType;
  var callMask#_438: MaskType;
  var callSecMask#_439: MaskType;
  var callCredits#_440: CreditsType;
  var exhaleMask#_443: MaskType;
  var exhaleHeap#_442: HeapType;
  var isHeld#_450: int;
  var isRdHeld#_451: bool;
  var cond#_452: bool;
  var methodCallK#_457: int;
  var this#199: ref where (this#199 == null) || (dtype(this#199) == AVLTreeNode#t);
  var r#200: ref where (r#200 == null) || (dtype(r#200) == AVLTreeNode#t);
  var callHeap#_453: HeapType;
  var callMask#_454: MaskType;
  var callSecMask#_455: MaskType;
  var callCredits#_456: CreditsType;
  var exhaleMask#_459: MaskType;
  var exhaleHeap#_458: HeapType;
  var isHeld#_474: int;
  var isRdHeld#_475: bool;
  var methodCallK#_480: int;
  var this#205: ref where (this#205 == null) || (dtype(this#205) == AVLTreeNode#t);
  var callHeap#_476: HeapType;
  var callMask#_477: MaskType;
  var callSecMask#_478: MaskType;
  var callCredits#_479: CreditsType;
  var exhaleMask#_482: MaskType;
  var exhaleHeap#_481: HeapType;
  var isHeld#_497: int;
  var isRdHeld#_498: bool;
  var exhaleMask#_500: MaskType;
  var exhaleHeap#_499: HeapType;

//urij test
/*  assume (this!=Heap[this,AVLTreeNode.left]);
  assume (this!=Heap[this,AVLTreeNode.right]);
  assume (null!=Heap[this,AVLTreeNode.left]);
  assume (null!=Heap[this,AVLTreeNode.right]);
  assume (Heap[this,AVLTreeNode.left]!=Heap[this,AVLTreeNode.right]);*/
//urij test


  assume (0 < methodK#_261) && ((1000 * methodK#_261) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // unfold
  assume #AVLTreeNode.valid#trigger(this);
  assume (0 < unfoldK#_262) && (unfoldK#_262 < Fractions(1)) && ((1000 * unfoldK#_262) < methodK#_261);
  assert {:msg "  205.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  205.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  205.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[this, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[this, AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[this, AVLTreeNode.valid][perm$N]));
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#159: int :: (0 <= lk#79#159) && (lk#79#159 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#159) < Heap[this, AVLTreeNode.key]));
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#160: int :: (0 <= rk#80#160) && (rk#80#160 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#160)));
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] > 0;
    SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, this, AVLTreeNode.valid)) {
    oldVers#_282 := Heap[this, AVLTreeNode.valid];
    havoc newVers#_283;
    Heap[this, AVLTreeNode.valid] := newVers#_283;
    assume oldVers#_282 < Heap[this, AVLTreeNode.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#163: int :: (0 <= lk#79#163) && (lk#79#163 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#163) < Heap[this, AVLTreeNode.key]));
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#164: int :: (0 <= rk#80#164) && (rk#80#164 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#164)));
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_284 := Heap[this, AVLTreeNode.key] == k#9;
  assert {:msg "  206.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  206.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  if (cond#_284) {
    // assigment to r
    r#10 := this;
    // assert
    assertHeap#_285 := Heap;
    assertMask#_286 := Mask;
    assertSecMask#_287 := SecMask;
    assertCredits#_288 := Credits;
    assume wf(assertHeap#_285, assertMask#_286, assertSecMask#_287);
    // begin exhale (assert)
    exhaleMask#_290 := assertMask#_286;
    havoc exhaleHeap#_289;
    assert {:msg "  208.15: Receiver might be null."} true ==> (this != null);
    assert {:msg "  208.15: Location might not be readable."} true ==> CanRead(assertMask#_286, assertSecMask#_287, this, AVLTreeNode.key);
    assert {:msg "  208.14: Sequence index might be negative."} true ==> (0 <= 0);
    assert {:msg "  208.14: Sequence index might be larger than or equal to the length of the sequence."} true ==> (0 < Seq#Length(Seq#Singleton(assertHeap#_285[this, AVLTreeNode.key])));
    assert {:msg "  208.4: Assertion might not hold. The expression at 208.11 might not evaluate to true."} k#9 == Seq#Index(Seq#Singleton(assertHeap#_285[this, AVLTreeNode.key]), 0);
    assertMask#_286 := exhaleMask#_290;
    assume IsGoodExhaleState(exhaleHeap#_289, assertHeap#_285, assertMask#_286, assertSecMask#_287);
    assertHeap#_285 := exhaleHeap#_289;
    assume IsGoodMask(assertMask#_286);
    assume wf(assertHeap#_285, assertMask#_286, assertSecMask#_287);
    // end exhale
    assume (0 < methodCallK#_295) && ((1000 * methodCallK#_295) < Fractions(1)) && ((1000 * methodCallK#_295) < methodK#_261);
    // call close
    callHeap#_291 := Heap;
    callMask#_292 := Mask;
    callSecMask#_293 := SecMask;
    callCredits#_294 := Credits;
    assume wf(callHeap#_291, callMask#_292, callSecMask#_293);
    assert {:msg "  209.4: The target of the method call might be null."} r#10 != null;
    this#165 := r#10;
    // begin exhale (precondition)
    exhaleMask#_297 := Mask;
    havoc exhaleHeap#_296;
    if (!(Heap[this#165, AVLTreeNode.left] == null)) {
      assert {:msg "  209.4: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#166: int :: (0 <= k#92#166) && (k#92#166 < Seq#Length(Heap[Heap[this#165, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#165, AVLTreeNode.left], AVLTreeNode.keys], k#92#166) < Heap[this#165, AVLTreeNode.key]));
    }
    if (!(Heap[this#165, AVLTreeNode.right] == null)) {
      assert {:msg "  209.4: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#167: int :: (0 <= k#93#167) && (k#93#167 < Seq#Length(Heap[Heap[this#165, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#165, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#165, AVLTreeNode.right], AVLTreeNode.keys], k#93#167)));
    }
    assert {:msg "  209.4: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#165, AVLTreeNode.left] == null, 0, Heap[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#165, AVLTreeNode.right] == null, 0, Heap[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
    assert {:msg "  209.4: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#165, AVLTreeNode.left] == null, 0, Heap[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#165, AVLTreeNode.right] == null, 0, Heap[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
    assert {:msg "  209.4: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  209.4: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_297[this#165, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_297[this#165, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_297[this#165, AVLTreeNode.key][perm$N]));
    exhaleMask#_297[this#165, AVLTreeNode.key] := exhaleMask#_297[this#165, AVLTreeNode.key][perm$R := exhaleMask#_297[this#165, AVLTreeNode.key][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_297);
    assume wf(Heap, exhaleMask#_297, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  209.4: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  209.4: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_297[this#165, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_297[this#165, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_297[this#165, AVLTreeNode.height][perm$N]));
    exhaleMask#_297[this#165, AVLTreeNode.height] := exhaleMask#_297[this#165, AVLTreeNode.height][perm$R := exhaleMask#_297[this#165, AVLTreeNode.height][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_297);
    assume wf(Heap, exhaleMask#_297, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  209.4: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  209.4: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_297[this#165, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_297[this#165, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_297[this#165, AVLTreeNode.left][perm$N]));
    exhaleMask#_297[this#165, AVLTreeNode.left] := exhaleMask#_297[this#165, AVLTreeNode.left][perm$R := exhaleMask#_297[this#165, AVLTreeNode.left][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_297);
    assume wf(Heap, exhaleMask#_297, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  209.4: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  209.4: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_297[this#165, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_297[this#165, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_297[this#165, AVLTreeNode.right][perm$N]));
    exhaleMask#_297[this#165, AVLTreeNode.right] := exhaleMask#_297[this#165, AVLTreeNode.right][perm$R := exhaleMask#_297[this#165, AVLTreeNode.right][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_297);
    assume wf(Heap, exhaleMask#_297, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  209.4: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  209.4: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_297[this#165, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_297[this#165, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_297[this#165, AVLTreeNode.keys][perm$N]));
    exhaleMask#_297[this#165, AVLTreeNode.keys] := exhaleMask#_297[this#165, AVLTreeNode.keys][perm$R := exhaleMask#_297[this#165, AVLTreeNode.keys][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_297);
    assume wf(Heap, exhaleMask#_297, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  209.4: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  209.4: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_297[this#165, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_297[this#165, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_297[this#165, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_297[this#165, AVLTreeNode.balanceFactor] := exhaleMask#_297[this#165, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_297[this#165, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_297);
    assume wf(Heap, exhaleMask#_297, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#165, AVLTreeNode.left] == null)) {
      assert {:msg "  209.4: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
      assert {:msg "  209.4: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (!CanRead(exhaleMask#_297, SecMask, Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_296[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_297);
      assume wf(Heap, exhaleMask#_297, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#165, AVLTreeNode.left] == null)) {
      assert {:msg "  209.4: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
      assert {:msg "  209.4: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_297);
      assume wf(Heap, exhaleMask#_297, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#165, AVLTreeNode.left] == null)) {
      assert {:msg "  209.4: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
      assert {:msg "  209.4: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_297);
      assume wf(Heap, exhaleMask#_297, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#165, AVLTreeNode.left] == null)) {
      assert {:msg "  209.4: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
      assert {:msg "  209.4: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_297[Heap[this#165, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_297);
      assume wf(Heap, exhaleMask#_297, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#165, AVLTreeNode.right] == null)) {
      assert {:msg "  209.4: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
      assert {:msg "  209.4: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (!CanRead(exhaleMask#_297, SecMask, Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_296[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_297);
      assume wf(Heap, exhaleMask#_297, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#165, AVLTreeNode.right] == null)) {
      assert {:msg "  209.4: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  209.4: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_297);
      assume wf(Heap, exhaleMask#_297, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#165, AVLTreeNode.right] == null)) {
      assert {:msg "  209.4: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  209.4: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_297);
      assume wf(Heap, exhaleMask#_297, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#165, AVLTreeNode.right] == null)) {
      assert {:msg "  209.4: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  209.4: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_297[Heap[this#165, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_297);
      assume wf(Heap, exhaleMask#_297, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_297;
    assume IsGoodExhaleState(exhaleHeap#_296, Heap, Mask, SecMask);
    Heap := exhaleHeap#_296;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    // inhale (postcondition)
    assume this#165 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[this#165, AVLTreeNode.valid] := Mask[this#165, AVLTreeNode.valid][perm$R := Mask[this#165, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#165, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#165 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[this#165, AVLTreeNode.height] := Mask[this#165, AVLTreeNode.height][perm$R := Mask[this#165, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#165, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#165 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[this#165, AVLTreeNode.keys] := Mask[this#165, AVLTreeNode.keys][perm$R := Mask[this#165, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#165, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#165 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[this#165, AVLTreeNode.balanceFactor] := Mask[this#165, AVLTreeNode.balanceFactor][perm$R := Mask[this#165, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#165, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Seq#Equal(Heap[this#165, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_291[this#165, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_291[callHeap#_291[this#165, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_291[this#165, AVLTreeNode.key])), ite(callHeap#_291[this#165, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_291[callHeap#_291[this#165, AVLTreeNode.right], AVLTreeNode.keys])));
    assume Heap[this#165, AVLTreeNode.height] == ite(ite(callHeap#_291[this#165, AVLTreeNode.left] == null, 0, callHeap#_291[callHeap#_291[this#165, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_291[this#165, AVLTreeNode.right] == null, 0, callHeap#_291[callHeap#_291[this#165, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_291[this#165, AVLTreeNode.left] == null, 0, callHeap#_291[callHeap#_291[this#165, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_291[this#165, AVLTreeNode.right] == null, 0, callHeap#_291[callHeap#_291[this#165, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap[this#165, AVLTreeNode.balanceFactor] == (ite(callHeap#_291[this#165, AVLTreeNode.left] == null, 0, callHeap#_291[callHeap#_291[this#165, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_291[this#165, AVLTreeNode.right] == null, 0, callHeap#_291[callHeap#_291[this#165, AVLTreeNode.right], AVLTreeNode.height]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
  } else {
    // if
    cond#_314 := k#9 < Heap[this, AVLTreeNode.key];
    assert {:msg "  211.10: Receiver might be null."} true ==> (this != null);
    assert {:msg "  211.10: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    if (cond#_314) {
      // local var nl
      // if
      cond#_315 := Heap[this, AVLTreeNode.left] == null;
      assert {:msg "  213.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  213.9: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
      if (cond#_315) {
        // assigment to nl
        // new
        havoc nw#_316;
        assume (nw#_316 != null) && (dtype(nw#_316) == AVLTreeNode#t);
        assume (forall<T#_1> f: Field (T#_1) :: (Mask[nw#_316, f][perm$R] == 0) && (Mask[nw#_316, f][perm$N] == 0));
        assume Heap[nw#_316, mu] == $LockBottom;
        assume Heap[nw#_316, held] <= 0;
        assume Heap[nw#_316, rdheld] == false;
        Mask[nw#_316, AVLTreeNode.key] := Mask[nw#_316, AVLTreeNode.key][perm$R := Mask[nw#_316, AVLTreeNode.key][perm$R] + Fractions(100)];
        Mask[nw#_316, AVLTreeNode.height] := Mask[nw#_316, AVLTreeNode.height][perm$R := Mask[nw#_316, AVLTreeNode.height][perm$R] + Fractions(100)];
        Mask[nw#_316, AVLTreeNode.left] := Mask[nw#_316, AVLTreeNode.left][perm$R := Mask[nw#_316, AVLTreeNode.left][perm$R] + Fractions(100)];
        Mask[nw#_316, AVLTreeNode.right] := Mask[nw#_316, AVLTreeNode.right][perm$R := Mask[nw#_316, AVLTreeNode.right][perm$R] + Fractions(100)];
        Mask[nw#_316, AVLTreeNode.keys] := Mask[nw#_316, AVLTreeNode.keys][perm$R := Mask[nw#_316, AVLTreeNode.keys][perm$R] + Fractions(100)];
        Mask[nw#_316, AVLTreeNode.balanceFactor] := Mask[nw#_316, AVLTreeNode.balanceFactor][perm$R := Mask[nw#_316, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
        Mask[nw#_316, mu] := Mask[nw#_316, mu][perm$R := Mask[nw#_316, mu][perm$R] + Fractions(100)];
        nl#12 := nw#_316;
        assume (0 < methodCallK#_321) && ((1000 * methodCallK#_321) < Fractions(1)) && ((1000 * methodCallK#_321) < methodK#_261);
        // call init
        callHeap#_317 := Heap;
        callMask#_318 := Mask;
        callSecMask#_319 := SecMask;
        callCredits#_320 := Credits;
        assume wf(callHeap#_317, callMask#_318, callSecMask#_319);
        assert {:msg "  215.6: The target of the method call might be null."} nl#12 != null;
        this#170 := nl#12;
        k#171 := k#9;
        // begin exhale (precondition)
        exhaleMask#_323 := Mask;
        havoc exhaleHeap#_322;
        assert {:msg "  215.6: The precondition at 155.12 might not hold. The permission at 155.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  215.6: The precondition at 155.12 might not hold. Insufficient fraction at 155.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_323[this#170, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_323[this#170, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_323[this#170, AVLTreeNode.key][perm$N]));
        exhaleMask#_323[this#170, AVLTreeNode.key] := exhaleMask#_323[this#170, AVLTreeNode.key][perm$R := exhaleMask#_323[this#170, AVLTreeNode.key][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_323);
        assume wf(Heap, exhaleMask#_323, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  215.6: The precondition at 156.12 might not hold. The permission at 156.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  215.6: The precondition at 156.12 might not hold. Insufficient fraction at 156.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_323[this#170, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_323[this#170, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_323[this#170, AVLTreeNode.height][perm$N]));
        exhaleMask#_323[this#170, AVLTreeNode.height] := exhaleMask#_323[this#170, AVLTreeNode.height][perm$R := exhaleMask#_323[this#170, AVLTreeNode.height][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_323);
        assume wf(Heap, exhaleMask#_323, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  215.6: The precondition at 157.12 might not hold. The permission at 157.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  215.6: The precondition at 157.12 might not hold. Insufficient fraction at 157.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_323[this#170, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_323[this#170, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_323[this#170, AVLTreeNode.left][perm$N]));
        exhaleMask#_323[this#170, AVLTreeNode.left] := exhaleMask#_323[this#170, AVLTreeNode.left][perm$R := exhaleMask#_323[this#170, AVLTreeNode.left][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_323);
        assume wf(Heap, exhaleMask#_323, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  215.6: The precondition at 158.12 might not hold. The permission at 158.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  215.6: The precondition at 158.12 might not hold. Insufficient fraction at 158.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_323[this#170, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_323[this#170, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_323[this#170, AVLTreeNode.right][perm$N]));
        exhaleMask#_323[this#170, AVLTreeNode.right] := exhaleMask#_323[this#170, AVLTreeNode.right][perm$R := exhaleMask#_323[this#170, AVLTreeNode.right][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_323);
        assume wf(Heap, exhaleMask#_323, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  215.6: The precondition at 160.12 might not hold. The permission at 160.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  215.6: The precondition at 160.12 might not hold. Insufficient fraction at 160.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_323[this#170, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_323[this#170, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_323[this#170, AVLTreeNode.keys][perm$N]));
        exhaleMask#_323[this#170, AVLTreeNode.keys] := exhaleMask#_323[this#170, AVLTreeNode.keys][perm$R := exhaleMask#_323[this#170, AVLTreeNode.keys][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_323);
        assume wf(Heap, exhaleMask#_323, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  215.6: The precondition at 161.12 might not hold. The permission at 161.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  215.6: The precondition at 161.12 might not hold. Insufficient fraction at 161.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_323[this#170, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_323[this#170, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_323[this#170, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_323[this#170, AVLTreeNode.balanceFactor] := exhaleMask#_323[this#170, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_323[this#170, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_323);
        assume wf(Heap, exhaleMask#_323, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_323;
        assume IsGoodExhaleState(exhaleHeap#_322, Heap, Mask, SecMask);
        Heap := exhaleHeap#_322;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        // inhale (postcondition)
        assume this#170 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[this#170, AVLTreeNode.valid] := Mask[this#170, AVLTreeNode.valid][perm$R := Mask[this#170, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#170, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#170 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#170, AVLTreeNode.keys] := Mask[this#170, AVLTreeNode.keys][perm$R := Mask[this#170, AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#170, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#170 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#170, AVLTreeNode.height] := Mask[this#170, AVLTreeNode.height][perm$R := Mask[this#170, AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#170, AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#170 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#170, AVLTreeNode.balanceFactor] := Mask[this#170, AVLTreeNode.balanceFactor][perm$R := Mask[this#170, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#170, AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Heap[this#170, AVLTreeNode.height] == 1;
        assume Seq#Equal(Heap[this#170, AVLTreeNode.keys], Seq#Singleton(k#171));
        assume Heap[this#170, AVLTreeNode.balanceFactor] == 0;
        assume Seq#Contains(Heap[this#170, AVLTreeNode.keys], k#171);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
      } else {
        assume (0 < methodCallK#_336) && ((1000 * methodCallK#_336) < Fractions(1)) && ((1000 * methodCallK#_336) < methodK#_261);
        // call insert
        callHeap#_332 := Heap;
        callMask#_333 := Mask;
        callSecMask#_334 := SecMask;
        callCredits#_335 := Credits;
        assume wf(callHeap#_332, callMask#_333, callSecMask#_334);
        assert {:msg "  217.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  217.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
        assert {:msg "  217.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#172 := Heap[this, AVLTreeNode.left];
        k#173 := k#9;
        // begin exhale (precondition)
        exhaleMask#_338 := Mask;
        havoc exhaleHeap#_337;
        assert {:msg "  217.6: The precondition at 185.12 might not hold. The permission at 185.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  217.6: The precondition at 185.12 might not hold. Insufficient fraction at 185.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_338[this#172, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_338[this#172, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_338[this#172, AVLTreeNode.valid][perm$N]));
        exhaleMask#_338[this#172, AVLTreeNode.valid] := exhaleMask#_338[this#172, AVLTreeNode.valid][perm$R := exhaleMask#_338[this#172, AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_338, SecMask, this#172, AVLTreeNode.valid)) {
          assume Heap[this#172, AVLTreeNode.valid] < exhaleHeap#_337[this#172, AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_338);
        assume wf(Heap, exhaleMask#_338, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  217.6: The precondition at 186.12 might not hold. The permission at 186.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  217.6: The precondition at 186.12 might not hold. Insufficient fraction at 186.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_338[this#172, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_338[this#172, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_338[this#172, AVLTreeNode.keys][perm$N]));
        exhaleMask#_338[this#172, AVLTreeNode.keys] := exhaleMask#_338[this#172, AVLTreeNode.keys][perm$R := exhaleMask#_338[this#172, AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_338);
        assume wf(Heap, exhaleMask#_338, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  217.6: The precondition at 187.12 might not hold. The permission at 187.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  217.6: The precondition at 187.12 might not hold. Insufficient fraction at 187.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_338[this#172, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_338[this#172, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_338[this#172, AVLTreeNode.height][perm$N]));
        exhaleMask#_338[this#172, AVLTreeNode.height] := exhaleMask#_338[this#172, AVLTreeNode.height][perm$R := exhaleMask#_338[this#172, AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_338);
        assume wf(Heap, exhaleMask#_338, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  217.6: The precondition at 188.12 might not hold. The permission at 188.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  217.6: The precondition at 188.12 might not hold. Insufficient fraction at 188.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_338[this#172, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_338[this#172, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_338[this#172, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_338[this#172, AVLTreeNode.balanceFactor] := exhaleMask#_338[this#172, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_338[this#172, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_338);
        assume wf(Heap, exhaleMask#_338, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_338;
        assume IsGoodExhaleState(exhaleHeap#_337, Heap, Mask, SecMask);
        Heap := exhaleHeap#_337;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#174;
        // inhale (postcondition)
        assume !(r#174 == null);
        assume r#174 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[r#174, AVLTreeNode.valid] := Mask[r#174, AVLTreeNode.valid][perm$R := Mask[r#174, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#174, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#174 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[r#174, AVLTreeNode.keys] := Mask[r#174, AVLTreeNode.keys][perm$R := Mask[r#174, AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#174, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#174 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[r#174, AVLTreeNode.height] := Mask[r#174, AVLTreeNode.height][perm$R := Mask[r#174, AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#174, AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#174 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[r#174, AVLTreeNode.balanceFactor] := Mask[r#174, AVLTreeNode.balanceFactor][perm$R := Mask[r#174, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#174, AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Seq#Contains(Heap[r#174, AVLTreeNode.keys], k#173);
        assume (forall i#82#175: int :: (0 <= i#82#175) && (i#82#175 < Seq#Length(callHeap#_332[this#172, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#174, AVLTreeNode.keys], Seq#Index(callHeap#_332[this#172, AVLTreeNode.keys], i#82#175)));
        assume (forall i#83#176: int :: (0 <= i#83#176) && (i#83#176 < Seq#Length(Heap[r#174, AVLTreeNode.keys])) ==> (Seq#Contains(callHeap#_332[this#172, AVLTreeNode.keys], Seq#Index(Heap[r#174, AVLTreeNode.keys], i#83#176)) || (Seq#Index(Heap[r#174, AVLTreeNode.keys], i#83#176) == k#173)));
        if (Seq#Contains(callHeap#_332[this#172, AVLTreeNode.keys], k#173)) {
          assume Seq#Equal(Heap[r#174, AVLTreeNode.keys], callHeap#_332[this#172, AVLTreeNode.keys]);
        }
        if (!Seq#Contains(callHeap#_332[this#172, AVLTreeNode.keys], k#173)) {
          assume Seq#Length(Heap[r#174, AVLTreeNode.keys]) == (Seq#Length(callHeap#_332[this#172, AVLTreeNode.keys]) + 1);
        }
        assume (Heap[r#174, AVLTreeNode.height] == callHeap#_332[this#172, AVLTreeNode.height]) || (Heap[r#174, AVLTreeNode.height] == (callHeap#_332[this#172, AVLTreeNode.height] + 1));
        if (Seq#Contains(callHeap#_332[this#172, AVLTreeNode.keys], k#173)) {
          assume Heap[r#174, AVLTreeNode.height] == callHeap#_332[this#172, AVLTreeNode.height];
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        nl#12 := r#174;
      }
      // update field left
      assert {:msg "  219.5: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
      Heap[this, AVLTreeNode.left] := nl#12;
      assume wf(Heap, Mask, SecMask);
      // local var bf
      assume (0 < methodCallK#_349) && ((1000 * methodCallK#_349) < Fractions(1)) && ((1000 * methodCallK#_349) < methodK#_261);
      // call getBalanceFactorI
      callHeap#_345 := Heap;
      callMask#_346 := Mask;
      callSecMask#_347 := SecMask;
      callCredits#_348 := Credits;
      assume wf(callHeap#_345, callMask#_346, callSecMask#_347);
      assert {:msg "  221.5: The target of the method call might be null."} this != null;
      this#177 := this;
      // begin exhale (precondition)
      exhaleMask#_351 := Mask;
      havoc exhaleHeap#_350;
      assert {:msg "  221.5: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_349 > 0;
      assert {:msg "  221.5: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_351[this#177, AVLTreeNode.left][perm$R] > 0;
      assume methodCallK#_349 < exhaleMask#_351[this#177, AVLTreeNode.left][perm$R];
      exhaleMask#_351[this#177, AVLTreeNode.left] := exhaleMask#_351[this#177, AVLTreeNode.left][perm$R := exhaleMask#_351[this#177, AVLTreeNode.left][perm$R] - methodCallK#_349];
      assume IsGoodMask(exhaleMask#_351);
      assume wf(Heap, exhaleMask#_351, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#177, AVLTreeNode.left] == null)) {
        assert {:msg "  221.5: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_349 > 0;
        assert {:msg "  221.5: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_351[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0;
        assume methodCallK#_349 < exhaleMask#_351[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height][perm$R];
        exhaleMask#_351[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_351[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_351[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_349];
        assume IsGoodMask(exhaleMask#_351);
        assume wf(Heap, exhaleMask#_351, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assert {:msg "  221.5: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_349 > 0;
      assert {:msg "  221.5: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_351[this#177, AVLTreeNode.right][perm$R] > 0;
      assume methodCallK#_349 < exhaleMask#_351[this#177, AVLTreeNode.right][perm$R];
      exhaleMask#_351[this#177, AVLTreeNode.right] := exhaleMask#_351[this#177, AVLTreeNode.right][perm$R := exhaleMask#_351[this#177, AVLTreeNode.right][perm$R] - methodCallK#_349];
      assume IsGoodMask(exhaleMask#_351);
      assume wf(Heap, exhaleMask#_351, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#177, AVLTreeNode.right] == null)) {
        assert {:msg "  221.5: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_349 > 0;
        assert {:msg "  221.5: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_351[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0;
        assume methodCallK#_349 < exhaleMask#_351[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height][perm$R];
        exhaleMask#_351[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_351[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_351[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_349];
        assume IsGoodMask(exhaleMask#_351);
        assume wf(Heap, exhaleMask#_351, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#177, AVLTreeNode.left] == null)) {
        assert {:msg "  221.5: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} Fractions(100) > 0;
        assert {:msg "  221.5: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_351[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_351[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_351[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_351[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_351[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_351[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_351, SecMask, Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_350[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_351);
        assume wf(Heap, exhaleMask#_351, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#177, AVLTreeNode.right] == null)) {
        assert {:msg "  221.5: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} Fractions(100) > 0;
        assert {:msg "  221.5: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_351[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_351[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_351[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_351[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_351[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_351[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_351, SecMask, Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_350[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_351);
        assume wf(Heap, exhaleMask#_351, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_351;
      assume IsGoodExhaleState(exhaleHeap#_350, Heap, Mask, SecMask);
      Heap := exhaleHeap#_350;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      havoc bf#178;
      // inhale (postcondition)
      assume this#177 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[this#177, AVLTreeNode.left] == null) || (dtype(Heap[this#177, AVLTreeNode.left]) == AVLTreeNode#t);
      assume methodCallK#_349 > 0;
      Mask[this#177, AVLTreeNode.left] := Mask[this#177, AVLTreeNode.left][perm$R := Mask[this#177, AVLTreeNode.left][perm$R] + methodCallK#_349];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#177, AVLTreeNode.left]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#177, AVLTreeNode.left] == null)) {
        assume Heap[this#177, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#177, AVLTreeNode.left] == null)) {
        assume Heap[this#177, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_349 > 0;
        Mask[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_349];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume this#177 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[this#177, AVLTreeNode.right] == null) || (dtype(Heap[this#177, AVLTreeNode.right]) == AVLTreeNode#t);
      assume methodCallK#_349 > 0;
      Mask[this#177, AVLTreeNode.right] := Mask[this#177, AVLTreeNode.right][perm$R := Mask[this#177, AVLTreeNode.right][perm$R] + methodCallK#_349];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#177, AVLTreeNode.right]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#177, AVLTreeNode.right] == null)) {
        assume Heap[this#177, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#177, AVLTreeNode.right] == null)) {
        assume Heap[this#177, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_349 > 0;
        Mask[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_349];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume bf#178 == (ite(Heap[this#177, AVLTreeNode.left] == null, 0, Heap[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#177, AVLTreeNode.right] == null, 0, Heap[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height]));
      if (bf#178 > 0) {
        assume !(Heap[this#177, AVLTreeNode.left] == null);
      }
      if (bf#178 < 0) {
        assume !(Heap[this#177, AVLTreeNode.right] == null);
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      bf#14 := bf#178;
      // if
      cond#_360 := bf#14 == 2;
      if (cond#_360) {
        assume (0 < methodCallK#_365) && ((1000 * methodCallK#_365) < Fractions(1)) && ((1000 * methodCallK#_365) < methodK#_261);
        // call rebalanceLeft
        callHeap#_361 := Heap;
        callMask#_362 := Mask;
        callSecMask#_363 := SecMask;
        callCredits#_364 := Credits;
        assume wf(callHeap#_361, callMask#_362, callSecMask#_363);
        assert {:msg "  224.6: The target of the method call might be null."} this != null;
        this#179 := this;
        // begin exhale (precondition)
        exhaleMask#_367 := Mask;
        havoc exhaleHeap#_366;
        assert {:msg "  224.6: The precondition at 608.12 might not hold. The expression at 608.12 might not evaluate to true."} !(Heap[this#179, AVLTreeNode.left] == null);
        assert {:msg "  224.6: The precondition at 613.12 might not hold. The expression at 613.12 might not evaluate to true."} (forall k#94#181: int :: (0 <= k#94#181) && (k#94#181 < Seq#Length(Heap[Heap[this#179, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#179, AVLTreeNode.left], AVLTreeNode.keys], k#94#181) < Heap[this#179, AVLTreeNode.key]));
        if (!(Heap[this#179, AVLTreeNode.right] == null)) {
          assert {:msg "  224.6: The precondition at 619.12 might not hold. The expression at 619.28 might not evaluate to true."} (forall k#95#182: int :: (0 <= k#95#182) && (k#95#182 < Seq#Length(Heap[Heap[this#179, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#179, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#179, AVLTreeNode.right], AVLTreeNode.keys], k#95#182)));
        }
        assert {:msg "  224.6: The precondition at 621.12 might not hold. The expression at 621.12 might not evaluate to true."} (Heap[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#179, AVLTreeNode.right] == null, 0, Heap[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height])) == 2;
        assert {:msg "  224.6: The precondition at 600.12 might not hold. The permission at 600.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  224.6: The precondition at 600.12 might not hold. Insufficient fraction at 600.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_367[this#179, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_367[this#179, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_367[this#179, AVLTreeNode.key][perm$N]));
        exhaleMask#_367[this#179, AVLTreeNode.key] := exhaleMask#_367[this#179, AVLTreeNode.key][perm$R := exhaleMask#_367[this#179, AVLTreeNode.key][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_367);
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 601.12 might not hold. The permission at 601.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  224.6: The precondition at 601.12 might not hold. Insufficient fraction at 601.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_367[this#179, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_367[this#179, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_367[this#179, AVLTreeNode.height][perm$N]));
        exhaleMask#_367[this#179, AVLTreeNode.height] := exhaleMask#_367[this#179, AVLTreeNode.height][perm$R := exhaleMask#_367[this#179, AVLTreeNode.height][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_367);
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 602.12 might not hold. The permission at 602.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  224.6: The precondition at 602.12 might not hold. Insufficient fraction at 602.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_367[this#179, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_367[this#179, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_367[this#179, AVLTreeNode.left][perm$N]));
        exhaleMask#_367[this#179, AVLTreeNode.left] := exhaleMask#_367[this#179, AVLTreeNode.left][perm$R := exhaleMask#_367[this#179, AVLTreeNode.left][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_367);
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 603.12 might not hold. The permission at 603.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  224.6: The precondition at 603.12 might not hold. Insufficient fraction at 603.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_367[this#179, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_367[this#179, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_367[this#179, AVLTreeNode.right][perm$N]));
        exhaleMask#_367[this#179, AVLTreeNode.right] := exhaleMask#_367[this#179, AVLTreeNode.right][perm$R := exhaleMask#_367[this#179, AVLTreeNode.right][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_367);
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 605.12 might not hold. The permission at 605.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  224.6: The precondition at 605.12 might not hold. Insufficient fraction at 605.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_367[this#179, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_367[this#179, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_367[this#179, AVLTreeNode.keys][perm$N]));
        exhaleMask#_367[this#179, AVLTreeNode.keys] := exhaleMask#_367[this#179, AVLTreeNode.keys][perm$R := exhaleMask#_367[this#179, AVLTreeNode.keys][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_367);
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 606.12 might not hold. The permission at 606.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  224.6: The precondition at 606.12 might not hold. Insufficient fraction at 606.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_367[this#179, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_367[this#179, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_367[this#179, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_367[this#179, AVLTreeNode.balanceFactor] := exhaleMask#_367[this#179, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_367[this#179, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_367);
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 609.12 might not hold. The permission at 609.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  224.6: The precondition at 609.12 might not hold. Insufficient fraction at 609.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_367, SecMask, Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_366[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_367);
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 610.12 might not hold. The permission at 610.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  224.6: The precondition at 610.12 might not hold. Insufficient fraction at 610.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_367);
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 611.12 might not hold. The permission at 611.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  224.6: The precondition at 611.12 might not hold. Insufficient fraction at 611.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_367);
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 612.12 might not hold. The permission at 612.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  224.6: The precondition at 612.12 might not hold. Insufficient fraction at 612.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_367[Heap[this#179, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_367);
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#179, AVLTreeNode.right] == null)) {
          assert {:msg "  224.6: The precondition at 615.12 might not hold. The permission at 615.28 might not be positive."} Fractions(100) > 0;
          assert {:msg "  224.6: The precondition at 615.12 might not hold. Insufficient fraction at 615.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_367, SecMask, Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_366[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_367);
          assume wf(Heap, exhaleMask#_367, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#179, AVLTreeNode.right] == null)) {
          assert {:msg "  224.6: The precondition at 616.12 might not hold. The permission at 616.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  224.6: The precondition at 616.12 might not hold. Insufficient fraction at 616.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_367);
          assume wf(Heap, exhaleMask#_367, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#179, AVLTreeNode.right] == null)) {
          assert {:msg "  224.6: The precondition at 617.12 might not hold. The permission at 617.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  224.6: The precondition at 617.12 might not hold. Insufficient fraction at 617.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_367);
          assume wf(Heap, exhaleMask#_367, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#179, AVLTreeNode.right] == null)) {
          assert {:msg "  224.6: The precondition at 618.12 might not hold. The permission at 618.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  224.6: The precondition at 618.12 might not hold. Insufficient fraction at 618.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_367[Heap[this#179, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_367);
          assume wf(Heap, exhaleMask#_367, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_367;
        assume IsGoodExhaleState(exhaleHeap#_366, Heap, Mask, SecMask);
        Heap := exhaleHeap#_366;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#180;
        // inhale (postcondition)
        assume !(r#180 == null);
        assume r#180 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[r#180, AVLTreeNode.valid] := Mask[r#180, AVLTreeNode.valid][perm$R := Mask[r#180, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#180, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#180 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[r#180, AVLTreeNode.height] := Mask[r#180, AVLTreeNode.height][perm$R := Mask[r#180, AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#180, AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#180 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[r#180, AVLTreeNode.keys] := Mask[r#180, AVLTreeNode.keys][perm$R := Mask[r#180, AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#180, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#180 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[r#180, AVLTreeNode.balanceFactor] := Mask[r#180, AVLTreeNode.balanceFactor][perm$R := Mask[r#180, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#180, AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume (Heap[r#180, AVLTreeNode.height] == callHeap#_361[callHeap#_361[this#179, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#180, AVLTreeNode.height] == (callHeap#_361[callHeap#_361[this#179, AVLTreeNode.left], AVLTreeNode.height] + 1));
        assume Seq#Equal(Heap[r#180, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_361[callHeap#_361[this#179, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_361[this#179, AVLTreeNode.key])), ite(callHeap#_361[this#179, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_361[callHeap#_361[this#179, AVLTreeNode.right], AVLTreeNode.keys])));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        r#10 := r#180;
      } else {
        // assigment to r
        r#10 := this;
        assume (0 < methodCallK#_388) && ((1000 * methodCallK#_388) < Fractions(1)) && ((1000 * methodCallK#_388) < methodK#_261);
        // call close
        callHeap#_384 := Heap;
        callMask#_385 := Mask;
        callSecMask#_386 := SecMask;
        callCredits#_387 := Credits;
        assume wf(callHeap#_384, callMask#_385, callSecMask#_386);
        assert {:msg "  227.6: The target of the method call might be null."} r#10 != null;
        this#185 := r#10;
        // begin exhale (precondition)
        exhaleMask#_390 := Mask;
        havoc exhaleHeap#_389;
        if (!(Heap[this#185, AVLTreeNode.left] == null)) {
          assert {:msg "  227.6: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#186: int :: (0 <= k#92#186) && (k#92#186 < Seq#Length(Heap[Heap[this#185, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#185, AVLTreeNode.left], AVLTreeNode.keys], k#92#186) < Heap[this#185, AVLTreeNode.key]));
        }
        if (!(Heap[this#185, AVLTreeNode.right] == null)) {
          assert {:msg "  227.6: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#187: int :: (0 <= k#93#187) && (k#93#187 < Seq#Length(Heap[Heap[this#185, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#185, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#185, AVLTreeNode.right], AVLTreeNode.keys], k#93#187)));
        }
        assert {:msg "  227.6: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#185, AVLTreeNode.left] == null, 0, Heap[Heap[this#185, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#185, AVLTreeNode.right] == null, 0, Heap[Heap[this#185, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
        assert {:msg "  227.6: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#185, AVLTreeNode.left] == null, 0, Heap[Heap[this#185, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#185, AVLTreeNode.right] == null, 0, Heap[Heap[this#185, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
        assert {:msg "  227.6: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  227.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_390[this#185, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_390[this#185, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_390[this#185, AVLTreeNode.key][perm$N]));
        exhaleMask#_390[this#185, AVLTreeNode.key] := exhaleMask#_390[this#185, AVLTreeNode.key][perm$R := exhaleMask#_390[this#185, AVLTreeNode.key][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_390);
        assume wf(Heap, exhaleMask#_390, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  227.6: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  227.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_390[this#185, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_390[this#185, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_390[this#185, AVLTreeNode.height][perm$N]));
        exhaleMask#_390[this#185, AVLTreeNode.height] := exhaleMask#_390[this#185, AVLTreeNode.height][perm$R := exhaleMask#_390[this#185, AVLTreeNode.height][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_390);
        assume wf(Heap, exhaleMask#_390, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  227.6: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  227.6: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_390[this#185, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_390[this#185, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_390[this#185, AVLTreeNode.left][perm$N]));
        exhaleMask#_390[this#185, AVLTreeNode.left] := exhaleMask#_390[this#185, AVLTreeNode.left][perm$R := exhaleMask#_390[this#185, AVLTreeNode.left][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_390);
        assume wf(Heap, exhaleMask#_390, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  227.6: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  227.6: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_390[this#185, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_390[this#185, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_390[this#185, AVLTreeNode.right][perm$N]));
        exhaleMask#_390[this#185, AVLTreeNode.right] := exhaleMask#_390[this#185, AVLTreeNode.right][perm$R := exhaleMask#_390[this#185, AVLTreeNode.right][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_390);
        assume wf(Heap, exhaleMask#_390, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  227.6: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  227.6: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_390[this#185, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_390[this#185, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_390[this#185, AVLTreeNode.keys][perm$N]));
        exhaleMask#_390[this#185, AVLTreeNode.keys] := exhaleMask#_390[this#185, AVLTreeNode.keys][perm$R := exhaleMask#_390[this#185, AVLTreeNode.keys][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_390);
        assume wf(Heap, exhaleMask#_390, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  227.6: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  227.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_390[this#185, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_390[this#185, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_390[this#185, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_390[this#185, AVLTreeNode.balanceFactor] := exhaleMask#_390[this#185, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_390[this#185, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_390);
        assume wf(Heap, exhaleMask#_390, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#185, AVLTreeNode.left] == null)) {
          assert {:msg "  227.6: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
          assert {:msg "  227.6: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_390, SecMask, Heap[this#185, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#185, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_389[Heap[this#185, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_390);
          assume wf(Heap, exhaleMask#_390, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#185, AVLTreeNode.left] == null)) {
          assert {:msg "  227.6: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
          assert {:msg "  227.6: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_390);
          assume wf(Heap, exhaleMask#_390, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#185, AVLTreeNode.left] == null)) {
          assert {:msg "  227.6: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
          assert {:msg "  227.6: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_390);
          assume wf(Heap, exhaleMask#_390, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#185, AVLTreeNode.left] == null)) {
          assert {:msg "  227.6: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
          assert {:msg "  227.6: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_390[Heap[this#185, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_390);
          assume wf(Heap, exhaleMask#_390, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#185, AVLTreeNode.right] == null)) {
          assert {:msg "  227.6: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
          assert {:msg "  227.6: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_390, SecMask, Heap[this#185, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#185, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_389[Heap[this#185, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_390);
          assume wf(Heap, exhaleMask#_390, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#185, AVLTreeNode.right] == null)) {
          assert {:msg "  227.6: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  227.6: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_390);
          assume wf(Heap, exhaleMask#_390, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#185, AVLTreeNode.right] == null)) {
          assert {:msg "  227.6: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  227.6: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_390);
          assume wf(Heap, exhaleMask#_390, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#185, AVLTreeNode.right] == null)) {
          assert {:msg "  227.6: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  227.6: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_390[Heap[this#185, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_390);
          assume wf(Heap, exhaleMask#_390, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_390;
        assume IsGoodExhaleState(exhaleHeap#_389, Heap, Mask, SecMask);
        Heap := exhaleHeap#_389;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        // inhale (postcondition)
        assume this#185 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[this#185, AVLTreeNode.valid] := Mask[this#185, AVLTreeNode.valid][perm$R := Mask[this#185, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#185, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#185 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#185, AVLTreeNode.height] := Mask[this#185, AVLTreeNode.height][perm$R := Mask[this#185, AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#185, AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#185 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#185, AVLTreeNode.keys] := Mask[this#185, AVLTreeNode.keys][perm$R := Mask[this#185, AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#185, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#185 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#185, AVLTreeNode.balanceFactor] := Mask[this#185, AVLTreeNode.balanceFactor][perm$R := Mask[this#185, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#185, AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Seq#Equal(Heap[this#185, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_384[this#185, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_384[callHeap#_384[this#185, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_384[this#185, AVLTreeNode.key])), ite(callHeap#_384[this#185, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_384[callHeap#_384[this#185, AVLTreeNode.right], AVLTreeNode.keys])));
        assume Heap[this#185, AVLTreeNode.height] == ite(ite(callHeap#_384[this#185, AVLTreeNode.left] == null, 0, callHeap#_384[callHeap#_384[this#185, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_384[this#185, AVLTreeNode.right] == null, 0, callHeap#_384[callHeap#_384[this#185, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_384[this#185, AVLTreeNode.left] == null, 0, callHeap#_384[callHeap#_384[this#185, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_384[this#185, AVLTreeNode.right] == null, 0, callHeap#_384[callHeap#_384[this#185, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume Heap[this#185, AVLTreeNode.balanceFactor] == (ite(callHeap#_384[this#185, AVLTreeNode.left] == null, 0, callHeap#_384[callHeap#_384[this#185, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_384[this#185, AVLTreeNode.right] == null, 0, callHeap#_384[callHeap#_384[this#185, AVLTreeNode.right], AVLTreeNode.height]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
      }
    } else {
      // local var nr
      // if
      cond#_407 := Heap[this, AVLTreeNode.right] == null;
      assert {:msg "  231.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  231.9: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
      if (cond#_407) {
        // assigment to nr
        // new
        havoc nw#_408;
        assume (nw#_408 != null) && (dtype(nw#_408) == AVLTreeNode#t);
        assume (forall<T#_2> f: Field (T#_2) :: (Mask[nw#_408, f][perm$R] == 0) && (Mask[nw#_408, f][perm$N] == 0));
        assume Heap[nw#_408, mu] == $LockBottom;
        assume Heap[nw#_408, held] <= 0;
        assume Heap[nw#_408, rdheld] == false;
        Mask[nw#_408, AVLTreeNode.key] := Mask[nw#_408, AVLTreeNode.key][perm$R := Mask[nw#_408, AVLTreeNode.key][perm$R] + Fractions(100)];
        Mask[nw#_408, AVLTreeNode.height] := Mask[nw#_408, AVLTreeNode.height][perm$R := Mask[nw#_408, AVLTreeNode.height][perm$R] + Fractions(100)];
        Mask[nw#_408, AVLTreeNode.left] := Mask[nw#_408, AVLTreeNode.left][perm$R := Mask[nw#_408, AVLTreeNode.left][perm$R] + Fractions(100)];
        Mask[nw#_408, AVLTreeNode.right] := Mask[nw#_408, AVLTreeNode.right][perm$R := Mask[nw#_408, AVLTreeNode.right][perm$R] + Fractions(100)];
        Mask[nw#_408, AVLTreeNode.keys] := Mask[nw#_408, AVLTreeNode.keys][perm$R := Mask[nw#_408, AVLTreeNode.keys][perm$R] + Fractions(100)];
        Mask[nw#_408, AVLTreeNode.balanceFactor] := Mask[nw#_408, AVLTreeNode.balanceFactor][perm$R := Mask[nw#_408, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
        Mask[nw#_408, mu] := Mask[nw#_408, mu][perm$R := Mask[nw#_408, mu][perm$R] + Fractions(100)];
        nr#16 := nw#_408;
        assume (0 < methodCallK#_413) && ((1000 * methodCallK#_413) < Fractions(1)) && ((1000 * methodCallK#_413) < methodK#_261);
        // call init
        callHeap#_409 := Heap;
        callMask#_410 := Mask;
        callSecMask#_411 := SecMask;
        callCredits#_412 := Credits;
        assume wf(callHeap#_409, callMask#_410, callSecMask#_411);
        assert {:msg "  233.6: The target of the method call might be null."} nr#16 != null;
        this#190 := nr#16;
        k#191 := k#9;
        // begin exhale (precondition)
        exhaleMask#_415 := Mask;
        havoc exhaleHeap#_414;
        assert {:msg "  233.6: The precondition at 155.12 might not hold. The permission at 155.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  233.6: The precondition at 155.12 might not hold. Insufficient fraction at 155.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_415[this#190, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_415[this#190, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_415[this#190, AVLTreeNode.key][perm$N]));
        exhaleMask#_415[this#190, AVLTreeNode.key] := exhaleMask#_415[this#190, AVLTreeNode.key][perm$R := exhaleMask#_415[this#190, AVLTreeNode.key][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_415);
        assume wf(Heap, exhaleMask#_415, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  233.6: The precondition at 156.12 might not hold. The permission at 156.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  233.6: The precondition at 156.12 might not hold. Insufficient fraction at 156.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_415[this#190, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_415[this#190, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_415[this#190, AVLTreeNode.height][perm$N]));
        exhaleMask#_415[this#190, AVLTreeNode.height] := exhaleMask#_415[this#190, AVLTreeNode.height][perm$R := exhaleMask#_415[this#190, AVLTreeNode.height][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_415);
        assume wf(Heap, exhaleMask#_415, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  233.6: The precondition at 157.12 might not hold. The permission at 157.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  233.6: The precondition at 157.12 might not hold. Insufficient fraction at 157.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_415[this#190, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_415[this#190, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_415[this#190, AVLTreeNode.left][perm$N]));
        exhaleMask#_415[this#190, AVLTreeNode.left] := exhaleMask#_415[this#190, AVLTreeNode.left][perm$R := exhaleMask#_415[this#190, AVLTreeNode.left][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_415);
        assume wf(Heap, exhaleMask#_415, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  233.6: The precondition at 158.12 might not hold. The permission at 158.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  233.6: The precondition at 158.12 might not hold. Insufficient fraction at 158.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_415[this#190, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_415[this#190, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_415[this#190, AVLTreeNode.right][perm$N]));
        exhaleMask#_415[this#190, AVLTreeNode.right] := exhaleMask#_415[this#190, AVLTreeNode.right][perm$R := exhaleMask#_415[this#190, AVLTreeNode.right][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_415);
        assume wf(Heap, exhaleMask#_415, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  233.6: The precondition at 160.12 might not hold. The permission at 160.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  233.6: The precondition at 160.12 might not hold. Insufficient fraction at 160.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_415[this#190, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_415[this#190, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_415[this#190, AVLTreeNode.keys][perm$N]));
        exhaleMask#_415[this#190, AVLTreeNode.keys] := exhaleMask#_415[this#190, AVLTreeNode.keys][perm$R := exhaleMask#_415[this#190, AVLTreeNode.keys][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_415);
        assume wf(Heap, exhaleMask#_415, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  233.6: The precondition at 161.12 might not hold. The permission at 161.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  233.6: The precondition at 161.12 might not hold. Insufficient fraction at 161.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_415[this#190, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_415[this#190, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_415[this#190, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_415[this#190, AVLTreeNode.balanceFactor] := exhaleMask#_415[this#190, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_415[this#190, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_415);
        assume wf(Heap, exhaleMask#_415, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_415;
        assume IsGoodExhaleState(exhaleHeap#_414, Heap, Mask, SecMask);
        Heap := exhaleHeap#_414;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        // inhale (postcondition)
        assume this#190 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[this#190, AVLTreeNode.valid] := Mask[this#190, AVLTreeNode.valid][perm$R := Mask[this#190, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#190, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#190 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#190, AVLTreeNode.keys] := Mask[this#190, AVLTreeNode.keys][perm$R := Mask[this#190, AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#190, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#190 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#190, AVLTreeNode.height] := Mask[this#190, AVLTreeNode.height][perm$R := Mask[this#190, AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#190, AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#190 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#190, AVLTreeNode.balanceFactor] := Mask[this#190, AVLTreeNode.balanceFactor][perm$R := Mask[this#190, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#190, AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Heap[this#190, AVLTreeNode.height] == 1;
        assume Seq#Equal(Heap[this#190, AVLTreeNode.keys], Seq#Singleton(k#191));
        assume Heap[this#190, AVLTreeNode.balanceFactor] == 0;
        assume Seq#Contains(Heap[this#190, AVLTreeNode.keys], k#191);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
      } else {
        assume (0 < methodCallK#_428) && ((1000 * methodCallK#_428) < Fractions(1)) && ((1000 * methodCallK#_428) < methodK#_261);
        // call insert
        callHeap#_424 := Heap;
        callMask#_425 := Mask;
        callSecMask#_426 := SecMask;
        callCredits#_427 := Credits;
        assume wf(callHeap#_424, callMask#_425, callSecMask#_426);
        assert {:msg "  235.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  235.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
        assert {:msg "  235.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#192 := Heap[this, AVLTreeNode.right];
        k#193 := k#9;
        // begin exhale (precondition)
        exhaleMask#_430 := Mask;
        havoc exhaleHeap#_429;
        assert {:msg "  235.6: The precondition at 185.12 might not hold. The permission at 185.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  235.6: The precondition at 185.12 might not hold. Insufficient fraction at 185.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_430[this#192, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_430[this#192, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_430[this#192, AVLTreeNode.valid][perm$N]));
        exhaleMask#_430[this#192, AVLTreeNode.valid] := exhaleMask#_430[this#192, AVLTreeNode.valid][perm$R := exhaleMask#_430[this#192, AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_430, SecMask, this#192, AVLTreeNode.valid)) {
          assume Heap[this#192, AVLTreeNode.valid] < exhaleHeap#_429[this#192, AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_430);
        assume wf(Heap, exhaleMask#_430, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  235.6: The precondition at 186.12 might not hold. The permission at 186.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  235.6: The precondition at 186.12 might not hold. Insufficient fraction at 186.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_430[this#192, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_430[this#192, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_430[this#192, AVLTreeNode.keys][perm$N]));
        exhaleMask#_430[this#192, AVLTreeNode.keys] := exhaleMask#_430[this#192, AVLTreeNode.keys][perm$R := exhaleMask#_430[this#192, AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_430);
        assume wf(Heap, exhaleMask#_430, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  235.6: The precondition at 187.12 might not hold. The permission at 187.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  235.6: The precondition at 187.12 might not hold. Insufficient fraction at 187.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_430[this#192, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_430[this#192, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_430[this#192, AVLTreeNode.height][perm$N]));
        exhaleMask#_430[this#192, AVLTreeNode.height] := exhaleMask#_430[this#192, AVLTreeNode.height][perm$R := exhaleMask#_430[this#192, AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_430);
        assume wf(Heap, exhaleMask#_430, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  235.6: The precondition at 188.12 might not hold. The permission at 188.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  235.6: The precondition at 188.12 might not hold. Insufficient fraction at 188.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_430[this#192, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_430[this#192, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_430[this#192, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_430[this#192, AVLTreeNode.balanceFactor] := exhaleMask#_430[this#192, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_430[this#192, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_430);
        assume wf(Heap, exhaleMask#_430, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_430;
        assume IsGoodExhaleState(exhaleHeap#_429, Heap, Mask, SecMask);
        Heap := exhaleHeap#_429;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#194;
        // inhale (postcondition)
        assume !(r#194 == null);
        assume r#194 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[r#194, AVLTreeNode.valid] := Mask[r#194, AVLTreeNode.valid][perm$R := Mask[r#194, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#194, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#194 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[r#194, AVLTreeNode.keys] := Mask[r#194, AVLTreeNode.keys][perm$R := Mask[r#194, AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#194, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#194 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[r#194, AVLTreeNode.height] := Mask[r#194, AVLTreeNode.height][perm$R := Mask[r#194, AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#194, AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#194 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[r#194, AVLTreeNode.balanceFactor] := Mask[r#194, AVLTreeNode.balanceFactor][perm$R := Mask[r#194, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#194, AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Seq#Contains(Heap[r#194, AVLTreeNode.keys], k#193);
        assume (forall i#82#195: int :: (0 <= i#82#195) && (i#82#195 < Seq#Length(callHeap#_424[this#192, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#194, AVLTreeNode.keys], Seq#Index(callHeap#_424[this#192, AVLTreeNode.keys], i#82#195)));
        assume (forall i#83#196: int :: (0 <= i#83#196) && (i#83#196 < Seq#Length(Heap[r#194, AVLTreeNode.keys])) ==> (Seq#Contains(callHeap#_424[this#192, AVLTreeNode.keys], Seq#Index(Heap[r#194, AVLTreeNode.keys], i#83#196)) || (Seq#Index(Heap[r#194, AVLTreeNode.keys], i#83#196) == k#193)));
        if (Seq#Contains(callHeap#_424[this#192, AVLTreeNode.keys], k#193)) {
          assume Seq#Equal(Heap[r#194, AVLTreeNode.keys], callHeap#_424[this#192, AVLTreeNode.keys]);
        }
        if (!Seq#Contains(callHeap#_424[this#192, AVLTreeNode.keys], k#193)) {
          assume Seq#Length(Heap[r#194, AVLTreeNode.keys]) == (Seq#Length(callHeap#_424[this#192, AVLTreeNode.keys]) + 1);
        }
        assume (Heap[r#194, AVLTreeNode.height] == callHeap#_424[this#192, AVLTreeNode.height]) || (Heap[r#194, AVLTreeNode.height] == (callHeap#_424[this#192, AVLTreeNode.height] + 1));
        if (Seq#Contains(callHeap#_424[this#192, AVLTreeNode.keys], k#193)) {
          assume Heap[r#194, AVLTreeNode.height] == callHeap#_424[this#192, AVLTreeNode.height];
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        nr#16 := r#194;
      }
      // update field right
      assert {:msg "  237.5: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
      Heap[this, AVLTreeNode.right] := nr#16;
      assume wf(Heap, Mask, SecMask);
      // local var bf
      assume (0 < methodCallK#_441) && ((1000 * methodCallK#_441) < Fractions(1)) && ((1000 * methodCallK#_441) < methodK#_261);
      // call getBalanceFactorI
      callHeap#_437 := Heap;
      callMask#_438 := Mask;
      callSecMask#_439 := SecMask;
      callCredits#_440 := Credits;
      assume wf(callHeap#_437, callMask#_438, callSecMask#_439);
      assert {:msg "  240.5: The target of the method call might be null."} this != null;
      this#197 := this;
      // begin exhale (precondition)
      exhaleMask#_443 := Mask;
      havoc exhaleHeap#_442;
      assert {:msg "  240.5: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_441 > 0;
      assert {:msg "  240.5: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_443[this#197, AVLTreeNode.left][perm$R] > 0;
      assume methodCallK#_441 < exhaleMask#_443[this#197, AVLTreeNode.left][perm$R];
      exhaleMask#_443[this#197, AVLTreeNode.left] := exhaleMask#_443[this#197, AVLTreeNode.left][perm$R := exhaleMask#_443[this#197, AVLTreeNode.left][perm$R] - methodCallK#_441];
      assume IsGoodMask(exhaleMask#_443);
      assume wf(Heap, exhaleMask#_443, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#197, AVLTreeNode.left] == null)) {
        assert {:msg "  240.5: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_441 > 0;
        assert {:msg "  240.5: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_443[Heap[this#197, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0;
        assume methodCallK#_441 < exhaleMask#_443[Heap[this#197, AVLTreeNode.left], AVLTreeNode.height][perm$R];
        exhaleMask#_443[Heap[this#197, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_443[Heap[this#197, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_443[Heap[this#197, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_441];
        assume IsGoodMask(exhaleMask#_443);
        assume wf(Heap, exhaleMask#_443, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assert {:msg "  240.5: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_441 > 0;
      assert {:msg "  240.5: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_443[this#197, AVLTreeNode.right][perm$R] > 0;
      assume methodCallK#_441 < exhaleMask#_443[this#197, AVLTreeNode.right][perm$R];
      exhaleMask#_443[this#197, AVLTreeNode.right] := exhaleMask#_443[this#197, AVLTreeNode.right][perm$R := exhaleMask#_443[this#197, AVLTreeNode.right][perm$R] - methodCallK#_441];
      assume IsGoodMask(exhaleMask#_443);
      assume wf(Heap, exhaleMask#_443, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#197, AVLTreeNode.right] == null)) {
        assert {:msg "  240.5: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_441 > 0;
        assert {:msg "  240.5: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_443[Heap[this#197, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0;
        assume methodCallK#_441 < exhaleMask#_443[Heap[this#197, AVLTreeNode.right], AVLTreeNode.height][perm$R];
        exhaleMask#_443[Heap[this#197, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_443[Heap[this#197, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_443[Heap[this#197, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_441];
        assume IsGoodMask(exhaleMask#_443);
        assume wf(Heap, exhaleMask#_443, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#197, AVLTreeNode.left] == null)) {
        assert {:msg "  240.5: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} Fractions(100) > 0;
        assert {:msg "  240.5: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_443[Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_443[Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_443[Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_443[Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_443[Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_443[Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_443, SecMask, Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_442[Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_443);
        assume wf(Heap, exhaleMask#_443, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#197, AVLTreeNode.right] == null)) {
        assert {:msg "  240.5: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} Fractions(100) > 0;
        assert {:msg "  240.5: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_443[Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_443[Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_443[Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_443[Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_443[Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_443[Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_443, SecMask, Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_442[Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_443);
        assume wf(Heap, exhaleMask#_443, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_443;
      assume IsGoodExhaleState(exhaleHeap#_442, Heap, Mask, SecMask);
      Heap := exhaleHeap#_442;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      havoc bf#198;
      // inhale (postcondition)
      assume this#197 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[this#197, AVLTreeNode.left] == null) || (dtype(Heap[this#197, AVLTreeNode.left]) == AVLTreeNode#t);
      assume methodCallK#_441 > 0;
      Mask[this#197, AVLTreeNode.left] := Mask[this#197, AVLTreeNode.left][perm$R := Mask[this#197, AVLTreeNode.left][perm$R] + methodCallK#_441];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#197, AVLTreeNode.left]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#197, AVLTreeNode.left] == null)) {
        assume Heap[this#197, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[this#197, AVLTreeNode.left], AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#197, AVLTreeNode.left] == null)) {
        assume Heap[this#197, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_441 > 0;
        Mask[Heap[this#197, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#197, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#197, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_441];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[this#197, AVLTreeNode.left], AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume this#197 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[this#197, AVLTreeNode.right] == null) || (dtype(Heap[this#197, AVLTreeNode.right]) == AVLTreeNode#t);
      assume methodCallK#_441 > 0;
      Mask[this#197, AVLTreeNode.right] := Mask[this#197, AVLTreeNode.right][perm$R := Mask[this#197, AVLTreeNode.right][perm$R] + methodCallK#_441];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#197, AVLTreeNode.right]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#197, AVLTreeNode.right] == null)) {
        assume Heap[this#197, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[this#197, AVLTreeNode.right], AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#197, AVLTreeNode.right] == null)) {
        assume Heap[this#197, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_441 > 0;
        Mask[Heap[this#197, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#197, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#197, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_441];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[this#197, AVLTreeNode.right], AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume bf#198 == (ite(Heap[this#197, AVLTreeNode.left] == null, 0, Heap[Heap[this#197, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#197, AVLTreeNode.right] == null, 0, Heap[Heap[this#197, AVLTreeNode.right], AVLTreeNode.height]));
      if (bf#198 > 0) {
        assume !(Heap[this#197, AVLTreeNode.left] == null);
      }
      if (bf#198 < 0) {
        assume !(Heap[this#197, AVLTreeNode.right] == null);
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      bf#18 := bf#198;
      // if
      cond#_452 := bf#18 == (0 - 2);
      if (cond#_452) {
        assume (0 < methodCallK#_457) && ((1000 * methodCallK#_457) < Fractions(1)) && ((1000 * methodCallK#_457) < methodK#_261);
        // call rebalanceRight
        callHeap#_453 := Heap;
        callMask#_454 := Mask;
        callSecMask#_455 := SecMask;
        callCredits#_456 := Credits;
        assume wf(callHeap#_453, callMask#_454, callSecMask#_455);
        assert {:msg "  242.6: The target of the method call might be null."} this != null;
        this#199 := this;
        // begin exhale (precondition)
        exhaleMask#_459 := Mask;
        havoc exhaleHeap#_458;
        if (!(Heap[this#199, AVLTreeNode.left] == null)) {
          assert {:msg "  242.6: The precondition at 758.12 might not hold. The expression at 758.25 might not evaluate to true."} (forall k#104#201: int :: (0 <= k#104#201) && (k#104#201 < Seq#Length(Heap[Heap[this#199, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#199, AVLTreeNode.left], AVLTreeNode.keys], k#104#201) < Heap[this#199, AVLTreeNode.key]));
        }
        assert {:msg "  242.6: The precondition at 760.12 might not hold. The expression at 760.12 might not evaluate to true."} !(Heap[this#199, AVLTreeNode.right] == null);
        assert {:msg "  242.6: The precondition at 765.12 might not hold. The expression at 765.12 might not evaluate to true."} (forall k#105#202: int :: (0 <= k#105#202) && (k#105#202 < Seq#Length(Heap[Heap[this#199, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#199, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#199, AVLTreeNode.right], AVLTreeNode.keys], k#105#202)));
        assert {:msg "  242.6: The precondition at 768.12 might not hold. The expression at 768.12 might not evaluate to true."} (ite(Heap[this#199, AVLTreeNode.left] == null, 0, Heap[Heap[this#199, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#199, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
        assert {:msg "  242.6: The precondition at 746.12 might not hold. The permission at 746.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  242.6: The precondition at 746.12 might not hold. Insufficient fraction at 746.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_459[this#199, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_459[this#199, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_459[this#199, AVLTreeNode.key][perm$N]));
        exhaleMask#_459[this#199, AVLTreeNode.key] := exhaleMask#_459[this#199, AVLTreeNode.key][perm$R := exhaleMask#_459[this#199, AVLTreeNode.key][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_459);
        assume wf(Heap, exhaleMask#_459, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 747.12 might not hold. The permission at 747.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  242.6: The precondition at 747.12 might not hold. Insufficient fraction at 747.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_459[this#199, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_459[this#199, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_459[this#199, AVLTreeNode.height][perm$N]));
        exhaleMask#_459[this#199, AVLTreeNode.height] := exhaleMask#_459[this#199, AVLTreeNode.height][perm$R := exhaleMask#_459[this#199, AVLTreeNode.height][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_459);
        assume wf(Heap, exhaleMask#_459, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 748.12 might not hold. The permission at 748.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  242.6: The precondition at 748.12 might not hold. Insufficient fraction at 748.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_459[this#199, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_459[this#199, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_459[this#199, AVLTreeNode.left][perm$N]));
        exhaleMask#_459[this#199, AVLTreeNode.left] := exhaleMask#_459[this#199, AVLTreeNode.left][perm$R := exhaleMask#_459[this#199, AVLTreeNode.left][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_459);
        assume wf(Heap, exhaleMask#_459, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 749.12 might not hold. The permission at 749.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  242.6: The precondition at 749.12 might not hold. Insufficient fraction at 749.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_459[this#199, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_459[this#199, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_459[this#199, AVLTreeNode.right][perm$N]));
        exhaleMask#_459[this#199, AVLTreeNode.right] := exhaleMask#_459[this#199, AVLTreeNode.right][perm$R := exhaleMask#_459[this#199, AVLTreeNode.right][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_459);
        assume wf(Heap, exhaleMask#_459, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 751.12 might not hold. The permission at 751.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  242.6: The precondition at 751.12 might not hold. Insufficient fraction at 751.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_459[this#199, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_459[this#199, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_459[this#199, AVLTreeNode.keys][perm$N]));
        exhaleMask#_459[this#199, AVLTreeNode.keys] := exhaleMask#_459[this#199, AVLTreeNode.keys][perm$R := exhaleMask#_459[this#199, AVLTreeNode.keys][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_459);
        assume wf(Heap, exhaleMask#_459, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 752.12 might not hold. The permission at 752.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  242.6: The precondition at 752.12 might not hold. Insufficient fraction at 752.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_459[this#199, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_459[this#199, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_459[this#199, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_459[this#199, AVLTreeNode.balanceFactor] := exhaleMask#_459[this#199, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_459[this#199, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_459);
        assume wf(Heap, exhaleMask#_459, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#199, AVLTreeNode.left] == null)) {
          assert {:msg "  242.6: The precondition at 754.12 might not hold. The permission at 754.25 might not be positive."} Fractions(100) > 0;
          assert {:msg "  242.6: The precondition at 754.12 might not hold. Insufficient fraction at 754.25 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_459, SecMask, Heap[this#199, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#199, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_458[Heap[this#199, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_459);
          assume wf(Heap, exhaleMask#_459, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#199, AVLTreeNode.left] == null)) {
          assert {:msg "  242.6: The precondition at 755.12 might not hold. The permission at 755.25 might not be positive."} Fractions(50) > 0;
          assert {:msg "  242.6: The precondition at 755.12 might not hold. Insufficient fraction at 755.25 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_459);
          assume wf(Heap, exhaleMask#_459, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#199, AVLTreeNode.left] == null)) {
          assert {:msg "  242.6: The precondition at 756.12 might not hold. The permission at 756.25 might not be positive."} Fractions(50) > 0;
          assert {:msg "  242.6: The precondition at 756.12 might not hold. Insufficient fraction at 756.25 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_459);
          assume wf(Heap, exhaleMask#_459, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#199, AVLTreeNode.left] == null)) {
          assert {:msg "  242.6: The precondition at 757.12 might not hold. The permission at 757.25 might not be positive."} Fractions(50) > 0;
          assert {:msg "  242.6: The precondition at 757.12 might not hold. Insufficient fraction at 757.25 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_459[Heap[this#199, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_459);
          assume wf(Heap, exhaleMask#_459, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assert {:msg "  242.6: The precondition at 761.12 might not hold. The permission at 761.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  242.6: The precondition at 761.12 might not hold. Insufficient fraction at 761.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_459, SecMask, Heap[this#199, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#199, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_458[Heap[this#199, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_459);
        assume wf(Heap, exhaleMask#_459, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 762.12 might not hold. The permission at 762.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  242.6: The precondition at 762.12 might not hold. Insufficient fraction at 762.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_459);
        assume wf(Heap, exhaleMask#_459, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 763.12 might not hold. The permission at 763.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  242.6: The precondition at 763.12 might not hold. Insufficient fraction at 763.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_459);
        assume wf(Heap, exhaleMask#_459, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 764.12 might not hold. The permission at 764.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  242.6: The precondition at 764.12 might not hold. Insufficient fraction at 764.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_459[Heap[this#199, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_459);
        assume wf(Heap, exhaleMask#_459, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_459;
        assume IsGoodExhaleState(exhaleHeap#_458, Heap, Mask, SecMask);
        Heap := exhaleHeap#_458;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#200;
        // inhale (postcondition)
        assume !(r#200 == null);
        assume r#200 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[r#200, AVLTreeNode.valid] := Mask[r#200, AVLTreeNode.valid][perm$R := Mask[r#200, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#200, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#200 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[r#200, AVLTreeNode.height] := Mask[r#200, AVLTreeNode.height][perm$R := Mask[r#200, AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#200, AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#200 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[r#200, AVLTreeNode.keys] := Mask[r#200, AVLTreeNode.keys][perm$R := Mask[r#200, AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#200, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#200 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[r#200, AVLTreeNode.balanceFactor] := Mask[r#200, AVLTreeNode.balanceFactor][perm$R := Mask[r#200, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[r#200, AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume (Heap[r#200, AVLTreeNode.height] == callHeap#_453[callHeap#_453[this#199, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#200, AVLTreeNode.height] == (callHeap#_453[callHeap#_453[this#199, AVLTreeNode.right], AVLTreeNode.height] + 1));
        assume Seq#Equal(Heap[r#200, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_453[this#199, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_453[callHeap#_453[this#199, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_453[this#199, AVLTreeNode.key])), callHeap#_453[callHeap#_453[this#199, AVLTreeNode.right], AVLTreeNode.keys]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        r#10 := r#200;
      } else {
        // assigment to r
        r#10 := this;
        assume (0 < methodCallK#_480) && ((1000 * methodCallK#_480) < Fractions(1)) && ((1000 * methodCallK#_480) < methodK#_261);
        // call close
        callHeap#_476 := Heap;
        callMask#_477 := Mask;
        callSecMask#_478 := SecMask;
        callCredits#_479 := Credits;
        assume wf(callHeap#_476, callMask#_477, callSecMask#_478);
        assert {:msg "  245.6: The target of the method call might be null."} r#10 != null;
        this#205 := r#10;
        // begin exhale (precondition)
        exhaleMask#_482 := Mask;
        havoc exhaleHeap#_481;
        if (!(Heap[this#205, AVLTreeNode.left] == null)) {
          assert {:msg "  245.6: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#206: int :: (0 <= k#92#206) && (k#92#206 < Seq#Length(Heap[Heap[this#205, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#205, AVLTreeNode.left], AVLTreeNode.keys], k#92#206) < Heap[this#205, AVLTreeNode.key]));
        }
        if (!(Heap[this#205, AVLTreeNode.right] == null)) {
          assert {:msg "  245.6: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#207: int :: (0 <= k#93#207) && (k#93#207 < Seq#Length(Heap[Heap[this#205, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#205, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#205, AVLTreeNode.right], AVLTreeNode.keys], k#93#207)));
        }
        assert {:msg "  245.6: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#205, AVLTreeNode.left] == null, 0, Heap[Heap[this#205, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#205, AVLTreeNode.right] == null, 0, Heap[Heap[this#205, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
        assert {:msg "  245.6: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#205, AVLTreeNode.left] == null, 0, Heap[Heap[this#205, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#205, AVLTreeNode.right] == null, 0, Heap[Heap[this#205, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
        assert {:msg "  245.6: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  245.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_482[this#205, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_482[this#205, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_482[this#205, AVLTreeNode.key][perm$N]));
        exhaleMask#_482[this#205, AVLTreeNode.key] := exhaleMask#_482[this#205, AVLTreeNode.key][perm$R := exhaleMask#_482[this#205, AVLTreeNode.key][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_482);
        assume wf(Heap, exhaleMask#_482, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  245.6: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  245.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_482[this#205, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_482[this#205, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_482[this#205, AVLTreeNode.height][perm$N]));
        exhaleMask#_482[this#205, AVLTreeNode.height] := exhaleMask#_482[this#205, AVLTreeNode.height][perm$R := exhaleMask#_482[this#205, AVLTreeNode.height][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_482);
        assume wf(Heap, exhaleMask#_482, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  245.6: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  245.6: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_482[this#205, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_482[this#205, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_482[this#205, AVLTreeNode.left][perm$N]));
        exhaleMask#_482[this#205, AVLTreeNode.left] := exhaleMask#_482[this#205, AVLTreeNode.left][perm$R := exhaleMask#_482[this#205, AVLTreeNode.left][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_482);
        assume wf(Heap, exhaleMask#_482, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  245.6: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  245.6: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_482[this#205, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_482[this#205, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_482[this#205, AVLTreeNode.right][perm$N]));
        exhaleMask#_482[this#205, AVLTreeNode.right] := exhaleMask#_482[this#205, AVLTreeNode.right][perm$R := exhaleMask#_482[this#205, AVLTreeNode.right][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_482);
        assume wf(Heap, exhaleMask#_482, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  245.6: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  245.6: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_482[this#205, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_482[this#205, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_482[this#205, AVLTreeNode.keys][perm$N]));
        exhaleMask#_482[this#205, AVLTreeNode.keys] := exhaleMask#_482[this#205, AVLTreeNode.keys][perm$R := exhaleMask#_482[this#205, AVLTreeNode.keys][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_482);
        assume wf(Heap, exhaleMask#_482, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  245.6: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  245.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_482[this#205, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_482[this#205, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_482[this#205, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_482[this#205, AVLTreeNode.balanceFactor] := exhaleMask#_482[this#205, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_482[this#205, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_482);
        assume wf(Heap, exhaleMask#_482, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#205, AVLTreeNode.left] == null)) {
          assert {:msg "  245.6: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
          assert {:msg "  245.6: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_482, SecMask, Heap[this#205, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#205, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_481[Heap[this#205, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_482);
          assume wf(Heap, exhaleMask#_482, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#205, AVLTreeNode.left] == null)) {
          assert {:msg "  245.6: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
          assert {:msg "  245.6: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_482);
          assume wf(Heap, exhaleMask#_482, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#205, AVLTreeNode.left] == null)) {
          assert {:msg "  245.6: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
          assert {:msg "  245.6: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_482);
          assume wf(Heap, exhaleMask#_482, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#205, AVLTreeNode.left] == null)) {
          assert {:msg "  245.6: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
          assert {:msg "  245.6: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_482[Heap[this#205, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_482);
          assume wf(Heap, exhaleMask#_482, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#205, AVLTreeNode.right] == null)) {
          assert {:msg "  245.6: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
          assert {:msg "  245.6: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_482, SecMask, Heap[this#205, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#205, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_481[Heap[this#205, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_482);
          assume wf(Heap, exhaleMask#_482, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#205, AVLTreeNode.right] == null)) {
          assert {:msg "  245.6: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  245.6: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_482);
          assume wf(Heap, exhaleMask#_482, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#205, AVLTreeNode.right] == null)) {
          assert {:msg "  245.6: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  245.6: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_482);
          assume wf(Heap, exhaleMask#_482, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#205, AVLTreeNode.right] == null)) {
          assert {:msg "  245.6: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  245.6: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_482[Heap[this#205, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_482);
          assume wf(Heap, exhaleMask#_482, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_482;
        assume IsGoodExhaleState(exhaleHeap#_481, Heap, Mask, SecMask);
        Heap := exhaleHeap#_481;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        // inhale (postcondition)
        assume this#205 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[this#205, AVLTreeNode.valid] := Mask[this#205, AVLTreeNode.valid][perm$R := Mask[this#205, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#205, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#205 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#205, AVLTreeNode.height] := Mask[this#205, AVLTreeNode.height][perm$R := Mask[this#205, AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#205, AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#205 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#205, AVLTreeNode.keys] := Mask[this#205, AVLTreeNode.keys][perm$R := Mask[this#205, AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#205, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#205 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#205, AVLTreeNode.balanceFactor] := Mask[this#205, AVLTreeNode.balanceFactor][perm$R := Mask[this#205, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#205, AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Seq#Equal(Heap[this#205, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_476[this#205, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_476[callHeap#_476[this#205, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_476[this#205, AVLTreeNode.key])), ite(callHeap#_476[this#205, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_476[callHeap#_476[this#205, AVLTreeNode.right], AVLTreeNode.keys])));
        assume Heap[this#205, AVLTreeNode.height] == ite(ite(callHeap#_476[this#205, AVLTreeNode.left] == null, 0, callHeap#_476[callHeap#_476[this#205, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_476[this#205, AVLTreeNode.right] == null, 0, callHeap#_476[callHeap#_476[this#205, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_476[this#205, AVLTreeNode.left] == null, 0, callHeap#_476[callHeap#_476[this#205, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_476[this#205, AVLTreeNode.right] == null, 0, callHeap#_476[callHeap#_476[this#205, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume Heap[this#205, AVLTreeNode.balanceFactor] == (ite(callHeap#_476[this#205, AVLTreeNode.left] == null, 0, callHeap#_476[callHeap#_476[this#205, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_476[this#205, AVLTreeNode.right] == null, 0, callHeap#_476[callHeap#_476[this#205, AVLTreeNode.right], AVLTreeNode.height]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
      }
    }
  }
  // begin exhale (postcondition)
  exhaleMask#_500 := Mask;
  havoc exhaleHeap#_499;
  assert {:msg "  184.2: The postcondition at 190.11 might not hold. The expression at 190.11 might not evaluate to true."} !(r#10 == null);
  assert {:msg "  184.2: The postcondition at 196.11 might not hold. The expression at 196.11 might not evaluate to true."} Seq#Contains(Heap[r#10, AVLTreeNode.keys], k#9);
  assert {:msg "  184.2: The postcondition at 197.11 might not hold. The expression at 197.11 might not evaluate to true."} (forall i#82#210: int :: (0 <= i#82#210) && (i#82#210 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#10, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#82#210)));
  assert {:msg "  184.2: The postcondition at 198.11 might not hold. The expression at 198.11 might not evaluate to true."} (forall i#83#211: int :: (0 <= i#83#211) && (i#83#211 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#211)) || (Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#211) == k#9)));
  if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  184.2: The postcondition at 199.11 might not hold. The expression at 199.30 might not evaluate to true."} Seq#Equal(Heap[r#10, AVLTreeNode.keys], old(Heap)[this, AVLTreeNode.keys]);
  }
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  184.2: The postcondition at 200.11 might not hold. The expression at 200.33 might not evaluate to true."} Seq#Length(Heap[r#10, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this, AVLTreeNode.keys]) + 1);
  }
  assert {:msg "  184.2: The postcondition at 202.11 might not hold. The expression at 202.11 might not evaluate to true."} (Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap[r#10, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] + 1));
  if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  184.2: The postcondition at 203.11 might not hold. The expression at 203.30 might not evaluate to true."} Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height];
  }
  assert {:msg "  184.2: The postcondition at 191.11 might not hold. The permission at 191.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  184.2: The postcondition at 191.11 might not hold. Insufficient fraction at 191.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_500[r#10, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_500[r#10, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_500[r#10, AVLTreeNode.valid][perm$N]));
  exhaleMask#_500[r#10, AVLTreeNode.valid] := exhaleMask#_500[r#10, AVLTreeNode.valid][perm$R := exhaleMask#_500[r#10, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (!CanRead(exhaleMask#_500, SecMask, r#10, AVLTreeNode.valid)) {
    assume Heap[r#10, AVLTreeNode.valid] < exhaleHeap#_499[r#10, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_500);
  assume wf(Heap, exhaleMask#_500, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  184.2: The postcondition at 192.11 might not hold. The permission at 192.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  184.2: The postcondition at 192.11 might not hold. Insufficient fraction at 192.11 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_500[r#10, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_500[r#10, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_500[r#10, AVLTreeNode.keys][perm$N]));
  exhaleMask#_500[r#10, AVLTreeNode.keys] := exhaleMask#_500[r#10, AVLTreeNode.keys][perm$R := exhaleMask#_500[r#10, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_500);
  assume wf(Heap, exhaleMask#_500, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  184.2: The postcondition at 193.11 might not hold. The permission at 193.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  184.2: The postcondition at 193.11 might not hold. Insufficient fraction at 193.11 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_500[r#10, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_500[r#10, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_500[r#10, AVLTreeNode.height][perm$N]));
  exhaleMask#_500[r#10, AVLTreeNode.height] := exhaleMask#_500[r#10, AVLTreeNode.height][perm$R := exhaleMask#_500[r#10, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_500);
  assume wf(Heap, exhaleMask#_500, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  184.2: The postcondition at 194.11 might not hold. The permission at 194.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  184.2: The postcondition at 194.11 might not hold. Insufficient fraction at 194.11 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_500[r#10, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_500[r#10, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_500[r#10, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_500[r#10, AVLTreeNode.balanceFactor] := exhaleMask#_500[r#10, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_500[r#10, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_500);
  assume wf(Heap, exhaleMask#_500, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_500;
  assume IsGoodExhaleState(exhaleHeap#_499, Heap, Mask, SecMask);
  Heap := exhaleHeap#_499;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  184.2: Method might lock/unlock more than allowed."} (forall lk#_505: ref :: {Heap[lk#_505, held]} {Heap[lk#_505, rdheld]} (((0 < Heap[lk#_505, held]) == (0 < old(Heap)[lk#_505, held])) && (Heap[lk#_505, rdheld] == old(Heap)[lk#_505, rdheld])) || false);
  assert {:msg "  184.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.remove$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#19: int where true) returns (r#20: ref where (r#20 == null) || (dtype(r#20) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_506: int;
  var i#84#215: int where true;
  var i#85#217: int where true;
  assume (0 < methodK#_506) && ((1000 * methodK#_506) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  254.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  259.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  259.15: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  if (Seq#Equal(old(Heap)[this, AVLTreeNode.keys], Seq#Singleton(k#19))) {
    assume r#20 == null;
  }
  assert {:msg "  260.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  260.15: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  if (!Seq#Equal(old(Heap)[this, AVLTreeNode.keys], Seq#Singleton(k#19))) {
    assume !(r#20 == null);
  }
  if (!(r#20 == null)) {
    assert {:msg "  262.25: Receiver might be null."} r#20 != null;
    assume r#20 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[r#20, AVLTreeNode.valid] := Mask[r#20, AVLTreeNode.valid][perm$R := Mask[r#20, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#20, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assume r#20 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#20, AVLTreeNode.keys] := Mask[r#20, AVLTreeNode.keys][perm$R := Mask[r#20, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#20, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assume r#20 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#20, AVLTreeNode.height] := Mask[r#20, AVLTreeNode.height][perm$R := Mask[r#20, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#20, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assume r#20 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#20, AVLTreeNode.balanceFactor] := Mask[r#20, AVLTreeNode.balanceFactor][perm$R := Mask[r#20, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#20, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assert {:msg "  267.32: Receiver might be null."} true ==> (r#20 != null);
    assert {:msg "  267.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#20, AVLTreeNode.keys);
    assume !Seq#Contains(Heap[r#20, AVLTreeNode.keys], k#19);
  }
  if (!(r#20 == null)) {
    assert {:msg "  268.11: Receiver might be null."} true && (0 <= i#84#215) ==> (this != null);
    assert {:msg "  268.11: Location might not be readable."} true && (0 <= i#84#215) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
    assert {:msg "  268.11: Receiver might be null."} true && (0 <= i#84#215) && (i#84#215 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  268.11: Location might not be readable."} true && (0 <= i#84#215) && (i#84#215 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
    assert {:msg "  268.52: Sequence index might be negative."} true && (0 <= i#84#215) && (i#84#215 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (0 <= i#84#215);
    assert {:msg "  268.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#84#215) && (i#84#215 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (i#84#215 < Seq#Length(old(Heap)[this, AVLTreeNode.keys]));
    assert {:msg "  268.59: Receiver might be null."} true && (0 <= i#84#215) && (i#84#215 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (r#20 != null);
    assert {:msg "  268.59: Location might not be readable."} true && (0 <= i#84#215) && (i#84#215 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, r#20, AVLTreeNode.keys);
    assert {:msg "  268.11: Receiver might be null."} true && (0 <= i#84#215) && (i#84#215 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) && (!Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#215))) ==> (this != null);
    assert {:msg "  268.11: Location might not be readable."} true && (0 <= i#84#215) && (i#84#215 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) && (!Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#215))) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
    assert {:msg "  268.52: Sequence index might be negative."} true && (0 <= i#84#215) && (i#84#215 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) && (!Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#215))) ==> (0 <= i#84#215);
    assert {:msg "  268.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#84#215) && (i#84#215 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) && (!Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#215))) ==> (i#84#215 < Seq#Length(old(Heap)[this, AVLTreeNode.keys]));
    assume (forall i#84#214: int :: (0 <= i#84#214) && (i#84#214 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#214)) || (Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#214) == k#19)));
  }
  if (!(r#20 == null)) {
    assert {:msg "  269.11: Receiver might be null."} true && (0 <= i#85#217) ==> (r#20 != null);
    assert {:msg "  269.11: Location might not be readable."} true && (0 <= i#85#217) ==> CanRead(Mask, SecMask, r#20, AVLTreeNode.keys);
    assert {:msg "  269.11: Receiver might be null."} true && (0 <= i#85#217) && (i#85#217 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> (r#20 != null);
    assert {:msg "  269.11: Location might not be readable."} true && (0 <= i#85#217) && (i#85#217 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, r#20, AVLTreeNode.keys);
    assert {:msg "  269.52: Sequence index might be negative."} true && (0 <= i#85#217) && (i#85#217 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> (0 <= i#85#217);
    assert {:msg "  269.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#85#217) && (i#85#217 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> (i#85#217 < Seq#Length(Heap[r#20, AVLTreeNode.keys]));
    assert {:msg "  269.61: Receiver might be null."} true && (0 <= i#85#217) && (i#85#217 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  269.61: Location might not be readable."} true && (0 <= i#85#217) && (i#85#217 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
    assert {:msg "  269.11: Receiver might be null."} true && (0 <= i#85#217) && (i#85#217 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) && Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#217)) ==> (r#20 != null);
    assert {:msg "  269.11: Location might not be readable."} true && (0 <= i#85#217) && (i#85#217 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) && Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#217)) ==> CanRead(Mask, SecMask, r#20, AVLTreeNode.keys);
    assert {:msg "  269.52: Sequence index might be negative."} true && (0 <= i#85#217) && (i#85#217 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) && Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#217)) ==> (0 <= i#85#217);
    assert {:msg "  269.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#85#217) && (i#85#217 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) && Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#217)) ==> (i#85#217 < Seq#Length(Heap[r#20, AVLTreeNode.keys]));
    assume (forall i#85#216: int :: (0 <= i#85#216) && (i#85#216 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#216)) && (!(Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#216) == k#19)));
  }
  assert {:msg "  270.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  270.22: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assume !(r#20 == null);
  }
  assert {:msg "  271.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  271.22: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assert {:msg "  271.34: Receiver might be null."} true ==> (r#20 != null);
    assert {:msg "  271.34: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#20, AVLTreeNode.keys);
    assert {:msg "  271.50: Receiver might be null."} true ==> (this != null);
    assert {:msg "  271.50: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
    assume Seq#Equal(Heap[r#20, AVLTreeNode.keys], old(Heap)[this, AVLTreeNode.keys]);
  }
  if (!(r#20 == null)) {
    assert {:msg "  272.34: Receiver might be null."} true ==> (this != null);
    assert {:msg "  272.34: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
    if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
      assert {:msg "  272.46: Receiver might be null."} true ==> (r#20 != null);
      assert {:msg "  272.46: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#20, AVLTreeNode.keys);
      assert {:msg "  272.62: Receiver might be null."} true ==> (this != null);
      assert {:msg "  272.62: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
      assume Seq#Length(Heap[r#20, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this, AVLTreeNode.keys]) - 1);
    }
  }
  assert {:msg "  274.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  274.15: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assume !(r#20 == null);
  }
  if (!(r#20 == null)) {
    assert {:msg "  275.25: Receiver might be null."} true ==> (r#20 != null);
    assert {:msg "  275.25: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#20, AVLTreeNode.height);
    assert {:msg "  275.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  275.39: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
    assert {:msg "  275.50: Receiver might be null."} true && (!(Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#20 != null);
    assert {:msg "  275.50: Location might not be readable."} true && (!(Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask, SecMask, r#20, AVLTreeNode.height);
    assert {:msg "  275.66: Receiver might be null."} true && (!(Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
    assert {:msg "  275.66: Location might not be readable."} true && (!(Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
    assume (Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || ((Heap[r#20, AVLTreeNode.height] + 1) == old(Heap)[this, AVLTreeNode.height]);
  }
  assert {:msg "  276.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  276.22: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assert {:msg "  276.33: Receiver might be null."} true ==> (r#20 != null);
    assert {:msg "  276.33: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#20, AVLTreeNode.height);
    assert {:msg "  276.47: Receiver might be null."} true ==> (this != null);
    assert {:msg "  276.47: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
    assume Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.remove(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#19: int where true) returns (r#20: ref where (r#20 == null) || (dtype(r#20) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_506: int;
  var unfoldK#_507: int;
  var oldVers#_527: int;
  var newVers#_528: int;
  var cond#_529: bool;
  var cond#_530: bool;
  var assertHeap#_531: HeapType;
  var assertMask#_532: MaskType;
  var assertSecMask#_533: MaskType;
  var assertCredits#_534: CreditsType;
  var exhaleMask#_536: MaskType;
  var exhaleHeap#_535: HeapType;
  var unfoldingK#_542: int;
  var predFlag#_541: bool;
  var unfoldingHeap#_537: HeapType;
  var unfoldingMask#_538: MaskType;
  var unfoldingSecMask#_539: MaskType;
  var unfoldingCredits#_540: CreditsType;
  var oldVers#_562: int;
  var newVers#_563: int;
  var assertHeap#_580: HeapType;
  var assertMask#_581: MaskType;
  var assertSecMask#_582: MaskType;
  var assertCredits#_583: CreditsType;
  var exhaleMask#_585: MaskType;
  var exhaleHeap#_584: HeapType;
  var unfoldingK#_591: int;
  var predFlag#_590: bool;
  var unfoldingHeap#_586: HeapType;
  var unfoldingMask#_587: MaskType;
  var unfoldingSecMask#_588: MaskType;
  var unfoldingCredits#_589: CreditsType;
  var oldVers#_611: int;
  var newVers#_612: int;
  var cond#_629: bool;
  var bf#22: int where true;
  var nl#24: ref where (nl#24 == null) || (dtype(nl#24) == AVLTreeNode#t);
  var nr#26: ref where (nr#26 == null) || (dtype(nr#26) == AVLTreeNode#t);
  var methodCallK#_634: int;
  var this#248: ref where (this#248 == null) || (dtype(this#248) == AVLTreeNode#t);
  var bf#249: int where true;
  var callHeap#_630: HeapType;
  var callMask#_631: MaskType;
  var callSecMask#_632: MaskType;
  var callCredits#_633: CreditsType;
  var exhaleMask#_636: MaskType;
  var exhaleHeap#_635: HeapType;
  var isHeld#_643: int;
  var isRdHeld#_644: bool;
  var cond#_645: bool;
  var methodCallK#_650: int;
  var this#250: ref where (this#250 == null) || (dtype(this#250) == AVLTreeNode#t);
  var r#251: ref where (r#251 == null) || (dtype(r#251) == AVLTreeNode#t);
  var m#252: ref where (m#252 == null) || (dtype(m#252) == AVLTreeNode#t);
  var callHeap#_646: HeapType;
  var callMask#_647: MaskType;
  var callSecMask#_648: MaskType;
  var callCredits#_649: CreditsType;
  var exhaleMask#_652: MaskType;
  var exhaleHeap#_651: HeapType;
  var isHeld#_657: int;
  var isRdHeld#_658: bool;
  var methodCallK#_663: int;
  var this#254: ref where (this#254 == null) || (dtype(this#254) == AVLTreeNode#t);
  var r#255: ref where (r#255 == null) || (dtype(r#255) == AVLTreeNode#t);
  var m#256: ref where (m#256 == null) || (dtype(m#256) == AVLTreeNode#t);
  var callHeap#_659: HeapType;
  var callMask#_660: MaskType;
  var callSecMask#_661: MaskType;
  var callCredits#_662: CreditsType;
  var exhaleMask#_665: MaskType;
  var exhaleHeap#_664: HeapType;
  var isHeld#_670: int;
  var isRdHeld#_671: bool;
  var unfoldK#_672: int;
  var oldVers#_692: int;
  var newVers#_693: int;
  var methodCallK#_698: int;
  var this#264: ref where (this#264 == null) || (dtype(this#264) == AVLTreeNode#t);
  var callHeap#_694: HeapType;
  var callMask#_695: MaskType;
  var callSecMask#_696: MaskType;
  var callCredits#_697: CreditsType;
  var exhaleMask#_700: MaskType;
  var exhaleHeap#_699: HeapType;
  var isHeld#_715: int;
  var isRdHeld#_716: bool;
  var cond#_717: bool;
  var cond#_718: bool;
  var nl#28: ref where (nl#28 == null) || (dtype(nl#28) == AVLTreeNode#t);
  var methodCallK#_723: int;
  var this#269: ref where (this#269 == null) || (dtype(this#269) == AVLTreeNode#t);
  var k#270: int where true;
  var r#271: ref where (r#271 == null) || (dtype(r#271) == AVLTreeNode#t);
  var callHeap#_719: HeapType;
  var callMask#_720: MaskType;
  var callSecMask#_721: MaskType;
  var callCredits#_722: CreditsType;
  var exhaleMask#_725: MaskType;
  var exhaleHeap#_724: HeapType;
  var isHeld#_730: int;
  var isRdHeld#_731: bool;
  var bf#30: int where true;
  var methodCallK#_736: int;
  var this#274: ref where (this#274 == null) || (dtype(this#274) == AVLTreeNode#t);
  var bf#275: int where true;
  var callHeap#_732: HeapType;
  var callMask#_733: MaskType;
  var callSecMask#_734: MaskType;
  var callCredits#_735: CreditsType;
  var exhaleMask#_738: MaskType;
  var exhaleHeap#_737: HeapType;
  var isHeld#_745: int;
  var isRdHeld#_746: bool;
  var cond#_747: bool;
  var methodCallK#_752: int;
  var this#276: ref where (this#276 == null) || (dtype(this#276) == AVLTreeNode#t);
  var r#277: ref where (r#277 == null) || (dtype(r#277) == AVLTreeNode#t);
  var callHeap#_748: HeapType;
  var callMask#_749: MaskType;
  var callSecMask#_750: MaskType;
  var callCredits#_751: CreditsType;
  var exhaleMask#_754: MaskType;
  var exhaleHeap#_753: HeapType;
  var isHeld#_769: int;
  var isRdHeld#_770: bool;
  var methodCallK#_775: int;
  var this#282: ref where (this#282 == null) || (dtype(this#282) == AVLTreeNode#t);
  var callHeap#_771: HeapType;
  var callMask#_772: MaskType;
  var callSecMask#_773: MaskType;
  var callCredits#_774: CreditsType;
  var exhaleMask#_777: MaskType;
  var exhaleHeap#_776: HeapType;
  var isHeld#_792: int;
  var isRdHeld#_793: bool;
  var methodCallK#_798: int;
  var this#287: ref where (this#287 == null) || (dtype(this#287) == AVLTreeNode#t);
  var callHeap#_794: HeapType;
  var callMask#_795: MaskType;
  var callSecMask#_796: MaskType;
  var callCredits#_797: CreditsType;
  var exhaleMask#_800: MaskType;
  var exhaleHeap#_799: HeapType;
  var isHeld#_815: int;
  var isRdHeld#_816: bool;
  var cond#_817: bool;
  var nr#32: ref where (nr#32 == null) || (dtype(nr#32) == AVLTreeNode#t);
  var methodCallK#_822: int;
  var this#292: ref where (this#292 == null) || (dtype(this#292) == AVLTreeNode#t);
  var k#293: int where true;
  var r#294: ref where (r#294 == null) || (dtype(r#294) == AVLTreeNode#t);
  var callHeap#_818: HeapType;
  var callMask#_819: MaskType;
  var callSecMask#_820: MaskType;
  var callCredits#_821: CreditsType;
  var exhaleMask#_824: MaskType;
  var exhaleHeap#_823: HeapType;
  var isHeld#_829: int;
  var isRdHeld#_830: bool;
  var bf#34: int where true;
  var methodCallK#_835: int;
  var this#297: ref where (this#297 == null) || (dtype(this#297) == AVLTreeNode#t);
  var bf#298: int where true;
  var callHeap#_831: HeapType;
  var callMask#_832: MaskType;
  var callSecMask#_833: MaskType;
  var callCredits#_834: CreditsType;
  var exhaleMask#_837: MaskType;
  var exhaleHeap#_836: HeapType;
  var isHeld#_844: int;
  var isRdHeld#_845: bool;
  var cond#_846: bool;
  var methodCallK#_851: int;
  var this#299: ref where (this#299 == null) || (dtype(this#299) == AVLTreeNode#t);
  var r#300: ref where (r#300 == null) || (dtype(r#300) == AVLTreeNode#t);
  var callHeap#_847: HeapType;
  var callMask#_848: MaskType;
  var callSecMask#_849: MaskType;
  var callCredits#_850: CreditsType;
  var exhaleMask#_853: MaskType;
  var exhaleHeap#_852: HeapType;
  var isHeld#_868: int;
  var isRdHeld#_869: bool;
  var methodCallK#_874: int;
  var this#305: ref where (this#305 == null) || (dtype(this#305) == AVLTreeNode#t);
  var callHeap#_870: HeapType;
  var callMask#_871: MaskType;
  var callSecMask#_872: MaskType;
  var callCredits#_873: CreditsType;
  var exhaleMask#_876: MaskType;
  var exhaleHeap#_875: HeapType;
  var isHeld#_891: int;
  var isRdHeld#_892: bool;
  var methodCallK#_897: int;
  var this#310: ref where (this#310 == null) || (dtype(this#310) == AVLTreeNode#t);
  var callHeap#_893: HeapType;
  var callMask#_894: MaskType;
  var callSecMask#_895: MaskType;
  var callCredits#_896: CreditsType;
  var exhaleMask#_899: MaskType;
  var exhaleHeap#_898: HeapType;
  var isHeld#_914: int;
  var isRdHeld#_915: bool;
  var exhaleMask#_917: MaskType;
  var exhaleHeap#_916: HeapType;
  assume (0 < methodK#_506) && ((1000 * methodK#_506) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // unfold
  assume #AVLTreeNode.valid#trigger(this);
  assume (0 < unfoldK#_507) && (unfoldK#_507 < Fractions(1)) && ((1000 * unfoldK#_507) < methodK#_506);
  assert {:msg "  278.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  278.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  278.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[this, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[this, AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[this, AVLTreeNode.valid][perm$N]));
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#218: int :: (0 <= lk#79#218) && (lk#79#218 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#218) < Heap[this, AVLTreeNode.key]));
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#219: int :: (0 <= rk#80#219) && (rk#80#219 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#219)));
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] > 0;
    SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, this, AVLTreeNode.valid)) {
    oldVers#_527 := Heap[this, AVLTreeNode.valid];
    havoc newVers#_528;
    Heap[this, AVLTreeNode.valid] := newVers#_528;
    assume oldVers#_527 < Heap[this, AVLTreeNode.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#222: int :: (0 <= lk#79#222) && (lk#79#222 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#222) < Heap[this, AVLTreeNode.key]));
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#223: int :: (0 <= rk#80#223) && (rk#80#223 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#223)));
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_529 := Heap[this, AVLTreeNode.key] == k#19;
  assert {:msg "  279.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  279.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  if (cond#_529) {
    // if
    cond#_530 := (Heap[this, AVLTreeNode.left] == null) || (Heap[this, AVLTreeNode.right] == null);
    assert {:msg "  280.8: Receiver might be null."} true ==> (this != null);
    assert {:msg "  280.8: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  280.22: Receiver might be null."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> (this != null);
    assert {:msg "  280.22: Location might not be readable."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    if (cond#_530) {
      // assert
      assertHeap#_531 := Heap;
      assertMask#_532 := Mask;
      assertSecMask#_533 := SecMask;
      assertCredits#_534 := Credits;
      assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
      // begin exhale (assert)
      exhaleMask#_536 := assertMask#_532;
      havoc exhaleHeap#_535;
      assert {:msg "  281.12: Receiver might be null."} true ==> (this != null);
      assert {:msg "  281.12: Location might not be readable."} true ==> CanRead(assertMask#_532, assertSecMask#_533, this, AVLTreeNode.right);
      if (!(assertHeap#_531[this, AVLTreeNode.right] == null)) {
        // unfolding
        assume (0 < unfoldingK#_542) && ((1000 * unfoldingK#_542) < Fractions(1));
        predFlag#_541 := true;
        assert {:msg "  281.38: Receiver might be null."} true ==> (this != null);
        assert {:msg "  281.38: Location might not be readable."} true ==> CanRead(assertMask#_532, assertSecMask#_533, this, AVLTreeNode.right);
        assert {:msg "  281.38: Receiver might be null."} true ==> (assertHeap#_531[this, AVLTreeNode.right] != null);
        unfoldingHeap#_537 := assertHeap#_531;
        unfoldingMask#_538 := assertMask#_532;
        unfoldingSecMask#_539 := assertSecMask#_533;
        unfoldingCredits#_540 := assertCredits#_534;
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        // begin exhale (unfolding)
        assert {:msg "  281.28: Unfolding might fail. The permission at 281.38 might not be positive."} Fractions(100) > 0;
        assert {:msg "  281.28: Unfolding might fail. Insufficient fraction at 281.38 for AVLTreeNode.valid."} (Fractions(100) <= unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (false) {
          // begin exhale (update SecMask)
          if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
            assume (forall lk#79#224: int :: (0 <= lk#79#224) && (lk#79#224 < Seq#Length(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#224) < unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key]));
          }
          if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
            assume unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
          }
          if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
            assume (forall rk#80#225: int :: (0 <= rk#80#225) && (rk#80#225 < Seq#Length(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#225)));
          }
          if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
            assume unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
          }
          //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
          assume Seq#Equal(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
          //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
          assume Seq#Contains(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key]);
          //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
          assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key])));
          //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
          //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
          //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
          //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
          //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
          unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
          if (unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
            unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
          }
          assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
          if (unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
            unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
          }
          assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
          if (unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
            unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
          }
          assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_539[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
            unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
              unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
            assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          }
          if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
            unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
            assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          }
          if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
            unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
            assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          }
          if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
            unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
            assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          }
          if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
            unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
              unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
            assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          }
          if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
            unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
            assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          }
          if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
            unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
            assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          }
          if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
            unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_539[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
            assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          }
          assume wf(unfoldingHeap#_537, unfoldingSecMask#_539, unfoldingSecMask#_539);
          // end exhale
        }
        if (!CanRead(unfoldingMask#_538, unfoldingSecMask#_539, unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.valid)) {
          oldVers#_562 := unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.valid];
          havoc newVers#_563;
          unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_563;
          assume oldVers#_562 < unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume IsGoodMask(unfoldingMask#_538);
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume IsGoodMask(unfoldingMask#_538);
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        // end exhale
        // inhale (unfolding)
        assume unfoldingHeap#_537[this, AVLTreeNode.right] != null;
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume true;
        assume Fractions(100) > 0;
        unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + Fractions(100)];
        assume IsGoodMask(unfoldingMask#_538);
        assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key]));
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume unfoldingHeap#_537[this, AVLTreeNode.right] != null;
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume true;
        assume Fractions(50) > 0;
        unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(unfoldingMask#_538);
        assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height]));
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume unfoldingHeap#_537[this, AVLTreeNode.right] != null;
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume (unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
        assume Fractions(100) > 0;
        unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + Fractions(100)];
        assume IsGoodMask(unfoldingMask#_538);
        assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left]));
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume unfoldingHeap#_537[this, AVLTreeNode.right] != null;
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume (unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
        assume Fractions(100) > 0;
        unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + Fractions(100)];
        assume IsGoodMask(unfoldingMask#_538);
        assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right]));
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume unfoldingHeap#_537[this, AVLTreeNode.right] != null;
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume true;
        assume Fractions(50) > 0;
        unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(unfoldingMask#_538);
        assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys]));
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume unfoldingHeap#_537[this, AVLTreeNode.right] != null;
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume true;
        assume Fractions(50) > 0;
        unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_538[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(unfoldingMask#_538);
        assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume Fractions(100) > 0;
          unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(unfoldingMask#_538);
          assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]));
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        }
        if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume true;
          assume Fractions(50) > 0;
          unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(unfoldingMask#_538);
          assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]));
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        }
        if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume true;
          assume Fractions(50) > 0;
          unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(unfoldingMask#_538);
          assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]));
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        }
        if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume true;
          assume Fractions(50) > 0;
          unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(unfoldingMask#_538);
          assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        }
        if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume (forall lk#79#228: int :: (0 <= lk#79#228) && (lk#79#228 < Seq#Length(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#228) < unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key]));
        }
        if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume Fractions(100) > 0;
          unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(unfoldingMask#_538);
          assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]));
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        }
        if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume true;
          assume Fractions(50) > 0;
          unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(unfoldingMask#_538);
          assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        }
        if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume true;
          assume Fractions(50) > 0;
          unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(unfoldingMask#_538);
          assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]));
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        }
        if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume true;
          assume Fractions(50) > 0;
          unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_538[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(unfoldingMask#_538);
          assume IsGoodState(heapFragment(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
          assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        }
        if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume (forall rk#80#229: int :: (0 <= rk#80#229) && (rk#80#229 < Seq#Length(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#229)));
        }
        if (!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        assume Seq#Equal(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
        assume Seq#Contains(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key]);
        assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.key])));
        assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_537[unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
        assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
        assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
        assume unfoldingHeap#_537[unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
        assume IsGoodMask(unfoldingMask#_538);
        assume wf(unfoldingHeap#_537, unfoldingMask#_538, unfoldingSecMask#_539);
        // end inhale
        if (false) {
          // begin exhale (update SecMask)
          if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
            assume (forall lk#79#230: int :: (0 <= lk#79#230) && (lk#79#230 < Seq#Length(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#230) < assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key]));
          }
          if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
            assume assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
          }
          if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
            assume (forall rk#80#231: int :: (0 <= rk#80#231) && (rk#80#231 < Seq#Length(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#231)));
          }
          if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
            assume assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
          }
          //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
          assume Seq#Equal(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key])), ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
          //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
          assume Seq#Contains(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys], assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key]);
          //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
          assume (forall kk#81: int :: Seq#Contains(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key])));
          //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
          //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
          //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
          //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
          //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
          assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
          if (assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
            assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
          }
          assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
          if (assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
            assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
          }
          assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
          if (assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
            assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
          }
          assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
            assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
              assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
            assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          }
          if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
            assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
            assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          }
          if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
            assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
            assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          }
          if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
            assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
            assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          }
          if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
            assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
              assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
            assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          }
          if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
            assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
            assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          }
          if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
            assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
            assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          }
          if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
            assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
            assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          }
          assume wf(assertHeap#_531, assertSecMask#_533, assertSecMask#_533);
          // end exhale
        }
        assume assertHeap#_531[this, AVLTreeNode.right] != null;
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume true;
        assume Fractions(100) > 0;
        assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + Fractions(100)];
        assume IsGoodMask(assertMask#_532);
        assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key]));
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume assertHeap#_531[this, AVLTreeNode.right] != null;
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume true;
        assume Fractions(50) > 0;
        assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(assertMask#_532);
        assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height]));
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume assertHeap#_531[this, AVLTreeNode.right] != null;
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume (assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
        assume Fractions(100) > 0;
        assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + Fractions(100)];
        assume IsGoodMask(assertMask#_532);
        assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left]));
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume assertHeap#_531[this, AVLTreeNode.right] != null;
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume (assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
        assume Fractions(100) > 0;
        assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + Fractions(100)];
        assume IsGoodMask(assertMask#_532);
        assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right]));
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume assertHeap#_531[this, AVLTreeNode.right] != null;
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume true;
        assume Fractions(50) > 0;
        assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(assertMask#_532);
        assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys]));
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume assertHeap#_531[this, AVLTreeNode.right] != null;
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume true;
        assume Fractions(50) > 0;
        assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_533[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(assertMask#_532);
        assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume Fractions(100) > 0;
          assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(assertMask#_532);
          assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]));
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        }
        if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume true;
          assume Fractions(50) > 0;
          assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(assertMask#_532);
          assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]));
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        }
        if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume true;
          assume Fractions(50) > 0;
          assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(assertMask#_532);
          assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]));
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        }
        if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume true;
          assume Fractions(50) > 0;
          assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(assertMask#_532);
          assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        }
        if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume (forall lk#79#234: int :: (0 <= lk#79#234) && (lk#79#234 < Seq#Length(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#234) < assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key]));
        }
        if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume Fractions(100) > 0;
          assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(assertMask#_532);
          assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]));
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        }
        if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume true;
          assume Fractions(50) > 0;
          assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(assertMask#_532);
          assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        }
        if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume true;
          assume Fractions(50) > 0;
          assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(assertMask#_532);
          assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]));
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        }
        if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume true;
          assume Fractions(50) > 0;
          assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_533[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(assertMask#_532);
          assume IsGoodState(heapFragment(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
          assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
        }
        if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume (forall rk#80#235: int :: (0 <= rk#80#235) && (rk#80#235 < Seq#Length(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#235)));
        }
        if (!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        assume Seq#Equal(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key])), ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
        assume Seq#Contains(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys], assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key]);
        assume (forall kk#81: int :: Seq#Contains(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.key])));
        assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_531[assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
        assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
        assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
        assume assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
        assert {:msg "  281.53: Receiver might be null."} true ==> (this != null);
        assert {:msg "  281.53: Location might not be readable."} true ==> CanRead(unfoldingMask#_538, unfoldingSecMask#_539, this, AVLTreeNode.right);
        assert {:msg "  281.53: Receiver might be null."} true ==> (unfoldingHeap#_537[this, AVLTreeNode.right] != null);
        assert {:msg "  281.53: Location might not be readable."} true ==> CanRead(unfoldingMask#_538, unfoldingSecMask#_539, unfoldingHeap#_537[this, AVLTreeNode.right], AVLTreeNode.keys);
        assert {:msg "  281.5: Assertion might not hold. The expression at 281.28 might not evaluate to true."} !Seq#Equal(assertHeap#_531[assertHeap#_531[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Empty());
      }
      assertMask#_532 := exhaleMask#_536;
      assume IsGoodExhaleState(exhaleHeap#_535, assertHeap#_531, assertMask#_532, assertSecMask#_533);
      assertHeap#_531 := exhaleHeap#_535;
      assume IsGoodMask(assertMask#_532);
      assume wf(assertHeap#_531, assertMask#_532, assertSecMask#_533);
      // end exhale
      // assert
      assertHeap#_580 := Heap;
      assertMask#_581 := Mask;
      assertSecMask#_582 := SecMask;
      assertCredits#_583 := Credits;
      assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
      // begin exhale (assert)
      exhaleMask#_585 := assertMask#_581;
      havoc exhaleHeap#_584;
      assert {:msg "  282.12: Receiver might be null."} true ==> (this != null);
      assert {:msg "  282.12: Location might not be readable."} true ==> CanRead(assertMask#_581, assertSecMask#_582, this, AVLTreeNode.left);
      if (!(assertHeap#_580[this, AVLTreeNode.left] == null)) {
        // unfolding
        assume (0 < unfoldingK#_591) && ((1000 * unfoldingK#_591) < Fractions(1));
        predFlag#_590 := true;
        assert {:msg "  282.38: Receiver might be null."} true ==> (this != null);
        assert {:msg "  282.38: Location might not be readable."} true ==> CanRead(assertMask#_581, assertSecMask#_582, this, AVLTreeNode.left);
        assert {:msg "  282.38: Receiver might be null."} true ==> (assertHeap#_580[this, AVLTreeNode.left] != null);
        unfoldingHeap#_586 := assertHeap#_580;
        unfoldingMask#_587 := assertMask#_581;
        unfoldingSecMask#_588 := assertSecMask#_582;
        unfoldingCredits#_589 := assertCredits#_583;
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        // begin exhale (unfolding)
        assert {:msg "  282.28: Unfolding might fail. The permission at 282.38 might not be positive."} Fractions(100) > 0;
        assert {:msg "  282.28: Unfolding might fail. Insufficient fraction at 282.38 for AVLTreeNode.valid."} (Fractions(100) <= unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (false) {
          // begin exhale (update SecMask)
          if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
            assume (forall lk#79#236: int :: (0 <= lk#79#236) && (lk#79#236 < Seq#Length(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#236) < unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key]));
          }
          if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
            assume unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
          }
          if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
            assume (forall rk#80#237: int :: (0 <= rk#80#237) && (rk#80#237 < Seq#Length(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#237)));
          }
          if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
            assume unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
          }
          //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
          assume Seq#Equal(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
          //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
          assume Seq#Contains(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key]);
          //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
          assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key])));
          //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
          //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
          //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
          //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
          //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
          unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
          if (unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
            unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
          }
          assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
          if (unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
            unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
          }
          assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
          if (unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
            unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
          }
          assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_588[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
            unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
              unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
            assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          }
          if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
            unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
            assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          }
          if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
            unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
            assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          }
          if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
            unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
            assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          }
          if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
            unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
              unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
            assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          }
          if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
            unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
            assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          }
          if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
            unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
            assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          }
          if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
            unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_588[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
            assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          }
          assume wf(unfoldingHeap#_586, unfoldingSecMask#_588, unfoldingSecMask#_588);
          // end exhale
        }
        if (!CanRead(unfoldingMask#_587, unfoldingSecMask#_588, unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.valid)) {
          oldVers#_611 := unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.valid];
          havoc newVers#_612;
          unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_612;
          assume oldVers#_611 < unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume IsGoodMask(unfoldingMask#_587);
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume IsGoodMask(unfoldingMask#_587);
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        // end exhale
        // inhale (unfolding)
        assume unfoldingHeap#_586[this, AVLTreeNode.left] != null;
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume true;
        assume Fractions(100) > 0;
        unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + Fractions(100)];
        assume IsGoodMask(unfoldingMask#_587);
        assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key]));
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume unfoldingHeap#_586[this, AVLTreeNode.left] != null;
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume true;
        assume Fractions(50) > 0;
        unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(unfoldingMask#_587);
        assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height]));
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume unfoldingHeap#_586[this, AVLTreeNode.left] != null;
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume (unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
        assume Fractions(100) > 0;
        unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + Fractions(100)];
        assume IsGoodMask(unfoldingMask#_587);
        assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left]));
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume unfoldingHeap#_586[this, AVLTreeNode.left] != null;
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume (unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
        assume Fractions(100) > 0;
        unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + Fractions(100)];
        assume IsGoodMask(unfoldingMask#_587);
        assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right]));
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume unfoldingHeap#_586[this, AVLTreeNode.left] != null;
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume true;
        assume Fractions(50) > 0;
        unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(unfoldingMask#_587);
        assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys]));
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume unfoldingHeap#_586[this, AVLTreeNode.left] != null;
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume true;
        assume Fractions(50) > 0;
        unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_587[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(unfoldingMask#_587);
        assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume Fractions(100) > 0;
          unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(unfoldingMask#_587);
          assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]));
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        }
        if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume true;
          assume Fractions(50) > 0;
          unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(unfoldingMask#_587);
          assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]));
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        }
        if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume true;
          assume Fractions(50) > 0;
          unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(unfoldingMask#_587);
          assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]));
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        }
        if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume true;
          assume Fractions(50) > 0;
          unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(unfoldingMask#_587);
          assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        }
        if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume (forall lk#79#240: int :: (0 <= lk#79#240) && (lk#79#240 < Seq#Length(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#240) < unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key]));
        }
        if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume Fractions(100) > 0;
          unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(unfoldingMask#_587);
          assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]));
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        }
        if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume true;
          assume Fractions(50) > 0;
          unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(unfoldingMask#_587);
          assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        }
        if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume true;
          assume Fractions(50) > 0;
          unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(unfoldingMask#_587);
          assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]));
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        }
        if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume true;
          assume Fractions(50) > 0;
          unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_587[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(unfoldingMask#_587);
          assume IsGoodState(heapFragment(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
          assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        }
        if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume (forall rk#80#241: int :: (0 <= rk#80#241) && (rk#80#241 < Seq#Length(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#241)));
        }
        if (!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        assume Seq#Equal(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
        assume Seq#Contains(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key]);
        assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.key])));
        assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_586[unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
        assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
        assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
        assume unfoldingHeap#_586[unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
        assume IsGoodMask(unfoldingMask#_587);
        assume wf(unfoldingHeap#_586, unfoldingMask#_587, unfoldingSecMask#_588);
        // end inhale
        if (false) {
          // begin exhale (update SecMask)
          if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
            assume (forall lk#79#242: int :: (0 <= lk#79#242) && (lk#79#242 < Seq#Length(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#242) < assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key]));
          }
          if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
            assume assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
          }
          if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
            assume (forall rk#80#243: int :: (0 <= rk#80#243) && (rk#80#243 < Seq#Length(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#243)));
          }
          if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
            assume assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
          }
          //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
          assume Seq#Equal(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key])), ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
          //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
          assume Seq#Contains(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys], assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key]);
          //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
          assume (forall kk#81: int :: Seq#Contains(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key])));
          //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
          //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
          //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
          //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
          //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
          assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
          if (assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
            assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
          }
          assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
          if (assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
            assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
          }
          assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
          if (assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
            assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
          }
          assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
            assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
              assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
            assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          }
          if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
            assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
            assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          }
          if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
            assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
            assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          }
          if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
            assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
            assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          }
          if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
            assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
              assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
            assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          }
          if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
            assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
            assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          }
          if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
            assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
            assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          }
          if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
            assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
            assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          }
          assume wf(assertHeap#_580, assertSecMask#_582, assertSecMask#_582);
          // end exhale
        }
        assume assertHeap#_580[this, AVLTreeNode.left] != null;
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume true;
        assume Fractions(100) > 0;
        assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + Fractions(100)];
        assume IsGoodMask(assertMask#_581);
        assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key]));
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume assertHeap#_580[this, AVLTreeNode.left] != null;
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume true;
        assume Fractions(50) > 0;
        assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(assertMask#_581);
        assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height]));
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume assertHeap#_580[this, AVLTreeNode.left] != null;
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume (assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
        assume Fractions(100) > 0;
        assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + Fractions(100)];
        assume IsGoodMask(assertMask#_581);
        assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left]));
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume assertHeap#_580[this, AVLTreeNode.left] != null;
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume (assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
        assume Fractions(100) > 0;
        assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + Fractions(100)];
        assume IsGoodMask(assertMask#_581);
        assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right]));
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume assertHeap#_580[this, AVLTreeNode.left] != null;
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume true;
        assume Fractions(50) > 0;
        assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(assertMask#_581);
        assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys]));
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume assertHeap#_580[this, AVLTreeNode.left] != null;
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume true;
        assume Fractions(50) > 0;
        assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_582[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(assertMask#_581);
        assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume Fractions(100) > 0;
          assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(assertMask#_581);
          assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]));
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        }
        if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume true;
          assume Fractions(50) > 0;
          assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(assertMask#_581);
          assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]));
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        }
        if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume true;
          assume Fractions(50) > 0;
          assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(assertMask#_581);
          assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]));
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        }
        if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume true;
          assume Fractions(50) > 0;
          assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(assertMask#_581);
          assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        }
        if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume (forall lk#79#246: int :: (0 <= lk#79#246) && (lk#79#246 < Seq#Length(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#246) < assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key]));
        }
        if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume Fractions(100) > 0;
          assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(assertMask#_581);
          assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]));
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        }
        if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume true;
          assume Fractions(50) > 0;
          assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(assertMask#_581);
          assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        }
        if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume true;
          assume Fractions(50) > 0;
          assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(assertMask#_581);
          assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]));
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        }
        if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume true;
          assume Fractions(50) > 0;
          assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_582[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(assertMask#_581);
          assume IsGoodState(heapFragment(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
          assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
        }
        if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume (forall rk#80#247: int :: (0 <= rk#80#247) && (rk#80#247 < Seq#Length(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#247)));
        }
        if (!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        assume Seq#Equal(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key])), ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
        assume Seq#Contains(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys], assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key]);
        assume (forall kk#81: int :: Seq#Contains(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.key])));
        assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_580[assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
        assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
        assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
        assume assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
        assert {:msg "  282.53: Receiver might be null."} true ==> (this != null);
        assert {:msg "  282.53: Location might not be readable."} true ==> CanRead(unfoldingMask#_587, unfoldingSecMask#_588, this, AVLTreeNode.left);
        assert {:msg "  282.53: Receiver might be null."} true ==> (unfoldingHeap#_586[this, AVLTreeNode.left] != null);
        assert {:msg "  282.53: Location might not be readable."} true ==> CanRead(unfoldingMask#_587, unfoldingSecMask#_588, unfoldingHeap#_586[this, AVLTreeNode.left], AVLTreeNode.keys);
        assert {:msg "  282.5: Assertion might not hold. The expression at 282.28 might not evaluate to true."} !Seq#Equal(assertHeap#_580[assertHeap#_580[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Empty());
      }
      assertMask#_581 := exhaleMask#_585;
      assume IsGoodExhaleState(exhaleHeap#_584, assertHeap#_580, assertMask#_581, assertSecMask#_582);
      assertHeap#_580 := exhaleHeap#_584;
      assume IsGoodMask(assertMask#_581);
      assume wf(assertHeap#_580, assertMask#_581, assertSecMask#_582);
      // end exhale
      // if
      cond#_629 := Heap[this, AVLTreeNode.left] == null;
      assert {:msg "  283.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  283.9: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
      if (cond#_629) {
        // assigment to r
        assert {:msg "  284.11: Receiver might be null."} true ==> (this != null);
        assert {:msg "  284.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
        r#20 := Heap[this, AVLTreeNode.right];
      } else {
        // assigment to r
        assert {:msg "  286.11: Receiver might be null."} true ==> (this != null);
        assert {:msg "  286.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
        r#20 := Heap[this, AVLTreeNode.left];
      }
    } else {
      // local var bf
      // local var nl
      // assigment to nl
      assert {:msg "  290.29: Receiver might be null."} true ==> (this != null);
      assert {:msg "  290.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
      nl#24 := Heap[this, AVLTreeNode.left];
      // local var nr
      // assigment to nr
      assert {:msg "  291.29: Receiver might be null."} true ==> (this != null);
      assert {:msg "  291.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
      nr#26 := Heap[this, AVLTreeNode.right];
      assume (0 < methodCallK#_634) && ((1000 * methodCallK#_634) < Fractions(1)) && ((1000 * methodCallK#_634) < methodK#_506);
      // call getBalanceFactorI
      callHeap#_630 := Heap;
      callMask#_631 := Mask;
      callSecMask#_632 := SecMask;
      callCredits#_633 := Credits;
      assume wf(callHeap#_630, callMask#_631, callSecMask#_632);
      assert {:msg "  293.5: The target of the method call might be null."} this != null;
      this#248 := this;
      // begin exhale (precondition)
      exhaleMask#_636 := Mask;
      havoc exhaleHeap#_635;
      assert {:msg "  293.5: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_634 > 0;
      assert {:msg "  293.5: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_636[this#248, AVLTreeNode.left][perm$R] > 0;
      assume methodCallK#_634 < exhaleMask#_636[this#248, AVLTreeNode.left][perm$R];
      exhaleMask#_636[this#248, AVLTreeNode.left] := exhaleMask#_636[this#248, AVLTreeNode.left][perm$R := exhaleMask#_636[this#248, AVLTreeNode.left][perm$R] - methodCallK#_634];
      assume IsGoodMask(exhaleMask#_636);
      assume wf(Heap, exhaleMask#_636, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#248, AVLTreeNode.left] == null)) {
        assert {:msg "  293.5: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_634 > 0;
        assert {:msg "  293.5: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_636[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0;
        assume methodCallK#_634 < exhaleMask#_636[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height][perm$R];
        exhaleMask#_636[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_636[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_636[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_634];
        assume IsGoodMask(exhaleMask#_636);
        assume wf(Heap, exhaleMask#_636, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assert {:msg "  293.5: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_634 > 0;
      assert {:msg "  293.5: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_636[this#248, AVLTreeNode.right][perm$R] > 0;
      assume methodCallK#_634 < exhaleMask#_636[this#248, AVLTreeNode.right][perm$R];
      exhaleMask#_636[this#248, AVLTreeNode.right] := exhaleMask#_636[this#248, AVLTreeNode.right][perm$R := exhaleMask#_636[this#248, AVLTreeNode.right][perm$R] - methodCallK#_634];
      assume IsGoodMask(exhaleMask#_636);
      assume wf(Heap, exhaleMask#_636, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#248, AVLTreeNode.right] == null)) {
        assert {:msg "  293.5: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_634 > 0;
        assert {:msg "  293.5: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_636[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0;
        assume methodCallK#_634 < exhaleMask#_636[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height][perm$R];
        exhaleMask#_636[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_636[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_636[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_634];
        assume IsGoodMask(exhaleMask#_636);
        assume wf(Heap, exhaleMask#_636, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#248, AVLTreeNode.left] == null)) {
        assert {:msg "  293.5: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} Fractions(100) > 0;
        assert {:msg "  293.5: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_636[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_636[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_636[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_636[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_636[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_636[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_636, SecMask, Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_635[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_636);
        assume wf(Heap, exhaleMask#_636, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#248, AVLTreeNode.right] == null)) {
        assert {:msg "  293.5: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} Fractions(100) > 0;
        assert {:msg "  293.5: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_636[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_636[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_636[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_636[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_636[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_636[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_636, SecMask, Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_635[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_636);
        assume wf(Heap, exhaleMask#_636, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_636;
      assume IsGoodExhaleState(exhaleHeap#_635, Heap, Mask, SecMask);
      Heap := exhaleHeap#_635;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      havoc bf#249;
      // inhale (postcondition)
      assume this#248 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[this#248, AVLTreeNode.left] == null) || (dtype(Heap[this#248, AVLTreeNode.left]) == AVLTreeNode#t);
      assume methodCallK#_634 > 0;
      Mask[this#248, AVLTreeNode.left] := Mask[this#248, AVLTreeNode.left][perm$R := Mask[this#248, AVLTreeNode.left][perm$R] + methodCallK#_634];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#248, AVLTreeNode.left]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#248, AVLTreeNode.left] == null)) {
        assume Heap[this#248, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#248, AVLTreeNode.left] == null)) {
        assume Heap[this#248, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_634 > 0;
        Mask[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_634];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume this#248 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[this#248, AVLTreeNode.right] == null) || (dtype(Heap[this#248, AVLTreeNode.right]) == AVLTreeNode#t);
      assume methodCallK#_634 > 0;
      Mask[this#248, AVLTreeNode.right] := Mask[this#248, AVLTreeNode.right][perm$R := Mask[this#248, AVLTreeNode.right][perm$R] + methodCallK#_634];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#248, AVLTreeNode.right]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#248, AVLTreeNode.right] == null)) {
        assume Heap[this#248, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#248, AVLTreeNode.right] == null)) {
        assume Heap[this#248, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_634 > 0;
        Mask[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_634];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume bf#249 == (ite(Heap[this#248, AVLTreeNode.left] == null, 0, Heap[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#248, AVLTreeNode.right] == null, 0, Heap[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height]));
      if (bf#249 > 0) {
        assume !(Heap[this#248, AVLTreeNode.left] == null);
      }
      if (bf#249 < 0) {
        assume !(Heap[this#248, AVLTreeNode.right] == null);
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      bf#22 := bf#249;
      // if
      cond#_645 := bf#22 > 0;
      if (cond#_645) {
        assume (0 < methodCallK#_650) && ((1000 * methodCallK#_650) < Fractions(1)) && ((1000 * methodCallK#_650) < methodK#_506);
        // call pruneMax
        callHeap#_646 := Heap;
        callMask#_647 := Mask;
        callSecMask#_648 := SecMask;
        callCredits#_649 := Credits;
        assume wf(callHeap#_646, callMask#_647, callSecMask#_648);
        assert {:msg "  295.19: Receiver might be null."} true ==> (this != null);
        assert {:msg "  295.19: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
        assert {:msg "  295.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#250 := Heap[this, AVLTreeNode.left];
        // begin exhale (precondition)
        exhaleMask#_652 := Mask;
        havoc exhaleHeap#_651;
        assert {:msg "  295.6: The precondition at 349.12 might not hold. The permission at 349.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  295.6: The precondition at 349.12 might not hold. Insufficient fraction at 349.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_652[this#250, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_652[this#250, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_652[this#250, AVLTreeNode.valid][perm$N]));
        exhaleMask#_652[this#250, AVLTreeNode.valid] := exhaleMask#_652[this#250, AVLTreeNode.valid][perm$R := exhaleMask#_652[this#250, AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_652, SecMask, this#250, AVLTreeNode.valid)) {
          assume Heap[this#250, AVLTreeNode.valid] < exhaleHeap#_651[this#250, AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_652);
        assume wf(Heap, exhaleMask#_652, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  295.6: The precondition at 350.12 might not hold. The permission at 350.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  295.6: The precondition at 350.12 might not hold. Insufficient fraction at 350.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_652[this#250, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_652[this#250, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_652[this#250, AVLTreeNode.keys][perm$N]));
        exhaleMask#_652[this#250, AVLTreeNode.keys] := exhaleMask#_652[this#250, AVLTreeNode.keys][perm$R := exhaleMask#_652[this#250, AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_652);
        assume wf(Heap, exhaleMask#_652, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  295.6: The precondition at 351.12 might not hold. The permission at 351.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  295.6: The precondition at 351.12 might not hold. Insufficient fraction at 351.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_652[this#250, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_652[this#250, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_652[this#250, AVLTreeNode.height][perm$N]));
        exhaleMask#_652[this#250, AVLTreeNode.height] := exhaleMask#_652[this#250, AVLTreeNode.height][perm$R := exhaleMask#_652[this#250, AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_652);
        assume wf(Heap, exhaleMask#_652, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  295.6: The precondition at 352.12 might not hold. The permission at 352.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  295.6: The precondition at 352.12 might not hold. Insufficient fraction at 352.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_652[this#250, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_652[this#250, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_652[this#250, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_652[this#250, AVLTreeNode.balanceFactor] := exhaleMask#_652[this#250, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_652[this#250, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_652);
        assume wf(Heap, exhaleMask#_652, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_652;
        assume IsGoodExhaleState(exhaleHeap#_651, Heap, Mask, SecMask);
        Heap := exhaleHeap#_651;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#251;
        havoc m#252;
        // inhale (postcondition)
        if (!(r#251 == null)) {
          assume r#251 != null;
          assume wf(Heap, Mask, SecMask);
          assume Fractions(100) > 0;
          Mask[r#251, AVLTreeNode.valid] := Mask[r#251, AVLTreeNode.valid][perm$R := Mask[r#251, AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#251, AVLTreeNode.valid]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#251 == null)) {
          assume r#251 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#251, AVLTreeNode.keys] := Mask[r#251, AVLTreeNode.keys][perm$R := Mask[r#251, AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#251, AVLTreeNode.keys]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#251 == null)) {
          assume r#251 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#251, AVLTreeNode.height] := Mask[r#251, AVLTreeNode.height][perm$R := Mask[r#251, AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#251, AVLTreeNode.height]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#251 == null)) {
          assume r#251 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#251, AVLTreeNode.balanceFactor] := Mask[r#251, AVLTreeNode.balanceFactor][perm$R := Mask[r#251, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#251, AVLTreeNode.balanceFactor]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#251 == null)) {
          assume (Heap[r#251, AVLTreeNode.height] == callHeap#_646[this#250, AVLTreeNode.height]) || ((Heap[r#251, AVLTreeNode.height] + 1) == callHeap#_646[this#250, AVLTreeNode.height]);
        }
        if (!(r#251 == null)) {
          assume (Seq#Length(Heap[r#251, AVLTreeNode.keys]) + 1) == Seq#Length(callHeap#_646[this#250, AVLTreeNode.keys]);
        }
        if (callHeap#_646[this#250, AVLTreeNode.height] > 1) {
          assume !(r#251 == null);
        }
        if (callHeap#_646[this#250, AVLTreeNode.height] == 1) {
          assume r#251 == null;
        }
        assume (callHeap#_646[this#250, AVLTreeNode.height] == ite(r#251 == null, 0, Heap[r#251, AVLTreeNode.height])) || (callHeap#_646[this#250, AVLTreeNode.height] == (ite(r#251 == null, 0, Heap[r#251, AVLTreeNode.height]) + 1));
        assume !(m#252 == null);
        assume m#252 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[m#252, AVLTreeNode.valid] := Mask[m#252, AVLTreeNode.valid][perm$R := Mask[m#252, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[m#252, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume m#252 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[m#252, AVLTreeNode.keys] := Mask[m#252, AVLTreeNode.keys][perm$R := Mask[m#252, AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[m#252, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume m#252 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[m#252, AVLTreeNode.height] := Mask[m#252, AVLTreeNode.height][perm$R := Mask[m#252, AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[m#252, AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume m#252 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[m#252, AVLTreeNode.balanceFactor] := Mask[m#252, AVLTreeNode.balanceFactor][perm$R := Mask[m#252, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[m#252, AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Heap[m#252, AVLTreeNode.height] == 1;
        assume Seq#Length(Heap[m#252, AVLTreeNode.keys]) == 1;
        assume Seq#Equal(Seq#Append(ite(r#251 == null, Seq#Empty(), Heap[r#251, AVLTreeNode.keys]), Heap[m#252, AVLTreeNode.keys]), callHeap#_646[this#250, AVLTreeNode.keys]);
        if (!(r#251 == null)) {
          assume (forall k#86#253: int :: (0 <= k#86#253) && (k#86#253 < Seq#Length(Heap[r#251, AVLTreeNode.keys])) ==> (Seq#Index(Heap[r#251, AVLTreeNode.keys], k#86#253) < Seq#Index(Heap[m#252, AVLTreeNode.keys], 0)));
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        nl#24 := r#251;
        r#20 := m#252;
      } else {
        assume (0 < methodCallK#_663) && ((1000 * methodCallK#_663) < Fractions(1)) && ((1000 * methodCallK#_663) < methodK#_506);
        // call pruneMin
        callHeap#_659 := Heap;
        callMask#_660 := Mask;
        callSecMask#_661 := SecMask;
        callCredits#_662 := Credits;
        assume wf(callHeap#_659, callMask#_660, callSecMask#_661);
        assert {:msg "  297.19: Receiver might be null."} true ==> (this != null);
        assert {:msg "  297.19: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
        assert {:msg "  297.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#254 := Heap[this, AVLTreeNode.right];
        // begin exhale (precondition)
        exhaleMask#_665 := Mask;
        havoc exhaleHeap#_664;
        assert {:msg "  297.6: The precondition at 404.12 might not hold. The permission at 404.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  297.6: The precondition at 404.12 might not hold. Insufficient fraction at 404.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_665[this#254, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_665[this#254, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_665[this#254, AVLTreeNode.valid][perm$N]));
        exhaleMask#_665[this#254, AVLTreeNode.valid] := exhaleMask#_665[this#254, AVLTreeNode.valid][perm$R := exhaleMask#_665[this#254, AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_665, SecMask, this#254, AVLTreeNode.valid)) {
          assume Heap[this#254, AVLTreeNode.valid] < exhaleHeap#_664[this#254, AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_665);
        assume wf(Heap, exhaleMask#_665, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  297.6: The precondition at 405.12 might not hold. The permission at 405.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  297.6: The precondition at 405.12 might not hold. Insufficient fraction at 405.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_665[this#254, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_665[this#254, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_665[this#254, AVLTreeNode.keys][perm$N]));
        exhaleMask#_665[this#254, AVLTreeNode.keys] := exhaleMask#_665[this#254, AVLTreeNode.keys][perm$R := exhaleMask#_665[this#254, AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_665);
        assume wf(Heap, exhaleMask#_665, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  297.6: The precondition at 406.12 might not hold. The permission at 406.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  297.6: The precondition at 406.12 might not hold. Insufficient fraction at 406.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_665[this#254, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_665[this#254, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_665[this#254, AVLTreeNode.height][perm$N]));
        exhaleMask#_665[this#254, AVLTreeNode.height] := exhaleMask#_665[this#254, AVLTreeNode.height][perm$R := exhaleMask#_665[this#254, AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_665);
        assume wf(Heap, exhaleMask#_665, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  297.6: The precondition at 407.12 might not hold. The permission at 407.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  297.6: The precondition at 407.12 might not hold. Insufficient fraction at 407.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_665[this#254, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_665[this#254, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_665[this#254, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_665[this#254, AVLTreeNode.balanceFactor] := exhaleMask#_665[this#254, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_665[this#254, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_665);
        assume wf(Heap, exhaleMask#_665, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_665;
        assume IsGoodExhaleState(exhaleHeap#_664, Heap, Mask, SecMask);
        Heap := exhaleHeap#_664;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#255;
        havoc m#256;
        // inhale (postcondition)
        if (!(r#255 == null)) {
          assume r#255 != null;
          assume wf(Heap, Mask, SecMask);
          assume Fractions(100) > 0;
          Mask[r#255, AVLTreeNode.valid] := Mask[r#255, AVLTreeNode.valid][perm$R := Mask[r#255, AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#255, AVLTreeNode.valid]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#255 == null)) {
          assume r#255 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#255, AVLTreeNode.keys] := Mask[r#255, AVLTreeNode.keys][perm$R := Mask[r#255, AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#255, AVLTreeNode.keys]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#255 == null)) {
          assume r#255 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#255, AVLTreeNode.height] := Mask[r#255, AVLTreeNode.height][perm$R := Mask[r#255, AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#255, AVLTreeNode.height]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#255 == null)) {
          assume r#255 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#255, AVLTreeNode.balanceFactor] := Mask[r#255, AVLTreeNode.balanceFactor][perm$R := Mask[r#255, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#255, AVLTreeNode.balanceFactor]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#255 == null)) {
          assume (Heap[r#255, AVLTreeNode.height] == callHeap#_659[this#254, AVLTreeNode.height]) || (Heap[r#255, AVLTreeNode.height] == (callHeap#_659[this#254, AVLTreeNode.height] - 1));
        }
        if (!(r#255 == null)) {
          assume (Seq#Length(Heap[r#255, AVLTreeNode.keys]) + 1) == Seq#Length(callHeap#_659[this#254, AVLTreeNode.keys]);
        }
        if (callHeap#_659[this#254, AVLTreeNode.height] > 1) {
          assume !(r#255 == null);
        }
        if (callHeap#_659[this#254, AVLTreeNode.height] == 1) {
          assume r#255 == null;
        }
        assume (callHeap#_659[this#254, AVLTreeNode.height] == ite(r#255 == null, 0, Heap[r#255, AVLTreeNode.height])) || (callHeap#_659[this#254, AVLTreeNode.height] == (ite(r#255 == null, 0, Heap[r#255, AVLTreeNode.height]) + 1));
        assume !(m#256 == null);
        assume m#256 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[m#256, AVLTreeNode.valid] := Mask[m#256, AVLTreeNode.valid][perm$R := Mask[m#256, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[m#256, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume m#256 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[m#256, AVLTreeNode.keys] := Mask[m#256, AVLTreeNode.keys][perm$R := Mask[m#256, AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[m#256, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume m#256 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[m#256, AVLTreeNode.height] := Mask[m#256, AVLTreeNode.height][perm$R := Mask[m#256, AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[m#256, AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume m#256 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[m#256, AVLTreeNode.balanceFactor] := Mask[m#256, AVLTreeNode.balanceFactor][perm$R := Mask[m#256, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[m#256, AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Heap[m#256, AVLTreeNode.height] == 1;
        assume Seq#Length(Heap[m#256, AVLTreeNode.keys]) == 1;
        assume Seq#Equal(Seq#Append(Heap[m#256, AVLTreeNode.keys], ite(r#255 == null, Seq#Empty(), Heap[r#255, AVLTreeNode.keys])), callHeap#_659[this#254, AVLTreeNode.keys]);
        if (!(r#255 == null)) {
          assume (forall k#89#257: int :: (0 <= k#89#257) && (k#89#257 < Seq#Length(Heap[r#255, AVLTreeNode.keys])) ==> (Seq#Index(Heap[m#256, AVLTreeNode.keys], 0) < Seq#Index(Heap[r#255, AVLTreeNode.keys], k#89#257)));
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        nr#26 := r#255;
        r#20 := m#256;
      }
      // unfold
      assume #AVLTreeNode.valid#trigger(r#20);
      assume (0 < unfoldK#_672) && (unfoldK#_672 < Fractions(1)) && ((1000 * unfoldK#_672) < methodK#_506);
      assert {:msg "  299.5: The target of the fold statement might be null."} r#20 != null;
      // begin exhale (unfold)
      assert {:msg "  299.5: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
      assert {:msg "  299.5: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[r#20, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[r#20, AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[r#20, AVLTreeNode.valid][perm$N]));
      Mask[r#20, AVLTreeNode.valid] := Mask[r#20, AVLTreeNode.valid][perm$R := Mask[r#20, AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (false) {
        // begin exhale (update SecMask)
        if (!(Heap[r#20, AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
          assume (forall lk#79#258: int :: (0 <= lk#79#258) && (lk#79#258 < Seq#Length(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys], lk#79#258) < Heap[r#20, AVLTreeNode.key]));
        }
        if (!(Heap[r#20, AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
          assume Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(Heap[r#20, AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
          assume (forall rk#80#259: int :: (0 <= rk#80#259) && (rk#80#259 < Seq#Length(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#20, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys], rk#80#259)));
        }
        if (!(Heap[r#20, AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
          assume Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
        assume Seq#Equal(Heap[r#20, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#20, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#20, AVLTreeNode.key])), ite(Heap[r#20, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys])));
        //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
        assume Seq#Contains(Heap[r#20, AVLTreeNode.keys], Heap[r#20, AVLTreeNode.key]);
        //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
        assume (forall kk#81: int :: Seq#Contains(Heap[r#20, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#20, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#20, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#20, AVLTreeNode.key])));
        //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
        assume Heap[r#20, AVLTreeNode.height] == ite(ite(Heap[r#20, AVLTreeNode.left] == null, 0, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#20, AVLTreeNode.right] == null, 0, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#20, AVLTreeNode.left] == null, 0, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#20, AVLTreeNode.right] == null, 0, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
        assume Heap[r#20, AVLTreeNode.balanceFactor] == (ite(Heap[r#20, AVLTreeNode.left] == null, 0, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#20, AVLTreeNode.right] == null, 0, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]));
        //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
        assume Heap[r#20, AVLTreeNode.balanceFactor] <= 1;
        //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
        assume Heap[r#20, AVLTreeNode.balanceFactor] >= (0 - 1);
        //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
        assume Heap[r#20, AVLTreeNode.height] > 0;
        SecMask[r#20, AVLTreeNode.key] := SecMask[r#20, AVLTreeNode.key][perm$R := SecMask[r#20, AVLTreeNode.key][perm$R] - Fractions(100)];
        if (SecMask[r#20, AVLTreeNode.key][perm$R] < 0) {
          SecMask[r#20, AVLTreeNode.key] := SecMask[r#20, AVLTreeNode.key][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[r#20, AVLTreeNode.height] := SecMask[r#20, AVLTreeNode.height][perm$R := SecMask[r#20, AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[r#20, AVLTreeNode.height][perm$R] < 0) {
          SecMask[r#20, AVLTreeNode.height] := SecMask[r#20, AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[r#20, AVLTreeNode.left] := SecMask[r#20, AVLTreeNode.left][perm$R := SecMask[r#20, AVLTreeNode.left][perm$R] - Fractions(100)];
        if (SecMask[r#20, AVLTreeNode.left][perm$R] < 0) {
          SecMask[r#20, AVLTreeNode.left] := SecMask[r#20, AVLTreeNode.left][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[r#20, AVLTreeNode.right] := SecMask[r#20, AVLTreeNode.right][perm$R := SecMask[r#20, AVLTreeNode.right][perm$R] - Fractions(100)];
        if (SecMask[r#20, AVLTreeNode.right][perm$R] < 0) {
          SecMask[r#20, AVLTreeNode.right] := SecMask[r#20, AVLTreeNode.right][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[r#20, AVLTreeNode.keys] := SecMask[r#20, AVLTreeNode.keys][perm$R := SecMask[r#20, AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[r#20, AVLTreeNode.keys][perm$R] < 0) {
          SecMask[r#20, AVLTreeNode.keys] := SecMask[r#20, AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[r#20, AVLTreeNode.balanceFactor] := SecMask[r#20, AVLTreeNode.balanceFactor][perm$R := SecMask[r#20, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[r#20, AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[r#20, AVLTreeNode.balanceFactor] := SecMask[r#20, AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[r#20, AVLTreeNode.left] == null)) {
          SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[r#20, AVLTreeNode.left] == null)) {
          SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[r#20, AVLTreeNode.left] == null)) {
          SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[r#20, AVLTreeNode.left] == null)) {
          SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[r#20, AVLTreeNode.right] == null)) {
          SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[r#20, AVLTreeNode.right] == null)) {
          SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[r#20, AVLTreeNode.right] == null)) {
          SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[r#20, AVLTreeNode.right] == null)) {
          SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume wf(Heap, SecMask, SecMask);
        // end exhale
      }
      if (!CanRead(Mask, SecMask, r#20, AVLTreeNode.valid)) {
        oldVers#_692 := Heap[r#20, AVLTreeNode.valid];
        havoc newVers#_693;
        Heap[r#20, AVLTreeNode.valid] := newVers#_693;
        assume oldVers#_692 < Heap[r#20, AVLTreeNode.valid];
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      // inhale (unfold)
      assume r#20 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(100) > 0;
      Mask[r#20, AVLTreeNode.key] := Mask[r#20, AVLTreeNode.key][perm$R := Mask[r#20, AVLTreeNode.key][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#20, AVLTreeNode.key]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#20 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#20, AVLTreeNode.height] := Mask[r#20, AVLTreeNode.height][perm$R := Mask[r#20, AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#20, AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#20 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[r#20, AVLTreeNode.left] == null) || (dtype(Heap[r#20, AVLTreeNode.left]) == AVLTreeNode#t);
      assume Fractions(100) > 0;
      Mask[r#20, AVLTreeNode.left] := Mask[r#20, AVLTreeNode.left][perm$R := Mask[r#20, AVLTreeNode.left][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#20, AVLTreeNode.left]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#20 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[r#20, AVLTreeNode.right] == null) || (dtype(Heap[r#20, AVLTreeNode.right]) == AVLTreeNode#t);
      assume Fractions(100) > 0;
      Mask[r#20, AVLTreeNode.right] := Mask[r#20, AVLTreeNode.right][perm$R := Mask[r#20, AVLTreeNode.right][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#20, AVLTreeNode.right]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#20 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#20, AVLTreeNode.keys] := Mask[r#20, AVLTreeNode.keys][perm$R := Mask[r#20, AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#20, AVLTreeNode.keys]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#20 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#20, AVLTreeNode.balanceFactor] := Mask[r#20, AVLTreeNode.balanceFactor][perm$R := Mask[r#20, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#20, AVLTreeNode.balanceFactor]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume (forall lk#79#262: int :: (0 <= lk#79#262) && (lk#79#262 < Seq#Length(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys], lk#79#262) < Heap[r#20, AVLTreeNode.key]));
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume (forall rk#80#263: int :: (0 <= rk#80#263) && (rk#80#263 < Seq#Length(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#20, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys], rk#80#263)));
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      assume Seq#Equal(Heap[r#20, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#20, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#20, AVLTreeNode.key])), ite(Heap[r#20, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys])));
      assume Seq#Contains(Heap[r#20, AVLTreeNode.keys], Heap[r#20, AVLTreeNode.key]);
      assume (forall kk#81: int :: Seq#Contains(Heap[r#20, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#20, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#20, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#20, AVLTreeNode.key])));
      assume Heap[r#20, AVLTreeNode.height] == ite(ite(Heap[r#20, AVLTreeNode.left] == null, 0, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#20, AVLTreeNode.right] == null, 0, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#20, AVLTreeNode.left] == null, 0, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#20, AVLTreeNode.right] == null, 0, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]) + 1);
      assume Heap[r#20, AVLTreeNode.balanceFactor] == (ite(Heap[r#20, AVLTreeNode.left] == null, 0, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#20, AVLTreeNode.right] == null, 0, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]));
      assume Heap[r#20, AVLTreeNode.balanceFactor] <= 1;
      assume Heap[r#20, AVLTreeNode.balanceFactor] >= (0 - 1);
      assume Heap[r#20, AVLTreeNode.height] > 0;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      // update field left
      assert {:msg "  300.5: Location might not be writable"} CanWrite(Mask, r#20, AVLTreeNode.left);
      Heap[r#20, AVLTreeNode.left] := nl#24;
      assume wf(Heap, Mask, SecMask);
      // update field right
      assert {:msg "  301.5: Location might not be writable"} CanWrite(Mask, r#20, AVLTreeNode.right);
      Heap[r#20, AVLTreeNode.right] := nr#26;
      assume wf(Heap, Mask, SecMask);
      assume (0 < methodCallK#_698) && ((1000 * methodCallK#_698) < Fractions(1)) && ((1000 * methodCallK#_698) < methodK#_506);
      // call close
      callHeap#_694 := Heap;
      callMask#_695 := Mask;
      callSecMask#_696 := SecMask;
      callCredits#_697 := Credits;
      assume wf(callHeap#_694, callMask#_695, callSecMask#_696);
      assert {:msg "  302.5: The target of the method call might be null."} r#20 != null;
      this#264 := r#20;
      // begin exhale (precondition)
      exhaleMask#_700 := Mask;
      havoc exhaleHeap#_699;
      if (!(Heap[this#264, AVLTreeNode.left] == null)) {
        assert {:msg "  302.5: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#265: int :: (0 <= k#92#265) && (k#92#265 < Seq#Length(Heap[Heap[this#264, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#264, AVLTreeNode.left], AVLTreeNode.keys], k#92#265) < Heap[this#264, AVLTreeNode.key]));
      }
      if (!(Heap[this#264, AVLTreeNode.right] == null)) {
        assert {:msg "  302.5: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#266: int :: (0 <= k#93#266) && (k#93#266 < Seq#Length(Heap[Heap[this#264, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#264, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#264, AVLTreeNode.right], AVLTreeNode.keys], k#93#266)));
      }
      assert {:msg "  302.5: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#264, AVLTreeNode.left] == null, 0, Heap[Heap[this#264, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#264, AVLTreeNode.right] == null, 0, Heap[Heap[this#264, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
      assert {:msg "  302.5: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#264, AVLTreeNode.left] == null, 0, Heap[Heap[this#264, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#264, AVLTreeNode.right] == null, 0, Heap[Heap[this#264, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
      assert {:msg "  302.5: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  302.5: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_700[this#264, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_700[this#264, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_700[this#264, AVLTreeNode.key][perm$N]));
      exhaleMask#_700[this#264, AVLTreeNode.key] := exhaleMask#_700[this#264, AVLTreeNode.key][perm$R := exhaleMask#_700[this#264, AVLTreeNode.key][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_700);
      assume wf(Heap, exhaleMask#_700, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  302.5: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  302.5: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_700[this#264, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_700[this#264, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_700[this#264, AVLTreeNode.height][perm$N]));
      exhaleMask#_700[this#264, AVLTreeNode.height] := exhaleMask#_700[this#264, AVLTreeNode.height][perm$R := exhaleMask#_700[this#264, AVLTreeNode.height][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_700);
      assume wf(Heap, exhaleMask#_700, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  302.5: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  302.5: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_700[this#264, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_700[this#264, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_700[this#264, AVLTreeNode.left][perm$N]));
      exhaleMask#_700[this#264, AVLTreeNode.left] := exhaleMask#_700[this#264, AVLTreeNode.left][perm$R := exhaleMask#_700[this#264, AVLTreeNode.left][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_700);
      assume wf(Heap, exhaleMask#_700, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  302.5: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  302.5: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_700[this#264, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_700[this#264, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_700[this#264, AVLTreeNode.right][perm$N]));
      exhaleMask#_700[this#264, AVLTreeNode.right] := exhaleMask#_700[this#264, AVLTreeNode.right][perm$R := exhaleMask#_700[this#264, AVLTreeNode.right][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_700);
      assume wf(Heap, exhaleMask#_700, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  302.5: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  302.5: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_700[this#264, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_700[this#264, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_700[this#264, AVLTreeNode.keys][perm$N]));
      exhaleMask#_700[this#264, AVLTreeNode.keys] := exhaleMask#_700[this#264, AVLTreeNode.keys][perm$R := exhaleMask#_700[this#264, AVLTreeNode.keys][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_700);
      assume wf(Heap, exhaleMask#_700, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  302.5: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  302.5: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_700[this#264, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_700[this#264, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_700[this#264, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_700[this#264, AVLTreeNode.balanceFactor] := exhaleMask#_700[this#264, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_700[this#264, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_700);
      assume wf(Heap, exhaleMask#_700, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#264, AVLTreeNode.left] == null)) {
        assert {:msg "  302.5: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
        assert {:msg "  302.5: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_700, SecMask, Heap[this#264, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#264, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_699[Heap[this#264, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_700);
        assume wf(Heap, exhaleMask#_700, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#264, AVLTreeNode.left] == null)) {
        assert {:msg "  302.5: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
        assert {:msg "  302.5: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_700);
        assume wf(Heap, exhaleMask#_700, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#264, AVLTreeNode.left] == null)) {
        assert {:msg "  302.5: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
        assert {:msg "  302.5: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_700);
        assume wf(Heap, exhaleMask#_700, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#264, AVLTreeNode.left] == null)) {
        assert {:msg "  302.5: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
        assert {:msg "  302.5: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_700[Heap[this#264, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_700);
        assume wf(Heap, exhaleMask#_700, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#264, AVLTreeNode.right] == null)) {
        assert {:msg "  302.5: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
        assert {:msg "  302.5: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_700, SecMask, Heap[this#264, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#264, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_699[Heap[this#264, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_700);
        assume wf(Heap, exhaleMask#_700, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#264, AVLTreeNode.right] == null)) {
        assert {:msg "  302.5: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
        assert {:msg "  302.5: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_700);
        assume wf(Heap, exhaleMask#_700, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#264, AVLTreeNode.right] == null)) {
        assert {:msg "  302.5: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
        assert {:msg "  302.5: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_700);
        assume wf(Heap, exhaleMask#_700, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#264, AVLTreeNode.right] == null)) {
        assert {:msg "  302.5: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
        assert {:msg "  302.5: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_700[Heap[this#264, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_700);
        assume wf(Heap, exhaleMask#_700, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_700;
      assume IsGoodExhaleState(exhaleHeap#_699, Heap, Mask, SecMask);
      Heap := exhaleHeap#_699;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      // inhale (postcondition)
      assume this#264 != null;
      assume wf(Heap, Mask, SecMask);
      assume Fractions(100) > 0;
      Mask[this#264, AVLTreeNode.valid] := Mask[this#264, AVLTreeNode.valid][perm$R := Mask[this#264, AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#264, AVLTreeNode.valid]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#264 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[this#264, AVLTreeNode.height] := Mask[this#264, AVLTreeNode.height][perm$R := Mask[this#264, AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#264, AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#264 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[this#264, AVLTreeNode.keys] := Mask[this#264, AVLTreeNode.keys][perm$R := Mask[this#264, AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#264, AVLTreeNode.keys]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#264 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[this#264, AVLTreeNode.balanceFactor] := Mask[this#264, AVLTreeNode.balanceFactor][perm$R := Mask[this#264, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#264, AVLTreeNode.balanceFactor]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume Seq#Equal(Heap[this#264, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_694[this#264, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_694[callHeap#_694[this#264, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_694[this#264, AVLTreeNode.key])), ite(callHeap#_694[this#264, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_694[callHeap#_694[this#264, AVLTreeNode.right], AVLTreeNode.keys])));
      assume Heap[this#264, AVLTreeNode.height] == ite(ite(callHeap#_694[this#264, AVLTreeNode.left] == null, 0, callHeap#_694[callHeap#_694[this#264, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_694[this#264, AVLTreeNode.right] == null, 0, callHeap#_694[callHeap#_694[this#264, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_694[this#264, AVLTreeNode.left] == null, 0, callHeap#_694[callHeap#_694[this#264, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_694[this#264, AVLTreeNode.right] == null, 0, callHeap#_694[callHeap#_694[this#264, AVLTreeNode.right], AVLTreeNode.height]) + 1);
      assume Heap[this#264, AVLTreeNode.balanceFactor] == (ite(callHeap#_694[this#264, AVLTreeNode.left] == null, 0, callHeap#_694[callHeap#_694[this#264, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_694[this#264, AVLTreeNode.right] == null, 0, callHeap#_694[callHeap#_694[this#264, AVLTreeNode.right], AVLTreeNode.height]));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
    }
  } else {
    // if
    cond#_717 := k#19 < Heap[this, AVLTreeNode.key];
    assert {:msg "  305.10: Receiver might be null."} true ==> (this != null);
    assert {:msg "  305.10: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    if (cond#_717) {
      // if
      cond#_718 := !(Heap[this, AVLTreeNode.left] == null);
      assert {:msg "  306.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  306.9: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
      if (cond#_718) {
        // local var nl
        assume (0 < methodCallK#_723) && ((1000 * methodCallK#_723) < Fractions(1)) && ((1000 * methodCallK#_723) < methodK#_506);
        // call remove
        callHeap#_719 := Heap;
        callMask#_720 := Mask;
        callSecMask#_721 := SecMask;
        callCredits#_722 := Credits;
        assume wf(callHeap#_719, callMask#_720, callSecMask#_721);
        assert {:msg "  308.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  308.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
        assert {:msg "  308.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#269 := Heap[this, AVLTreeNode.left];
        k#270 := k#19;
        // begin exhale (precondition)
        exhaleMask#_725 := Mask;
        havoc exhaleHeap#_724;
        assert {:msg "  308.6: The precondition at 254.12 might not hold. The permission at 254.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  308.6: The precondition at 254.12 might not hold. Insufficient fraction at 254.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_725[this#269, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_725[this#269, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_725[this#269, AVLTreeNode.valid][perm$N]));
        exhaleMask#_725[this#269, AVLTreeNode.valid] := exhaleMask#_725[this#269, AVLTreeNode.valid][perm$R := exhaleMask#_725[this#269, AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_725, SecMask, this#269, AVLTreeNode.valid)) {
          assume Heap[this#269, AVLTreeNode.valid] < exhaleHeap#_724[this#269, AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_725);
        assume wf(Heap, exhaleMask#_725, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  308.6: The precondition at 255.12 might not hold. The permission at 255.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  308.6: The precondition at 255.12 might not hold. Insufficient fraction at 255.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_725[this#269, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_725[this#269, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_725[this#269, AVLTreeNode.keys][perm$N]));
        exhaleMask#_725[this#269, AVLTreeNode.keys] := exhaleMask#_725[this#269, AVLTreeNode.keys][perm$R := exhaleMask#_725[this#269, AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_725);
        assume wf(Heap, exhaleMask#_725, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  308.6: The precondition at 256.12 might not hold. The permission at 256.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  308.6: The precondition at 256.12 might not hold. Insufficient fraction at 256.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_725[this#269, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_725[this#269, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_725[this#269, AVLTreeNode.height][perm$N]));
        exhaleMask#_725[this#269, AVLTreeNode.height] := exhaleMask#_725[this#269, AVLTreeNode.height][perm$R := exhaleMask#_725[this#269, AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_725);
        assume wf(Heap, exhaleMask#_725, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  308.6: The precondition at 257.12 might not hold. The permission at 257.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  308.6: The precondition at 257.12 might not hold. Insufficient fraction at 257.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_725[this#269, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_725[this#269, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_725[this#269, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_725[this#269, AVLTreeNode.balanceFactor] := exhaleMask#_725[this#269, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_725[this#269, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_725);
        assume wf(Heap, exhaleMask#_725, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_725;
        assume IsGoodExhaleState(exhaleHeap#_724, Heap, Mask, SecMask);
        Heap := exhaleHeap#_724;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#271;
        // inhale (postcondition)
        if (Seq#Equal(callHeap#_719[this#269, AVLTreeNode.keys], Seq#Singleton(k#270))) {
          assume r#271 == null;
        }
        if (!Seq#Equal(callHeap#_719[this#269, AVLTreeNode.keys], Seq#Singleton(k#270))) {
          assume !(r#271 == null);
        }
        if (!(r#271 == null)) {
          assume r#271 != null;
          assume wf(Heap, Mask, SecMask);
          assume Fractions(100) > 0;
          Mask[r#271, AVLTreeNode.valid] := Mask[r#271, AVLTreeNode.valid][perm$R := Mask[r#271, AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#271, AVLTreeNode.valid]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#271 == null)) {
          assume r#271 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#271, AVLTreeNode.keys] := Mask[r#271, AVLTreeNode.keys][perm$R := Mask[r#271, AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#271, AVLTreeNode.keys]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#271 == null)) {
          assume r#271 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#271, AVLTreeNode.height] := Mask[r#271, AVLTreeNode.height][perm$R := Mask[r#271, AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#271, AVLTreeNode.height]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#271 == null)) {
          assume r#271 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#271, AVLTreeNode.balanceFactor] := Mask[r#271, AVLTreeNode.balanceFactor][perm$R := Mask[r#271, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#271, AVLTreeNode.balanceFactor]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#271 == null)) {
          assume !Seq#Contains(Heap[r#271, AVLTreeNode.keys], k#270);
        }
        if (!(r#271 == null)) {
          assume (forall i#84#272: int :: (0 <= i#84#272) && (i#84#272 < Seq#Length(callHeap#_719[this#269, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#271, AVLTreeNode.keys], Seq#Index(callHeap#_719[this#269, AVLTreeNode.keys], i#84#272)) || (Seq#Index(callHeap#_719[this#269, AVLTreeNode.keys], i#84#272) == k#270)));
        }
        if (!(r#271 == null)) {
          assume (forall i#85#273: int :: (0 <= i#85#273) && (i#85#273 < Seq#Length(Heap[r#271, AVLTreeNode.keys])) ==> Seq#Contains(callHeap#_719[this#269, AVLTreeNode.keys], Seq#Index(Heap[r#271, AVLTreeNode.keys], i#85#273)) && (!(Seq#Index(Heap[r#271, AVLTreeNode.keys], i#85#273) == k#270)));
        }
        if (!Seq#Contains(callHeap#_719[this#269, AVLTreeNode.keys], k#270)) {
          assume !(r#271 == null);
        }
        if (!Seq#Contains(callHeap#_719[this#269, AVLTreeNode.keys], k#270)) {
          assume Seq#Equal(Heap[r#271, AVLTreeNode.keys], callHeap#_719[this#269, AVLTreeNode.keys]);
        }
        if (!(r#271 == null)) {
          if (Seq#Contains(callHeap#_719[this#269, AVLTreeNode.keys], k#270)) {
            assume Seq#Length(Heap[r#271, AVLTreeNode.keys]) == (Seq#Length(callHeap#_719[this#269, AVLTreeNode.keys]) - 1);
          }
        }
        if (callHeap#_719[this#269, AVLTreeNode.height] > 1) {
          assume !(r#271 == null);
        }
        if (!(r#271 == null)) {
          assume (Heap[r#271, AVLTreeNode.height] == callHeap#_719[this#269, AVLTreeNode.height]) || ((Heap[r#271, AVLTreeNode.height] + 1) == callHeap#_719[this#269, AVLTreeNode.height]);
        }
        if (!Seq#Contains(callHeap#_719[this#269, AVLTreeNode.keys], k#270)) {
          assume Heap[r#271, AVLTreeNode.height] == callHeap#_719[this#269, AVLTreeNode.height];
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        nl#28 := r#271;
        // update field left
        assert {:msg "  309.6: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
        Heap[this, AVLTreeNode.left] := nl#28;
        assume wf(Heap, Mask, SecMask);
        // local var bf
        assume (0 < methodCallK#_736) && ((1000 * methodCallK#_736) < Fractions(1)) && ((1000 * methodCallK#_736) < methodK#_506);
        // call getBalanceFactorI
        callHeap#_732 := Heap;
        callMask#_733 := Mask;
        callSecMask#_734 := SecMask;
        callCredits#_735 := Credits;
        assume wf(callHeap#_732, callMask#_733, callSecMask#_734);
        assert {:msg "  312.6: The target of the method call might be null."} this != null;
        this#274 := this;
        // begin exhale (precondition)
        exhaleMask#_738 := Mask;
        havoc exhaleHeap#_737;
        assert {:msg "  312.6: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_736 > 0;
        assert {:msg "  312.6: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_738[this#274, AVLTreeNode.left][perm$R] > 0;
        assume methodCallK#_736 < exhaleMask#_738[this#274, AVLTreeNode.left][perm$R];
        exhaleMask#_738[this#274, AVLTreeNode.left] := exhaleMask#_738[this#274, AVLTreeNode.left][perm$R := exhaleMask#_738[this#274, AVLTreeNode.left][perm$R] - methodCallK#_736];
        assume IsGoodMask(exhaleMask#_738);
        assume wf(Heap, exhaleMask#_738, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#274, AVLTreeNode.left] == null)) {
          assert {:msg "  312.6: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_736 > 0;
          assert {:msg "  312.6: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_738[Heap[this#274, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0;
          assume methodCallK#_736 < exhaleMask#_738[Heap[this#274, AVLTreeNode.left], AVLTreeNode.height][perm$R];
          exhaleMask#_738[Heap[this#274, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_738[Heap[this#274, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_738[Heap[this#274, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_736];
          assume IsGoodMask(exhaleMask#_738);
          assume wf(Heap, exhaleMask#_738, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assert {:msg "  312.6: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_736 > 0;
        assert {:msg "  312.6: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_738[this#274, AVLTreeNode.right][perm$R] > 0;
        assume methodCallK#_736 < exhaleMask#_738[this#274, AVLTreeNode.right][perm$R];
        exhaleMask#_738[this#274, AVLTreeNode.right] := exhaleMask#_738[this#274, AVLTreeNode.right][perm$R := exhaleMask#_738[this#274, AVLTreeNode.right][perm$R] - methodCallK#_736];
        assume IsGoodMask(exhaleMask#_738);
        assume wf(Heap, exhaleMask#_738, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#274, AVLTreeNode.right] == null)) {
          assert {:msg "  312.6: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_736 > 0;
          assert {:msg "  312.6: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_738[Heap[this#274, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0;
          assume methodCallK#_736 < exhaleMask#_738[Heap[this#274, AVLTreeNode.right], AVLTreeNode.height][perm$R];
          exhaleMask#_738[Heap[this#274, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_738[Heap[this#274, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_738[Heap[this#274, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_736];
          assume IsGoodMask(exhaleMask#_738);
          assume wf(Heap, exhaleMask#_738, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#274, AVLTreeNode.left] == null)) {
          assert {:msg "  312.6: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} Fractions(100) > 0;
          assert {:msg "  312.6: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_738[Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_738[Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_738[Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_738[Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_738[Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_738[Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_738, SecMask, Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_737[Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_738);
          assume wf(Heap, exhaleMask#_738, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#274, AVLTreeNode.right] == null)) {
          assert {:msg "  312.6: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} Fractions(100) > 0;
          assert {:msg "  312.6: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_738[Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_738[Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_738[Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_738[Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_738[Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_738[Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_738, SecMask, Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_737[Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_738);
          assume wf(Heap, exhaleMask#_738, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_738;
        assume IsGoodExhaleState(exhaleHeap#_737, Heap, Mask, SecMask);
        Heap := exhaleHeap#_737;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc bf#275;
        // inhale (postcondition)
        assume this#274 != null;
        assume wf(Heap, Mask, SecMask);
        assume (Heap[this#274, AVLTreeNode.left] == null) || (dtype(Heap[this#274, AVLTreeNode.left]) == AVLTreeNode#t);
        assume methodCallK#_736 > 0;
        Mask[this#274, AVLTreeNode.left] := Mask[this#274, AVLTreeNode.left][perm$R := Mask[this#274, AVLTreeNode.left][perm$R] + methodCallK#_736];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#274, AVLTreeNode.left]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#274, AVLTreeNode.left] == null)) {
          assume Heap[this#274, AVLTreeNode.left] != null;
          assume wf(Heap, Mask, SecMask);
          assume Fractions(100) > 0;
          Mask[Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[Heap[this#274, AVLTreeNode.left], AVLTreeNode.valid]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#274, AVLTreeNode.left] == null)) {
          assume Heap[this#274, AVLTreeNode.left] != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume methodCallK#_736 > 0;
          Mask[Heap[this#274, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#274, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#274, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_736];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[Heap[this#274, AVLTreeNode.left], AVLTreeNode.height]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume this#274 != null;
        assume wf(Heap, Mask, SecMask);
        assume (Heap[this#274, AVLTreeNode.right] == null) || (dtype(Heap[this#274, AVLTreeNode.right]) == AVLTreeNode#t);
        assume methodCallK#_736 > 0;
        Mask[this#274, AVLTreeNode.right] := Mask[this#274, AVLTreeNode.right][perm$R := Mask[this#274, AVLTreeNode.right][perm$R] + methodCallK#_736];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#274, AVLTreeNode.right]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#274, AVLTreeNode.right] == null)) {
          assume Heap[this#274, AVLTreeNode.right] != null;
          assume wf(Heap, Mask, SecMask);
          assume Fractions(100) > 0;
          Mask[Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[Heap[this#274, AVLTreeNode.right], AVLTreeNode.valid]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#274, AVLTreeNode.right] == null)) {
          assume Heap[this#274, AVLTreeNode.right] != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume methodCallK#_736 > 0;
          Mask[Heap[this#274, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#274, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#274, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_736];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[Heap[this#274, AVLTreeNode.right], AVLTreeNode.height]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume bf#275 == (ite(Heap[this#274, AVLTreeNode.left] == null, 0, Heap[Heap[this#274, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#274, AVLTreeNode.right] == null, 0, Heap[Heap[this#274, AVLTreeNode.right], AVLTreeNode.height]));
        if (bf#275 > 0) {
          assume !(Heap[this#274, AVLTreeNode.left] == null);
        }
        if (bf#275 < 0) {
          assume !(Heap[this#274, AVLTreeNode.right] == null);
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        bf#30 := bf#275;
        // if
        cond#_747 := bf#30 == (0 - 2);
        if (cond#_747) {
          assume (0 < methodCallK#_752) && ((1000 * methodCallK#_752) < Fractions(1)) && ((1000 * methodCallK#_752) < methodK#_506);
          // call rebalanceRight
          callHeap#_748 := Heap;
          callMask#_749 := Mask;
          callSecMask#_750 := SecMask;
          callCredits#_751 := Credits;
          assume wf(callHeap#_748, callMask#_749, callSecMask#_750);
          assert {:msg "  315.7: The target of the method call might be null."} this != null;
          this#276 := this;
          // begin exhale (precondition)
          exhaleMask#_754 := Mask;
          havoc exhaleHeap#_753;
          if (!(Heap[this#276, AVLTreeNode.left] == null)) {
            assert {:msg "  315.7: The precondition at 758.12 might not hold. The expression at 758.25 might not evaluate to true."} (forall k#104#278: int :: (0 <= k#104#278) && (k#104#278 < Seq#Length(Heap[Heap[this#276, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#276, AVLTreeNode.left], AVLTreeNode.keys], k#104#278) < Heap[this#276, AVLTreeNode.key]));
          }
          assert {:msg "  315.7: The precondition at 760.12 might not hold. The expression at 760.12 might not evaluate to true."} !(Heap[this#276, AVLTreeNode.right] == null);
          assert {:msg "  315.7: The precondition at 765.12 might not hold. The expression at 765.12 might not evaluate to true."} (forall k#105#279: int :: (0 <= k#105#279) && (k#105#279 < Seq#Length(Heap[Heap[this#276, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#276, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#276, AVLTreeNode.right], AVLTreeNode.keys], k#105#279)));
          assert {:msg "  315.7: The precondition at 768.12 might not hold. The expression at 768.12 might not evaluate to true."} (ite(Heap[this#276, AVLTreeNode.left] == null, 0, Heap[Heap[this#276, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#276, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
          assert {:msg "  315.7: The precondition at 746.12 might not hold. The permission at 746.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  315.7: The precondition at 746.12 might not hold. Insufficient fraction at 746.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_754[this#276, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_754[this#276, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_754[this#276, AVLTreeNode.key][perm$N]));
          exhaleMask#_754[this#276, AVLTreeNode.key] := exhaleMask#_754[this#276, AVLTreeNode.key][perm$R := exhaleMask#_754[this#276, AVLTreeNode.key][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_754);
          assume wf(Heap, exhaleMask#_754, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 747.12 might not hold. The permission at 747.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  315.7: The precondition at 747.12 might not hold. Insufficient fraction at 747.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_754[this#276, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_754[this#276, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_754[this#276, AVLTreeNode.height][perm$N]));
          exhaleMask#_754[this#276, AVLTreeNode.height] := exhaleMask#_754[this#276, AVLTreeNode.height][perm$R := exhaleMask#_754[this#276, AVLTreeNode.height][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_754);
          assume wf(Heap, exhaleMask#_754, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 748.12 might not hold. The permission at 748.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  315.7: The precondition at 748.12 might not hold. Insufficient fraction at 748.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_754[this#276, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_754[this#276, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_754[this#276, AVLTreeNode.left][perm$N]));
          exhaleMask#_754[this#276, AVLTreeNode.left] := exhaleMask#_754[this#276, AVLTreeNode.left][perm$R := exhaleMask#_754[this#276, AVLTreeNode.left][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_754);
          assume wf(Heap, exhaleMask#_754, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 749.12 might not hold. The permission at 749.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  315.7: The precondition at 749.12 might not hold. Insufficient fraction at 749.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_754[this#276, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_754[this#276, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_754[this#276, AVLTreeNode.right][perm$N]));
          exhaleMask#_754[this#276, AVLTreeNode.right] := exhaleMask#_754[this#276, AVLTreeNode.right][perm$R := exhaleMask#_754[this#276, AVLTreeNode.right][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_754);
          assume wf(Heap, exhaleMask#_754, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 751.12 might not hold. The permission at 751.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  315.7: The precondition at 751.12 might not hold. Insufficient fraction at 751.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_754[this#276, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_754[this#276, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_754[this#276, AVLTreeNode.keys][perm$N]));
          exhaleMask#_754[this#276, AVLTreeNode.keys] := exhaleMask#_754[this#276, AVLTreeNode.keys][perm$R := exhaleMask#_754[this#276, AVLTreeNode.keys][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_754);
          assume wf(Heap, exhaleMask#_754, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 752.12 might not hold. The permission at 752.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  315.7: The precondition at 752.12 might not hold. Insufficient fraction at 752.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_754[this#276, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_754[this#276, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_754[this#276, AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_754[this#276, AVLTreeNode.balanceFactor] := exhaleMask#_754[this#276, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_754[this#276, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_754);
          assume wf(Heap, exhaleMask#_754, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[this#276, AVLTreeNode.left] == null)) {
            assert {:msg "  315.7: The precondition at 754.12 might not hold. The permission at 754.25 might not be positive."} Fractions(100) > 0;
            assert {:msg "  315.7: The precondition at 754.12 might not hold. Insufficient fraction at 754.25 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
            exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (!CanRead(exhaleMask#_754, SecMask, Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid)) {
              assume Heap[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_753[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid];
            }
            assume IsGoodMask(exhaleMask#_754);
            assume wf(Heap, exhaleMask#_754, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#276, AVLTreeNode.left] == null)) {
            assert {:msg "  315.7: The precondition at 755.12 might not hold. The permission at 755.25 might not be positive."} Fractions(50) > 0;
            assert {:msg "  315.7: The precondition at 755.12 might not hold. Insufficient fraction at 755.25 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
            exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_754);
            assume wf(Heap, exhaleMask#_754, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#276, AVLTreeNode.left] == null)) {
            assert {:msg "  315.7: The precondition at 756.12 might not hold. The permission at 756.25 might not be positive."} Fractions(50) > 0;
            assert {:msg "  315.7: The precondition at 756.12 might not hold. Insufficient fraction at 756.25 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
            exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_754);
            assume wf(Heap, exhaleMask#_754, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#276, AVLTreeNode.left] == null)) {
            assert {:msg "  315.7: The precondition at 757.12 might not hold. The permission at 757.25 might not be positive."} Fractions(50) > 0;
            assert {:msg "  315.7: The precondition at 757.12 might not hold. Insufficient fraction at 757.25 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_754[Heap[this#276, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_754);
            assume wf(Heap, exhaleMask#_754, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          assert {:msg "  315.7: The precondition at 761.12 might not hold. The permission at 761.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  315.7: The precondition at 761.12 might not hold. Insufficient fraction at 761.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_754, SecMask, Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_753[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_754);
          assume wf(Heap, exhaleMask#_754, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 762.12 might not hold. The permission at 762.12 might not be positive."} Fractions(50) > 0;
          assert {:msg "  315.7: The precondition at 762.12 might not hold. Insufficient fraction at 762.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_754);
          assume wf(Heap, exhaleMask#_754, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 763.12 might not hold. The permission at 763.12 might not be positive."} Fractions(50) > 0;
          assert {:msg "  315.7: The precondition at 763.12 might not hold. Insufficient fraction at 763.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_754);
          assume wf(Heap, exhaleMask#_754, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 764.12 might not hold. The permission at 764.12 might not be positive."} Fractions(50) > 0;
          assert {:msg "  315.7: The precondition at 764.12 might not hold. Insufficient fraction at 764.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_754[Heap[this#276, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_754);
          assume wf(Heap, exhaleMask#_754, SecMask);
          assume wf(Heap, Mask, SecMask);
          Mask := exhaleMask#_754;
          assume IsGoodExhaleState(exhaleHeap#_753, Heap, Mask, SecMask);
          Heap := exhaleHeap#_753;
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end exhale
          havoc r#277;
          // inhale (postcondition)
          assume !(r#277 == null);
          assume r#277 != null;
          assume wf(Heap, Mask, SecMask);
          assume Fractions(100) > 0;
          Mask[r#277, AVLTreeNode.valid] := Mask[r#277, AVLTreeNode.valid][perm$R := Mask[r#277, AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#277, AVLTreeNode.valid]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume r#277 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#277, AVLTreeNode.height] := Mask[r#277, AVLTreeNode.height][perm$R := Mask[r#277, AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#277, AVLTreeNode.height]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume r#277 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#277, AVLTreeNode.keys] := Mask[r#277, AVLTreeNode.keys][perm$R := Mask[r#277, AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#277, AVLTreeNode.keys]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume r#277 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#277, AVLTreeNode.balanceFactor] := Mask[r#277, AVLTreeNode.balanceFactor][perm$R := Mask[r#277, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#277, AVLTreeNode.balanceFactor]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume (Heap[r#277, AVLTreeNode.height] == callHeap#_748[callHeap#_748[this#276, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#277, AVLTreeNode.height] == (callHeap#_748[callHeap#_748[this#276, AVLTreeNode.right], AVLTreeNode.height] + 1));
          assume Seq#Equal(Heap[r#277, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_748[this#276, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_748[callHeap#_748[this#276, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_748[this#276, AVLTreeNode.key])), callHeap#_748[callHeap#_748[this#276, AVLTreeNode.right], AVLTreeNode.keys]));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end inhale
          r#20 := r#277;
        } else {
          assume (0 < methodCallK#_775) && ((1000 * methodCallK#_775) < Fractions(1)) && ((1000 * methodCallK#_775) < methodK#_506);
          // call close
          callHeap#_771 := Heap;
          callMask#_772 := Mask;
          callSecMask#_773 := SecMask;
          callCredits#_774 := Credits;
          assume wf(callHeap#_771, callMask#_772, callSecMask#_773);
          assert {:msg "  317.7: The target of the method call might be null."} this != null;
          this#282 := this;
          // begin exhale (precondition)
          exhaleMask#_777 := Mask;
          havoc exhaleHeap#_776;
          if (!(Heap[this#282, AVLTreeNode.left] == null)) {
            assert {:msg "  317.7: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#283: int :: (0 <= k#92#283) && (k#92#283 < Seq#Length(Heap[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys], k#92#283) < Heap[this#282, AVLTreeNode.key]));
          }
          if (!(Heap[this#282, AVLTreeNode.right] == null)) {
            assert {:msg "  317.7: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#284: int :: (0 <= k#93#284) && (k#93#284 < Seq#Length(Heap[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#282, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys], k#93#284)));
          }
          assert {:msg "  317.7: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#282, AVLTreeNode.left] == null, 0, Heap[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#282, AVLTreeNode.right] == null, 0, Heap[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
          assert {:msg "  317.7: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#282, AVLTreeNode.left] == null, 0, Heap[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#282, AVLTreeNode.right] == null, 0, Heap[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
          assert {:msg "  317.7: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  317.7: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_777[this#282, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_777[this#282, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_777[this#282, AVLTreeNode.key][perm$N]));
          exhaleMask#_777[this#282, AVLTreeNode.key] := exhaleMask#_777[this#282, AVLTreeNode.key][perm$R := exhaleMask#_777[this#282, AVLTreeNode.key][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_777);
          assume wf(Heap, exhaleMask#_777, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  317.7: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  317.7: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_777[this#282, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_777[this#282, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_777[this#282, AVLTreeNode.height][perm$N]));
          exhaleMask#_777[this#282, AVLTreeNode.height] := exhaleMask#_777[this#282, AVLTreeNode.height][perm$R := exhaleMask#_777[this#282, AVLTreeNode.height][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_777);
          assume wf(Heap, exhaleMask#_777, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  317.7: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  317.7: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_777[this#282, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_777[this#282, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_777[this#282, AVLTreeNode.left][perm$N]));
          exhaleMask#_777[this#282, AVLTreeNode.left] := exhaleMask#_777[this#282, AVLTreeNode.left][perm$R := exhaleMask#_777[this#282, AVLTreeNode.left][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_777);
          assume wf(Heap, exhaleMask#_777, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  317.7: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  317.7: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_777[this#282, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_777[this#282, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_777[this#282, AVLTreeNode.right][perm$N]));
          exhaleMask#_777[this#282, AVLTreeNode.right] := exhaleMask#_777[this#282, AVLTreeNode.right][perm$R := exhaleMask#_777[this#282, AVLTreeNode.right][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_777);
          assume wf(Heap, exhaleMask#_777, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  317.7: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  317.7: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_777[this#282, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_777[this#282, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_777[this#282, AVLTreeNode.keys][perm$N]));
          exhaleMask#_777[this#282, AVLTreeNode.keys] := exhaleMask#_777[this#282, AVLTreeNode.keys][perm$R := exhaleMask#_777[this#282, AVLTreeNode.keys][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_777);
          assume wf(Heap, exhaleMask#_777, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  317.7: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  317.7: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_777[this#282, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_777[this#282, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_777[this#282, AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_777[this#282, AVLTreeNode.balanceFactor] := exhaleMask#_777[this#282, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_777[this#282, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_777);
          assume wf(Heap, exhaleMask#_777, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[this#282, AVLTreeNode.left] == null)) {
            assert {:msg "  317.7: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
            assert {:msg "  317.7: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
            exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (!CanRead(exhaleMask#_777, SecMask, Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid)) {
              assume Heap[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_776[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid];
            }
            assume IsGoodMask(exhaleMask#_777);
            assume wf(Heap, exhaleMask#_777, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#282, AVLTreeNode.left] == null)) {
            assert {:msg "  317.7: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
            assert {:msg "  317.7: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
            exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_777);
            assume wf(Heap, exhaleMask#_777, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#282, AVLTreeNode.left] == null)) {
            assert {:msg "  317.7: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
            assert {:msg "  317.7: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
            exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_777);
            assume wf(Heap, exhaleMask#_777, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#282, AVLTreeNode.left] == null)) {
            assert {:msg "  317.7: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
            assert {:msg "  317.7: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_777[Heap[this#282, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_777);
            assume wf(Heap, exhaleMask#_777, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#282, AVLTreeNode.right] == null)) {
            assert {:msg "  317.7: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
            assert {:msg "  317.7: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
            exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (!CanRead(exhaleMask#_777, SecMask, Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid)) {
              assume Heap[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_776[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid];
            }
            assume IsGoodMask(exhaleMask#_777);
            assume wf(Heap, exhaleMask#_777, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#282, AVLTreeNode.right] == null)) {
            assert {:msg "  317.7: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
            assert {:msg "  317.7: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
            exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_777);
            assume wf(Heap, exhaleMask#_777, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#282, AVLTreeNode.right] == null)) {
            assert {:msg "  317.7: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
            assert {:msg "  317.7: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
            exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_777);
            assume wf(Heap, exhaleMask#_777, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#282, AVLTreeNode.right] == null)) {
            assert {:msg "  317.7: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
            assert {:msg "  317.7: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_777[Heap[this#282, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_777);
            assume wf(Heap, exhaleMask#_777, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          Mask := exhaleMask#_777;
          assume IsGoodExhaleState(exhaleHeap#_776, Heap, Mask, SecMask);
          Heap := exhaleHeap#_776;
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end exhale
          // inhale (postcondition)
          assume this#282 != null;
          assume wf(Heap, Mask, SecMask);
          assume Fractions(100) > 0;
          Mask[this#282, AVLTreeNode.valid] := Mask[this#282, AVLTreeNode.valid][perm$R := Mask[this#282, AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[this#282, AVLTreeNode.valid]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume this#282 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[this#282, AVLTreeNode.height] := Mask[this#282, AVLTreeNode.height][perm$R := Mask[this#282, AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[this#282, AVLTreeNode.height]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume this#282 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[this#282, AVLTreeNode.keys] := Mask[this#282, AVLTreeNode.keys][perm$R := Mask[this#282, AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[this#282, AVLTreeNode.keys]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume this#282 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[this#282, AVLTreeNode.balanceFactor] := Mask[this#282, AVLTreeNode.balanceFactor][perm$R := Mask[this#282, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[this#282, AVLTreeNode.balanceFactor]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume Seq#Equal(Heap[this#282, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_771[this#282, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_771[callHeap#_771[this#282, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_771[this#282, AVLTreeNode.key])), ite(callHeap#_771[this#282, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_771[callHeap#_771[this#282, AVLTreeNode.right], AVLTreeNode.keys])));
          assume Heap[this#282, AVLTreeNode.height] == ite(ite(callHeap#_771[this#282, AVLTreeNode.left] == null, 0, callHeap#_771[callHeap#_771[this#282, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_771[this#282, AVLTreeNode.right] == null, 0, callHeap#_771[callHeap#_771[this#282, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_771[this#282, AVLTreeNode.left] == null, 0, callHeap#_771[callHeap#_771[this#282, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_771[this#282, AVLTreeNode.right] == null, 0, callHeap#_771[callHeap#_771[this#282, AVLTreeNode.right], AVLTreeNode.height]) + 1);
          assume Heap[this#282, AVLTreeNode.balanceFactor] == (ite(callHeap#_771[this#282, AVLTreeNode.left] == null, 0, callHeap#_771[callHeap#_771[this#282, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_771[this#282, AVLTreeNode.right] == null, 0, callHeap#_771[callHeap#_771[this#282, AVLTreeNode.right], AVLTreeNode.height]));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end inhale
          // assigment to r
          r#20 := this;
        }
      } else {
        // assigment to r
        r#20 := this;
        assume (0 < methodCallK#_798) && ((1000 * methodCallK#_798) < Fractions(1)) && ((1000 * methodCallK#_798) < methodK#_506);
        // call close
        callHeap#_794 := Heap;
        callMask#_795 := Mask;
        callSecMask#_796 := SecMask;
        callCredits#_797 := Credits;
        assume wf(callHeap#_794, callMask#_795, callSecMask#_796);
        assert {:msg "  322.6: The target of the method call might be null."} r#20 != null;
        this#287 := r#20;
        // begin exhale (precondition)
        exhaleMask#_800 := Mask;
        havoc exhaleHeap#_799;
        if (!(Heap[this#287, AVLTreeNode.left] == null)) {
          assert {:msg "  322.6: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#288: int :: (0 <= k#92#288) && (k#92#288 < Seq#Length(Heap[Heap[this#287, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#287, AVLTreeNode.left], AVLTreeNode.keys], k#92#288) < Heap[this#287, AVLTreeNode.key]));
        }
        if (!(Heap[this#287, AVLTreeNode.right] == null)) {
          assert {:msg "  322.6: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#289: int :: (0 <= k#93#289) && (k#93#289 < Seq#Length(Heap[Heap[this#287, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#287, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#287, AVLTreeNode.right], AVLTreeNode.keys], k#93#289)));
        }
        assert {:msg "  322.6: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#287, AVLTreeNode.left] == null, 0, Heap[Heap[this#287, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#287, AVLTreeNode.right] == null, 0, Heap[Heap[this#287, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
        assert {:msg "  322.6: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#287, AVLTreeNode.left] == null, 0, Heap[Heap[this#287, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#287, AVLTreeNode.right] == null, 0, Heap[Heap[this#287, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
        assert {:msg "  322.6: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  322.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_800[this#287, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_800[this#287, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_800[this#287, AVLTreeNode.key][perm$N]));
        exhaleMask#_800[this#287, AVLTreeNode.key] := exhaleMask#_800[this#287, AVLTreeNode.key][perm$R := exhaleMask#_800[this#287, AVLTreeNode.key][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_800);
        assume wf(Heap, exhaleMask#_800, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  322.6: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  322.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_800[this#287, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_800[this#287, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_800[this#287, AVLTreeNode.height][perm$N]));
        exhaleMask#_800[this#287, AVLTreeNode.height] := exhaleMask#_800[this#287, AVLTreeNode.height][perm$R := exhaleMask#_800[this#287, AVLTreeNode.height][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_800);
        assume wf(Heap, exhaleMask#_800, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  322.6: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  322.6: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_800[this#287, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_800[this#287, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_800[this#287, AVLTreeNode.left][perm$N]));
        exhaleMask#_800[this#287, AVLTreeNode.left] := exhaleMask#_800[this#287, AVLTreeNode.left][perm$R := exhaleMask#_800[this#287, AVLTreeNode.left][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_800);
        assume wf(Heap, exhaleMask#_800, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  322.6: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  322.6: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_800[this#287, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_800[this#287, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_800[this#287, AVLTreeNode.right][perm$N]));
        exhaleMask#_800[this#287, AVLTreeNode.right] := exhaleMask#_800[this#287, AVLTreeNode.right][perm$R := exhaleMask#_800[this#287, AVLTreeNode.right][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_800);
        assume wf(Heap, exhaleMask#_800, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  322.6: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  322.6: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_800[this#287, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_800[this#287, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_800[this#287, AVLTreeNode.keys][perm$N]));
        exhaleMask#_800[this#287, AVLTreeNode.keys] := exhaleMask#_800[this#287, AVLTreeNode.keys][perm$R := exhaleMask#_800[this#287, AVLTreeNode.keys][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_800);
        assume wf(Heap, exhaleMask#_800, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  322.6: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  322.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_800[this#287, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_800[this#287, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_800[this#287, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_800[this#287, AVLTreeNode.balanceFactor] := exhaleMask#_800[this#287, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_800[this#287, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_800);
        assume wf(Heap, exhaleMask#_800, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#287, AVLTreeNode.left] == null)) {
          assert {:msg "  322.6: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
          assert {:msg "  322.6: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_800, SecMask, Heap[this#287, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#287, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_799[Heap[this#287, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_800);
          assume wf(Heap, exhaleMask#_800, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#287, AVLTreeNode.left] == null)) {
          assert {:msg "  322.6: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
          assert {:msg "  322.6: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_800);
          assume wf(Heap, exhaleMask#_800, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#287, AVLTreeNode.left] == null)) {
          assert {:msg "  322.6: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
          assert {:msg "  322.6: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_800);
          assume wf(Heap, exhaleMask#_800, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#287, AVLTreeNode.left] == null)) {
          assert {:msg "  322.6: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
          assert {:msg "  322.6: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_800[Heap[this#287, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_800);
          assume wf(Heap, exhaleMask#_800, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#287, AVLTreeNode.right] == null)) {
          assert {:msg "  322.6: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
          assert {:msg "  322.6: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_800, SecMask, Heap[this#287, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#287, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_799[Heap[this#287, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_800);
          assume wf(Heap, exhaleMask#_800, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#287, AVLTreeNode.right] == null)) {
          assert {:msg "  322.6: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  322.6: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_800);
          assume wf(Heap, exhaleMask#_800, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#287, AVLTreeNode.right] == null)) {
          assert {:msg "  322.6: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  322.6: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_800);
          assume wf(Heap, exhaleMask#_800, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#287, AVLTreeNode.right] == null)) {
          assert {:msg "  322.6: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  322.6: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_800[Heap[this#287, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_800);
          assume wf(Heap, exhaleMask#_800, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_800;
        assume IsGoodExhaleState(exhaleHeap#_799, Heap, Mask, SecMask);
        Heap := exhaleHeap#_799;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        // inhale (postcondition)
        assume this#287 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[this#287, AVLTreeNode.valid] := Mask[this#287, AVLTreeNode.valid][perm$R := Mask[this#287, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#287, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#287 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#287, AVLTreeNode.height] := Mask[this#287, AVLTreeNode.height][perm$R := Mask[this#287, AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#287, AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#287 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#287, AVLTreeNode.keys] := Mask[this#287, AVLTreeNode.keys][perm$R := Mask[this#287, AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#287, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#287 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#287, AVLTreeNode.balanceFactor] := Mask[this#287, AVLTreeNode.balanceFactor][perm$R := Mask[this#287, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#287, AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Seq#Equal(Heap[this#287, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_794[this#287, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_794[callHeap#_794[this#287, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_794[this#287, AVLTreeNode.key])), ite(callHeap#_794[this#287, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_794[callHeap#_794[this#287, AVLTreeNode.right], AVLTreeNode.keys])));
        assume Heap[this#287, AVLTreeNode.height] == ite(ite(callHeap#_794[this#287, AVLTreeNode.left] == null, 0, callHeap#_794[callHeap#_794[this#287, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_794[this#287, AVLTreeNode.right] == null, 0, callHeap#_794[callHeap#_794[this#287, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_794[this#287, AVLTreeNode.left] == null, 0, callHeap#_794[callHeap#_794[this#287, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_794[this#287, AVLTreeNode.right] == null, 0, callHeap#_794[callHeap#_794[this#287, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume Heap[this#287, AVLTreeNode.balanceFactor] == (ite(callHeap#_794[this#287, AVLTreeNode.left] == null, 0, callHeap#_794[callHeap#_794[this#287, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_794[this#287, AVLTreeNode.right] == null, 0, callHeap#_794[callHeap#_794[this#287, AVLTreeNode.right], AVLTreeNode.height]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
      }
    } else {
      // if
      cond#_817 := !(Heap[this, AVLTreeNode.right] == null);
      assert {:msg "  325.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  325.9: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
      if (cond#_817) {
        // local var nr
        assume (0 < methodCallK#_822) && ((1000 * methodCallK#_822) < Fractions(1)) && ((1000 * methodCallK#_822) < methodK#_506);
        // call remove
        callHeap#_818 := Heap;
        callMask#_819 := Mask;
        callSecMask#_820 := SecMask;
        callCredits#_821 := Credits;
        assume wf(callHeap#_818, callMask#_819, callSecMask#_820);
        assert {:msg "  327.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  327.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
        assert {:msg "  327.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#292 := Heap[this, AVLTreeNode.right];
        k#293 := k#19;
        // begin exhale (precondition)
        exhaleMask#_824 := Mask;
        havoc exhaleHeap#_823;
        assert {:msg "  327.6: The precondition at 254.12 might not hold. The permission at 254.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  327.6: The precondition at 254.12 might not hold. Insufficient fraction at 254.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_824[this#292, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_824[this#292, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_824[this#292, AVLTreeNode.valid][perm$N]));
        exhaleMask#_824[this#292, AVLTreeNode.valid] := exhaleMask#_824[this#292, AVLTreeNode.valid][perm$R := exhaleMask#_824[this#292, AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_824, SecMask, this#292, AVLTreeNode.valid)) {
          assume Heap[this#292, AVLTreeNode.valid] < exhaleHeap#_823[this#292, AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_824);
        assume wf(Heap, exhaleMask#_824, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  327.6: The precondition at 255.12 might not hold. The permission at 255.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  327.6: The precondition at 255.12 might not hold. Insufficient fraction at 255.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_824[this#292, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_824[this#292, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_824[this#292, AVLTreeNode.keys][perm$N]));
        exhaleMask#_824[this#292, AVLTreeNode.keys] := exhaleMask#_824[this#292, AVLTreeNode.keys][perm$R := exhaleMask#_824[this#292, AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_824);
        assume wf(Heap, exhaleMask#_824, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  327.6: The precondition at 256.12 might not hold. The permission at 256.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  327.6: The precondition at 256.12 might not hold. Insufficient fraction at 256.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_824[this#292, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_824[this#292, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_824[this#292, AVLTreeNode.height][perm$N]));
        exhaleMask#_824[this#292, AVLTreeNode.height] := exhaleMask#_824[this#292, AVLTreeNode.height][perm$R := exhaleMask#_824[this#292, AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_824);
        assume wf(Heap, exhaleMask#_824, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  327.6: The precondition at 257.12 might not hold. The permission at 257.12 might not be positive."} Fractions(50) > 0;
        assert {:msg "  327.6: The precondition at 257.12 might not hold. Insufficient fraction at 257.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_824[this#292, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_824[this#292, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_824[this#292, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_824[this#292, AVLTreeNode.balanceFactor] := exhaleMask#_824[this#292, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_824[this#292, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_824);
        assume wf(Heap, exhaleMask#_824, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_824;
        assume IsGoodExhaleState(exhaleHeap#_823, Heap, Mask, SecMask);
        Heap := exhaleHeap#_823;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#294;
        // inhale (postcondition)
        if (Seq#Equal(callHeap#_818[this#292, AVLTreeNode.keys], Seq#Singleton(k#293))) {
          assume r#294 == null;
        }
        if (!Seq#Equal(callHeap#_818[this#292, AVLTreeNode.keys], Seq#Singleton(k#293))) {
          assume !(r#294 == null);
        }
        if (!(r#294 == null)) {
          assume r#294 != null;
          assume wf(Heap, Mask, SecMask);
          assume Fractions(100) > 0;
          Mask[r#294, AVLTreeNode.valid] := Mask[r#294, AVLTreeNode.valid][perm$R := Mask[r#294, AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#294, AVLTreeNode.valid]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#294 == null)) {
          assume r#294 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#294, AVLTreeNode.keys] := Mask[r#294, AVLTreeNode.keys][perm$R := Mask[r#294, AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#294, AVLTreeNode.keys]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#294 == null)) {
          assume r#294 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#294, AVLTreeNode.height] := Mask[r#294, AVLTreeNode.height][perm$R := Mask[r#294, AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#294, AVLTreeNode.height]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#294 == null)) {
          assume r#294 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#294, AVLTreeNode.balanceFactor] := Mask[r#294, AVLTreeNode.balanceFactor][perm$R := Mask[r#294, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#294, AVLTreeNode.balanceFactor]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#294 == null)) {
          assume !Seq#Contains(Heap[r#294, AVLTreeNode.keys], k#293);
        }
        if (!(r#294 == null)) {
          assume (forall i#84#295: int :: (0 <= i#84#295) && (i#84#295 < Seq#Length(callHeap#_818[this#292, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#294, AVLTreeNode.keys], Seq#Index(callHeap#_818[this#292, AVLTreeNode.keys], i#84#295)) || (Seq#Index(callHeap#_818[this#292, AVLTreeNode.keys], i#84#295) == k#293)));
        }
        if (!(r#294 == null)) {
          assume (forall i#85#296: int :: (0 <= i#85#296) && (i#85#296 < Seq#Length(Heap[r#294, AVLTreeNode.keys])) ==> Seq#Contains(callHeap#_818[this#292, AVLTreeNode.keys], Seq#Index(Heap[r#294, AVLTreeNode.keys], i#85#296)) && (!(Seq#Index(Heap[r#294, AVLTreeNode.keys], i#85#296) == k#293)));
        }
        if (!Seq#Contains(callHeap#_818[this#292, AVLTreeNode.keys], k#293)) {
          assume !(r#294 == null);
        }
        if (!Seq#Contains(callHeap#_818[this#292, AVLTreeNode.keys], k#293)) {
          assume Seq#Equal(Heap[r#294, AVLTreeNode.keys], callHeap#_818[this#292, AVLTreeNode.keys]);
        }
        if (!(r#294 == null)) {
          if (Seq#Contains(callHeap#_818[this#292, AVLTreeNode.keys], k#293)) {
            assume Seq#Length(Heap[r#294, AVLTreeNode.keys]) == (Seq#Length(callHeap#_818[this#292, AVLTreeNode.keys]) - 1);
          }
        }
        if (callHeap#_818[this#292, AVLTreeNode.height] > 1) {
          assume !(r#294 == null);
        }
        if (!(r#294 == null)) {
          assume (Heap[r#294, AVLTreeNode.height] == callHeap#_818[this#292, AVLTreeNode.height]) || ((Heap[r#294, AVLTreeNode.height] + 1) == callHeap#_818[this#292, AVLTreeNode.height]);
        }
        if (!Seq#Contains(callHeap#_818[this#292, AVLTreeNode.keys], k#293)) {
          assume Heap[r#294, AVLTreeNode.height] == callHeap#_818[this#292, AVLTreeNode.height];
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        nr#32 := r#294;
        // update field right
        assert {:msg "  328.6: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
        Heap[this, AVLTreeNode.right] := nr#32;
        assume wf(Heap, Mask, SecMask);
        // local var bf
        assume (0 < methodCallK#_835) && ((1000 * methodCallK#_835) < Fractions(1)) && ((1000 * methodCallK#_835) < methodK#_506);
        // call getBalanceFactorI
        callHeap#_831 := Heap;
        callMask#_832 := Mask;
        callSecMask#_833 := SecMask;
        callCredits#_834 := Credits;
        assume wf(callHeap#_831, callMask#_832, callSecMask#_833);
        assert {:msg "  331.6: The target of the method call might be null."} this != null;
        this#297 := this;
        // begin exhale (precondition)
        exhaleMask#_837 := Mask;
        havoc exhaleHeap#_836;
        assert {:msg "  331.6: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_835 > 0;
        assert {:msg "  331.6: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_837[this#297, AVLTreeNode.left][perm$R] > 0;
        assume methodCallK#_835 < exhaleMask#_837[this#297, AVLTreeNode.left][perm$R];
        exhaleMask#_837[this#297, AVLTreeNode.left] := exhaleMask#_837[this#297, AVLTreeNode.left][perm$R := exhaleMask#_837[this#297, AVLTreeNode.left][perm$R] - methodCallK#_835];
        assume IsGoodMask(exhaleMask#_837);
        assume wf(Heap, exhaleMask#_837, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#297, AVLTreeNode.left] == null)) {
          assert {:msg "  331.6: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_835 > 0;
          assert {:msg "  331.6: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_837[Heap[this#297, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0;
          assume methodCallK#_835 < exhaleMask#_837[Heap[this#297, AVLTreeNode.left], AVLTreeNode.height][perm$R];
          exhaleMask#_837[Heap[this#297, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_837[Heap[this#297, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_837[Heap[this#297, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_835];
          assume IsGoodMask(exhaleMask#_837);
          assume wf(Heap, exhaleMask#_837, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assert {:msg "  331.6: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_835 > 0;
        assert {:msg "  331.6: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_837[this#297, AVLTreeNode.right][perm$R] > 0;
        assume methodCallK#_835 < exhaleMask#_837[this#297, AVLTreeNode.right][perm$R];
        exhaleMask#_837[this#297, AVLTreeNode.right] := exhaleMask#_837[this#297, AVLTreeNode.right][perm$R := exhaleMask#_837[this#297, AVLTreeNode.right][perm$R] - methodCallK#_835];
        assume IsGoodMask(exhaleMask#_837);
        assume wf(Heap, exhaleMask#_837, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#297, AVLTreeNode.right] == null)) {
          assert {:msg "  331.6: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_835 > 0;
          assert {:msg "  331.6: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_837[Heap[this#297, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0;
          assume methodCallK#_835 < exhaleMask#_837[Heap[this#297, AVLTreeNode.right], AVLTreeNode.height][perm$R];
          exhaleMask#_837[Heap[this#297, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_837[Heap[this#297, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_837[Heap[this#297, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_835];
          assume IsGoodMask(exhaleMask#_837);
          assume wf(Heap, exhaleMask#_837, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#297, AVLTreeNode.left] == null)) {
          assert {:msg "  331.6: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} Fractions(100) > 0;
          assert {:msg "  331.6: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_837[Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_837[Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_837[Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_837[Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_837[Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_837[Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_837, SecMask, Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_836[Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_837);
          assume wf(Heap, exhaleMask#_837, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#297, AVLTreeNode.right] == null)) {
          assert {:msg "  331.6: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} Fractions(100) > 0;
          assert {:msg "  331.6: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_837[Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_837[Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_837[Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_837[Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_837[Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_837[Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_837, SecMask, Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_836[Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_837);
          assume wf(Heap, exhaleMask#_837, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_837;
        assume IsGoodExhaleState(exhaleHeap#_836, Heap, Mask, SecMask);
        Heap := exhaleHeap#_836;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc bf#298;
        // inhale (postcondition)
        assume this#297 != null;
        assume wf(Heap, Mask, SecMask);
        assume (Heap[this#297, AVLTreeNode.left] == null) || (dtype(Heap[this#297, AVLTreeNode.left]) == AVLTreeNode#t);
        assume methodCallK#_835 > 0;
        Mask[this#297, AVLTreeNode.left] := Mask[this#297, AVLTreeNode.left][perm$R := Mask[this#297, AVLTreeNode.left][perm$R] + methodCallK#_835];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#297, AVLTreeNode.left]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#297, AVLTreeNode.left] == null)) {
          assume Heap[this#297, AVLTreeNode.left] != null;
          assume wf(Heap, Mask, SecMask);
          assume Fractions(100) > 0;
          Mask[Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[Heap[this#297, AVLTreeNode.left], AVLTreeNode.valid]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#297, AVLTreeNode.left] == null)) {
          assume Heap[this#297, AVLTreeNode.left] != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume methodCallK#_835 > 0;
          Mask[Heap[this#297, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#297, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#297, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_835];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[Heap[this#297, AVLTreeNode.left], AVLTreeNode.height]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume this#297 != null;
        assume wf(Heap, Mask, SecMask);
        assume (Heap[this#297, AVLTreeNode.right] == null) || (dtype(Heap[this#297, AVLTreeNode.right]) == AVLTreeNode#t);
        assume methodCallK#_835 > 0;
        Mask[this#297, AVLTreeNode.right] := Mask[this#297, AVLTreeNode.right][perm$R := Mask[this#297, AVLTreeNode.right][perm$R] + methodCallK#_835];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#297, AVLTreeNode.right]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#297, AVLTreeNode.right] == null)) {
          assume Heap[this#297, AVLTreeNode.right] != null;
          assume wf(Heap, Mask, SecMask);
          assume Fractions(100) > 0;
          Mask[Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[Heap[this#297, AVLTreeNode.right], AVLTreeNode.valid]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#297, AVLTreeNode.right] == null)) {
          assume Heap[this#297, AVLTreeNode.right] != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume methodCallK#_835 > 0;
          Mask[Heap[this#297, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#297, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#297, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_835];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[Heap[this#297, AVLTreeNode.right], AVLTreeNode.height]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume bf#298 == (ite(Heap[this#297, AVLTreeNode.left] == null, 0, Heap[Heap[this#297, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#297, AVLTreeNode.right] == null, 0, Heap[Heap[this#297, AVLTreeNode.right], AVLTreeNode.height]));
        if (bf#298 > 0) {
          assume !(Heap[this#297, AVLTreeNode.left] == null);
        }
        if (bf#298 < 0) {
          assume !(Heap[this#297, AVLTreeNode.right] == null);
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        bf#34 := bf#298;
        // if
        cond#_846 := bf#34 == 2;
        if (cond#_846) {
          assume (0 < methodCallK#_851) && ((1000 * methodCallK#_851) < Fractions(1)) && ((1000 * methodCallK#_851) < methodK#_506);
          // call rebalanceLeft
          callHeap#_847 := Heap;
          callMask#_848 := Mask;
          callSecMask#_849 := SecMask;
          callCredits#_850 := Credits;
          assume wf(callHeap#_847, callMask#_848, callSecMask#_849);
          assert {:msg "  333.7: The target of the method call might be null."} this != null;
          this#299 := this;
          // begin exhale (precondition)
          exhaleMask#_853 := Mask;
          havoc exhaleHeap#_852;
          assert {:msg "  333.7: The precondition at 608.12 might not hold. The expression at 608.12 might not evaluate to true."} !(Heap[this#299, AVLTreeNode.left] == null);
          assert {:msg "  333.7: The precondition at 613.12 might not hold. The expression at 613.12 might not evaluate to true."} (forall k#94#301: int :: (0 <= k#94#301) && (k#94#301 < Seq#Length(Heap[Heap[this#299, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#299, AVLTreeNode.left], AVLTreeNode.keys], k#94#301) < Heap[this#299, AVLTreeNode.key]));
          if (!(Heap[this#299, AVLTreeNode.right] == null)) {
            assert {:msg "  333.7: The precondition at 619.12 might not hold. The expression at 619.28 might not evaluate to true."} (forall k#95#302: int :: (0 <= k#95#302) && (k#95#302 < Seq#Length(Heap[Heap[this#299, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#299, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#299, AVLTreeNode.right], AVLTreeNode.keys], k#95#302)));
          }
          assert {:msg "  333.7: The precondition at 621.12 might not hold. The expression at 621.12 might not evaluate to true."} (Heap[Heap[this#299, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#299, AVLTreeNode.right] == null, 0, Heap[Heap[this#299, AVLTreeNode.right], AVLTreeNode.height])) == 2;
          assert {:msg "  333.7: The precondition at 600.12 might not hold. The permission at 600.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  333.7: The precondition at 600.12 might not hold. Insufficient fraction at 600.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_853[this#299, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_853[this#299, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_853[this#299, AVLTreeNode.key][perm$N]));
          exhaleMask#_853[this#299, AVLTreeNode.key] := exhaleMask#_853[this#299, AVLTreeNode.key][perm$R := exhaleMask#_853[this#299, AVLTreeNode.key][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_853);
          assume wf(Heap, exhaleMask#_853, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 601.12 might not hold. The permission at 601.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  333.7: The precondition at 601.12 might not hold. Insufficient fraction at 601.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_853[this#299, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_853[this#299, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_853[this#299, AVLTreeNode.height][perm$N]));
          exhaleMask#_853[this#299, AVLTreeNode.height] := exhaleMask#_853[this#299, AVLTreeNode.height][perm$R := exhaleMask#_853[this#299, AVLTreeNode.height][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_853);
          assume wf(Heap, exhaleMask#_853, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 602.12 might not hold. The permission at 602.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  333.7: The precondition at 602.12 might not hold. Insufficient fraction at 602.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_853[this#299, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_853[this#299, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_853[this#299, AVLTreeNode.left][perm$N]));
          exhaleMask#_853[this#299, AVLTreeNode.left] := exhaleMask#_853[this#299, AVLTreeNode.left][perm$R := exhaleMask#_853[this#299, AVLTreeNode.left][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_853);
          assume wf(Heap, exhaleMask#_853, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 603.12 might not hold. The permission at 603.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  333.7: The precondition at 603.12 might not hold. Insufficient fraction at 603.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_853[this#299, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_853[this#299, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_853[this#299, AVLTreeNode.right][perm$N]));
          exhaleMask#_853[this#299, AVLTreeNode.right] := exhaleMask#_853[this#299, AVLTreeNode.right][perm$R := exhaleMask#_853[this#299, AVLTreeNode.right][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_853);
          assume wf(Heap, exhaleMask#_853, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 605.12 might not hold. The permission at 605.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  333.7: The precondition at 605.12 might not hold. Insufficient fraction at 605.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_853[this#299, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_853[this#299, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_853[this#299, AVLTreeNode.keys][perm$N]));
          exhaleMask#_853[this#299, AVLTreeNode.keys] := exhaleMask#_853[this#299, AVLTreeNode.keys][perm$R := exhaleMask#_853[this#299, AVLTreeNode.keys][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_853);
          assume wf(Heap, exhaleMask#_853, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 606.12 might not hold. The permission at 606.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  333.7: The precondition at 606.12 might not hold. Insufficient fraction at 606.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_853[this#299, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_853[this#299, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_853[this#299, AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_853[this#299, AVLTreeNode.balanceFactor] := exhaleMask#_853[this#299, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_853[this#299, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_853);
          assume wf(Heap, exhaleMask#_853, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 609.12 might not hold. The permission at 609.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  333.7: The precondition at 609.12 might not hold. Insufficient fraction at 609.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_853, SecMask, Heap[this#299, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#299, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_852[Heap[this#299, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_853);
          assume wf(Heap, exhaleMask#_853, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 610.12 might not hold. The permission at 610.12 might not be positive."} Fractions(50) > 0;
          assert {:msg "  333.7: The precondition at 610.12 might not hold. Insufficient fraction at 610.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_853);
          assume wf(Heap, exhaleMask#_853, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 611.12 might not hold. The permission at 611.12 might not be positive."} Fractions(50) > 0;
          assert {:msg "  333.7: The precondition at 611.12 might not hold. Insufficient fraction at 611.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_853);
          assume wf(Heap, exhaleMask#_853, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 612.12 might not hold. The permission at 612.12 might not be positive."} Fractions(50) > 0;
          assert {:msg "  333.7: The precondition at 612.12 might not hold. Insufficient fraction at 612.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_853[Heap[this#299, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_853);
          assume wf(Heap, exhaleMask#_853, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[this#299, AVLTreeNode.right] == null)) {
            assert {:msg "  333.7: The precondition at 615.12 might not hold. The permission at 615.28 might not be positive."} Fractions(100) > 0;
            assert {:msg "  333.7: The precondition at 615.12 might not hold. Insufficient fraction at 615.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
            exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (!CanRead(exhaleMask#_853, SecMask, Heap[this#299, AVLTreeNode.right], AVLTreeNode.valid)) {
              assume Heap[Heap[this#299, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_852[Heap[this#299, AVLTreeNode.right], AVLTreeNode.valid];
            }
            assume IsGoodMask(exhaleMask#_853);
            assume wf(Heap, exhaleMask#_853, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#299, AVLTreeNode.right] == null)) {
            assert {:msg "  333.7: The precondition at 616.12 might not hold. The permission at 616.28 might not be positive."} Fractions(50) > 0;
            assert {:msg "  333.7: The precondition at 616.12 might not hold. Insufficient fraction at 616.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
            exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_853);
            assume wf(Heap, exhaleMask#_853, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#299, AVLTreeNode.right] == null)) {
            assert {:msg "  333.7: The precondition at 617.12 might not hold. The permission at 617.28 might not be positive."} Fractions(50) > 0;
            assert {:msg "  333.7: The precondition at 617.12 might not hold. Insufficient fraction at 617.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
            exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_853);
            assume wf(Heap, exhaleMask#_853, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#299, AVLTreeNode.right] == null)) {
            assert {:msg "  333.7: The precondition at 618.12 might not hold. The permission at 618.28 might not be positive."} Fractions(50) > 0;
            assert {:msg "  333.7: The precondition at 618.12 might not hold. Insufficient fraction at 618.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_853[Heap[this#299, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_853);
            assume wf(Heap, exhaleMask#_853, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          Mask := exhaleMask#_853;
          assume IsGoodExhaleState(exhaleHeap#_852, Heap, Mask, SecMask);
          Heap := exhaleHeap#_852;
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end exhale
          havoc r#300;
          // inhale (postcondition)
          assume !(r#300 == null);
          assume r#300 != null;
          assume wf(Heap, Mask, SecMask);
          assume Fractions(100) > 0;
          Mask[r#300, AVLTreeNode.valid] := Mask[r#300, AVLTreeNode.valid][perm$R := Mask[r#300, AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#300, AVLTreeNode.valid]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume r#300 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#300, AVLTreeNode.height] := Mask[r#300, AVLTreeNode.height][perm$R := Mask[r#300, AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#300, AVLTreeNode.height]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume r#300 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#300, AVLTreeNode.keys] := Mask[r#300, AVLTreeNode.keys][perm$R := Mask[r#300, AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#300, AVLTreeNode.keys]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume r#300 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[r#300, AVLTreeNode.balanceFactor] := Mask[r#300, AVLTreeNode.balanceFactor][perm$R := Mask[r#300, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[r#300, AVLTreeNode.balanceFactor]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume (Heap[r#300, AVLTreeNode.height] == callHeap#_847[callHeap#_847[this#299, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#300, AVLTreeNode.height] == (callHeap#_847[callHeap#_847[this#299, AVLTreeNode.left], AVLTreeNode.height] + 1));
          assume Seq#Equal(Heap[r#300, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_847[callHeap#_847[this#299, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_847[this#299, AVLTreeNode.key])), ite(callHeap#_847[this#299, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_847[callHeap#_847[this#299, AVLTreeNode.right], AVLTreeNode.keys])));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end inhale
          r#20 := r#300;
        } else {
          // assigment to r
          r#20 := this;
          assume (0 < methodCallK#_874) && ((1000 * methodCallK#_874) < Fractions(1)) && ((1000 * methodCallK#_874) < methodK#_506);
          // call close
          callHeap#_870 := Heap;
          callMask#_871 := Mask;
          callSecMask#_872 := SecMask;
          callCredits#_873 := Credits;
          assume wf(callHeap#_870, callMask#_871, callSecMask#_872);
          assert {:msg "  336.7: The target of the method call might be null."} r#20 != null;
          this#305 := r#20;
          // begin exhale (precondition)
          exhaleMask#_876 := Mask;
          havoc exhaleHeap#_875;
          if (!(Heap[this#305, AVLTreeNode.left] == null)) {
            assert {:msg "  336.7: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#306: int :: (0 <= k#92#306) && (k#92#306 < Seq#Length(Heap[Heap[this#305, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#305, AVLTreeNode.left], AVLTreeNode.keys], k#92#306) < Heap[this#305, AVLTreeNode.key]));
          }
          if (!(Heap[this#305, AVLTreeNode.right] == null)) {
            assert {:msg "  336.7: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#307: int :: (0 <= k#93#307) && (k#93#307 < Seq#Length(Heap[Heap[this#305, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#305, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#305, AVLTreeNode.right], AVLTreeNode.keys], k#93#307)));
          }
          assert {:msg "  336.7: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#305, AVLTreeNode.left] == null, 0, Heap[Heap[this#305, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#305, AVLTreeNode.right] == null, 0, Heap[Heap[this#305, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
          assert {:msg "  336.7: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#305, AVLTreeNode.left] == null, 0, Heap[Heap[this#305, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#305, AVLTreeNode.right] == null, 0, Heap[Heap[this#305, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
          assert {:msg "  336.7: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  336.7: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_876[this#305, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_876[this#305, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_876[this#305, AVLTreeNode.key][perm$N]));
          exhaleMask#_876[this#305, AVLTreeNode.key] := exhaleMask#_876[this#305, AVLTreeNode.key][perm$R := exhaleMask#_876[this#305, AVLTreeNode.key][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_876);
          assume wf(Heap, exhaleMask#_876, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  336.7: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  336.7: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_876[this#305, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_876[this#305, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_876[this#305, AVLTreeNode.height][perm$N]));
          exhaleMask#_876[this#305, AVLTreeNode.height] := exhaleMask#_876[this#305, AVLTreeNode.height][perm$R := exhaleMask#_876[this#305, AVLTreeNode.height][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_876);
          assume wf(Heap, exhaleMask#_876, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  336.7: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  336.7: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_876[this#305, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_876[this#305, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_876[this#305, AVLTreeNode.left][perm$N]));
          exhaleMask#_876[this#305, AVLTreeNode.left] := exhaleMask#_876[this#305, AVLTreeNode.left][perm$R := exhaleMask#_876[this#305, AVLTreeNode.left][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_876);
          assume wf(Heap, exhaleMask#_876, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  336.7: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  336.7: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_876[this#305, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_876[this#305, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_876[this#305, AVLTreeNode.right][perm$N]));
          exhaleMask#_876[this#305, AVLTreeNode.right] := exhaleMask#_876[this#305, AVLTreeNode.right][perm$R := exhaleMask#_876[this#305, AVLTreeNode.right][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_876);
          assume wf(Heap, exhaleMask#_876, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  336.7: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  336.7: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_876[this#305, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_876[this#305, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_876[this#305, AVLTreeNode.keys][perm$N]));
          exhaleMask#_876[this#305, AVLTreeNode.keys] := exhaleMask#_876[this#305, AVLTreeNode.keys][perm$R := exhaleMask#_876[this#305, AVLTreeNode.keys][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_876);
          assume wf(Heap, exhaleMask#_876, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  336.7: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
          assert {:msg "  336.7: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_876[this#305, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_876[this#305, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_876[this#305, AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_876[this#305, AVLTreeNode.balanceFactor] := exhaleMask#_876[this#305, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_876[this#305, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
          assume IsGoodMask(exhaleMask#_876);
          assume wf(Heap, exhaleMask#_876, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[this#305, AVLTreeNode.left] == null)) {
            assert {:msg "  336.7: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
            assert {:msg "  336.7: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
            exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (!CanRead(exhaleMask#_876, SecMask, Heap[this#305, AVLTreeNode.left], AVLTreeNode.valid)) {
              assume Heap[Heap[this#305, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_875[Heap[this#305, AVLTreeNode.left], AVLTreeNode.valid];
            }
            assume IsGoodMask(exhaleMask#_876);
            assume wf(Heap, exhaleMask#_876, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#305, AVLTreeNode.left] == null)) {
            assert {:msg "  336.7: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
            assert {:msg "  336.7: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
            exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_876);
            assume wf(Heap, exhaleMask#_876, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#305, AVLTreeNode.left] == null)) {
            assert {:msg "  336.7: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
            assert {:msg "  336.7: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
            exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_876);
            assume wf(Heap, exhaleMask#_876, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#305, AVLTreeNode.left] == null)) {
            assert {:msg "  336.7: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
            assert {:msg "  336.7: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_876[Heap[this#305, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_876);
            assume wf(Heap, exhaleMask#_876, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#305, AVLTreeNode.right] == null)) {
            assert {:msg "  336.7: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
            assert {:msg "  336.7: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
            exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (!CanRead(exhaleMask#_876, SecMask, Heap[this#305, AVLTreeNode.right], AVLTreeNode.valid)) {
              assume Heap[Heap[this#305, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_875[Heap[this#305, AVLTreeNode.right], AVLTreeNode.valid];
            }
            assume IsGoodMask(exhaleMask#_876);
            assume wf(Heap, exhaleMask#_876, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#305, AVLTreeNode.right] == null)) {
            assert {:msg "  336.7: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
            assert {:msg "  336.7: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
            exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_876);
            assume wf(Heap, exhaleMask#_876, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#305, AVLTreeNode.right] == null)) {
            assert {:msg "  336.7: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
            assert {:msg "  336.7: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
            exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_876);
            assume wf(Heap, exhaleMask#_876, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#305, AVLTreeNode.right] == null)) {
            assert {:msg "  336.7: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
            assert {:msg "  336.7: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_876[Heap[this#305, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            assume IsGoodMask(exhaleMask#_876);
            assume wf(Heap, exhaleMask#_876, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          Mask := exhaleMask#_876;
          assume IsGoodExhaleState(exhaleHeap#_875, Heap, Mask, SecMask);
          Heap := exhaleHeap#_875;
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end exhale
          // inhale (postcondition)
          assume this#305 != null;
          assume wf(Heap, Mask, SecMask);
          assume Fractions(100) > 0;
          Mask[this#305, AVLTreeNode.valid] := Mask[this#305, AVLTreeNode.valid][perm$R := Mask[this#305, AVLTreeNode.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[this#305, AVLTreeNode.valid]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume this#305 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[this#305, AVLTreeNode.height] := Mask[this#305, AVLTreeNode.height][perm$R := Mask[this#305, AVLTreeNode.height][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[this#305, AVLTreeNode.height]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume this#305 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[this#305, AVLTreeNode.keys] := Mask[this#305, AVLTreeNode.keys][perm$R := Mask[this#305, AVLTreeNode.keys][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[this#305, AVLTreeNode.keys]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume this#305 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume Fractions(50) > 0;
          Mask[this#305, AVLTreeNode.balanceFactor] := Mask[this#305, AVLTreeNode.balanceFactor][perm$R := Mask[this#305, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(heapFragment(Heap[this#305, AVLTreeNode.balanceFactor]));
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume Seq#Equal(Heap[this#305, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_870[this#305, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_870[callHeap#_870[this#305, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_870[this#305, AVLTreeNode.key])), ite(callHeap#_870[this#305, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_870[callHeap#_870[this#305, AVLTreeNode.right], AVLTreeNode.keys])));
          assume Heap[this#305, AVLTreeNode.height] == ite(ite(callHeap#_870[this#305, AVLTreeNode.left] == null, 0, callHeap#_870[callHeap#_870[this#305, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_870[this#305, AVLTreeNode.right] == null, 0, callHeap#_870[callHeap#_870[this#305, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_870[this#305, AVLTreeNode.left] == null, 0, callHeap#_870[callHeap#_870[this#305, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_870[this#305, AVLTreeNode.right] == null, 0, callHeap#_870[callHeap#_870[this#305, AVLTreeNode.right], AVLTreeNode.height]) + 1);
          assume Heap[this#305, AVLTreeNode.balanceFactor] == (ite(callHeap#_870[this#305, AVLTreeNode.left] == null, 0, callHeap#_870[callHeap#_870[this#305, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_870[this#305, AVLTreeNode.right] == null, 0, callHeap#_870[callHeap#_870[this#305, AVLTreeNode.right], AVLTreeNode.height]));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end inhale
        }
      } else {
        // assigment to r
        r#20 := this;
        assume (0 < methodCallK#_897) && ((1000 * methodCallK#_897) < Fractions(1)) && ((1000 * methodCallK#_897) < methodK#_506);
        // call close
        callHeap#_893 := Heap;
        callMask#_894 := Mask;
        callSecMask#_895 := SecMask;
        callCredits#_896 := Credits;
        assume wf(callHeap#_893, callMask#_894, callSecMask#_895);
        assert {:msg "  340.6: The target of the method call might be null."} r#20 != null;
        this#310 := r#20;
        // begin exhale (precondition)
        exhaleMask#_899 := Mask;
        havoc exhaleHeap#_898;
        if (!(Heap[this#310, AVLTreeNode.left] == null)) {
          assert {:msg "  340.6: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#311: int :: (0 <= k#92#311) && (k#92#311 < Seq#Length(Heap[Heap[this#310, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#310, AVLTreeNode.left], AVLTreeNode.keys], k#92#311) < Heap[this#310, AVLTreeNode.key]));
        }
        if (!(Heap[this#310, AVLTreeNode.right] == null)) {
          assert {:msg "  340.6: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#312: int :: (0 <= k#93#312) && (k#93#312 < Seq#Length(Heap[Heap[this#310, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#310, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#310, AVLTreeNode.right], AVLTreeNode.keys], k#93#312)));
        }
        assert {:msg "  340.6: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#310, AVLTreeNode.left] == null, 0, Heap[Heap[this#310, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#310, AVLTreeNode.right] == null, 0, Heap[Heap[this#310, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
        assert {:msg "  340.6: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#310, AVLTreeNode.left] == null, 0, Heap[Heap[this#310, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#310, AVLTreeNode.right] == null, 0, Heap[Heap[this#310, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
        assert {:msg "  340.6: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  340.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_899[this#310, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_899[this#310, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_899[this#310, AVLTreeNode.key][perm$N]));
        exhaleMask#_899[this#310, AVLTreeNode.key] := exhaleMask#_899[this#310, AVLTreeNode.key][perm$R := exhaleMask#_899[this#310, AVLTreeNode.key][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_899);
        assume wf(Heap, exhaleMask#_899, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  340.6: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  340.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_899[this#310, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_899[this#310, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_899[this#310, AVLTreeNode.height][perm$N]));
        exhaleMask#_899[this#310, AVLTreeNode.height] := exhaleMask#_899[this#310, AVLTreeNode.height][perm$R := exhaleMask#_899[this#310, AVLTreeNode.height][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_899);
        assume wf(Heap, exhaleMask#_899, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  340.6: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  340.6: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_899[this#310, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_899[this#310, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_899[this#310, AVLTreeNode.left][perm$N]));
        exhaleMask#_899[this#310, AVLTreeNode.left] := exhaleMask#_899[this#310, AVLTreeNode.left][perm$R := exhaleMask#_899[this#310, AVLTreeNode.left][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_899);
        assume wf(Heap, exhaleMask#_899, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  340.6: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  340.6: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_899[this#310, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_899[this#310, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_899[this#310, AVLTreeNode.right][perm$N]));
        exhaleMask#_899[this#310, AVLTreeNode.right] := exhaleMask#_899[this#310, AVLTreeNode.right][perm$R := exhaleMask#_899[this#310, AVLTreeNode.right][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_899);
        assume wf(Heap, exhaleMask#_899, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  340.6: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  340.6: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_899[this#310, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_899[this#310, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_899[this#310, AVLTreeNode.keys][perm$N]));
        exhaleMask#_899[this#310, AVLTreeNode.keys] := exhaleMask#_899[this#310, AVLTreeNode.keys][perm$R := exhaleMask#_899[this#310, AVLTreeNode.keys][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_899);
        assume wf(Heap, exhaleMask#_899, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  340.6: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  340.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_899[this#310, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_899[this#310, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_899[this#310, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_899[this#310, AVLTreeNode.balanceFactor] := exhaleMask#_899[this#310, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_899[this#310, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
        assume IsGoodMask(exhaleMask#_899);
        assume wf(Heap, exhaleMask#_899, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#310, AVLTreeNode.left] == null)) {
          assert {:msg "  340.6: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
          assert {:msg "  340.6: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_899, SecMask, Heap[this#310, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#310, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_898[Heap[this#310, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_899);
          assume wf(Heap, exhaleMask#_899, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#310, AVLTreeNode.left] == null)) {
          assert {:msg "  340.6: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
          assert {:msg "  340.6: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_899);
          assume wf(Heap, exhaleMask#_899, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#310, AVLTreeNode.left] == null)) {
          assert {:msg "  340.6: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
          assert {:msg "  340.6: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_899);
          assume wf(Heap, exhaleMask#_899, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#310, AVLTreeNode.left] == null)) {
          assert {:msg "  340.6: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
          assert {:msg "  340.6: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_899[Heap[this#310, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_899);
          assume wf(Heap, exhaleMask#_899, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#310, AVLTreeNode.right] == null)) {
          assert {:msg "  340.6: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
          assert {:msg "  340.6: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (!CanRead(exhaleMask#_899, SecMask, Heap[this#310, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#310, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_898[Heap[this#310, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume IsGoodMask(exhaleMask#_899);
          assume wf(Heap, exhaleMask#_899, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#310, AVLTreeNode.right] == null)) {
          assert {:msg "  340.6: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  340.6: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_899);
          assume wf(Heap, exhaleMask#_899, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#310, AVLTreeNode.right] == null)) {
          assert {:msg "  340.6: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  340.6: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_899);
          assume wf(Heap, exhaleMask#_899, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#310, AVLTreeNode.right] == null)) {
          assert {:msg "  340.6: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
          assert {:msg "  340.6: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_899[Heap[this#310, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          assume IsGoodMask(exhaleMask#_899);
          assume wf(Heap, exhaleMask#_899, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_899;
        assume IsGoodExhaleState(exhaleHeap#_898, Heap, Mask, SecMask);
        Heap := exhaleHeap#_898;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        // inhale (postcondition)
        assume this#310 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[this#310, AVLTreeNode.valid] := Mask[this#310, AVLTreeNode.valid][perm$R := Mask[this#310, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#310, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#310 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#310, AVLTreeNode.height] := Mask[this#310, AVLTreeNode.height][perm$R := Mask[this#310, AVLTreeNode.height][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#310, AVLTreeNode.height]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#310 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#310, AVLTreeNode.keys] := Mask[this#310, AVLTreeNode.keys][perm$R := Mask[this#310, AVLTreeNode.keys][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#310, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#310 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume Fractions(50) > 0;
        Mask[this#310, AVLTreeNode.balanceFactor] := Mask[this#310, AVLTreeNode.balanceFactor][perm$R := Mask[this#310, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#310, AVLTreeNode.balanceFactor]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Seq#Equal(Heap[this#310, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_893[this#310, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_893[callHeap#_893[this#310, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_893[this#310, AVLTreeNode.key])), ite(callHeap#_893[this#310, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_893[callHeap#_893[this#310, AVLTreeNode.right], AVLTreeNode.keys])));
        assume Heap[this#310, AVLTreeNode.height] == ite(ite(callHeap#_893[this#310, AVLTreeNode.left] == null, 0, callHeap#_893[callHeap#_893[this#310, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_893[this#310, AVLTreeNode.right] == null, 0, callHeap#_893[callHeap#_893[this#310, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_893[this#310, AVLTreeNode.left] == null, 0, callHeap#_893[callHeap#_893[this#310, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_893[this#310, AVLTreeNode.right] == null, 0, callHeap#_893[callHeap#_893[this#310, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume Heap[this#310, AVLTreeNode.balanceFactor] == (ite(callHeap#_893[this#310, AVLTreeNode.left] == null, 0, callHeap#_893[callHeap#_893[this#310, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_893[this#310, AVLTreeNode.right] == null, 0, callHeap#_893[callHeap#_893[this#310, AVLTreeNode.right], AVLTreeNode.height]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
      }
    }
  }
  // begin exhale (postcondition)
  exhaleMask#_917 := Mask;
  havoc exhaleHeap#_916;
  if (Seq#Equal(old(Heap)[this, AVLTreeNode.keys], Seq#Singleton(k#19))) {
    assert {:msg "  253.2: The postcondition at 259.11 might not hold. The expression at 259.30 might not evaluate to true."} r#20 == null;
  }
  if (!Seq#Equal(old(Heap)[this, AVLTreeNode.keys], Seq#Singleton(k#19))) {
    assert {:msg "  253.2: The postcondition at 260.11 might not hold. The expression at 260.30 might not evaluate to true."} !(r#20 == null);
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 267.11 might not hold. The expression at 267.25 might not evaluate to true."} !Seq#Contains(Heap[r#20, AVLTreeNode.keys], k#19);
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 268.11 might not hold. The expression at 268.25 might not evaluate to true."} (forall i#84#315: int :: (0 <= i#84#315) && (i#84#315 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#315)) || (Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#315) == k#19)));
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 269.11 might not hold. The expression at 269.25 might not evaluate to true."} (forall i#85#316: int :: (0 <= i#85#316) && (i#85#316 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#316)) && (!(Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#316) == k#19)));
  }
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assert {:msg "  253.2: The postcondition at 270.11 might not hold. The expression at 270.34 might not evaluate to true."} !(r#20 == null);
  }
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assert {:msg "  253.2: The postcondition at 271.11 might not hold. The expression at 271.34 might not evaluate to true."} Seq#Equal(Heap[r#20, AVLTreeNode.keys], old(Heap)[this, AVLTreeNode.keys]);
  }
  if (!(r#20 == null)) {
    if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
      assert {:msg "  253.2: The postcondition at 272.11 might not hold. The expression at 272.45 might not evaluate to true."} Seq#Length(Heap[r#20, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this, AVLTreeNode.keys]) - 1);
    }
  }
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assert {:msg "  253.2: The postcondition at 274.11 might not hold. The expression at 274.29 might not evaluate to true."} !(r#20 == null);
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 275.11 might not hold. The expression at 275.25 might not evaluate to true."} (Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || ((Heap[r#20, AVLTreeNode.height] + 1) == old(Heap)[this, AVLTreeNode.height]);
  }
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assert {:msg "  253.2: The postcondition at 276.11 might not hold. The expression at 276.33 might not evaluate to true."} Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height];
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 262.11 might not hold. The permission at 262.25 might not be positive."} Fractions(100) > 0;
    assert {:msg "  253.2: The postcondition at 262.11 might not hold. Insufficient fraction at 262.25 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_917[r#20, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_917[r#20, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_917[r#20, AVLTreeNode.valid][perm$N]));
    exhaleMask#_917[r#20, AVLTreeNode.valid] := exhaleMask#_917[r#20, AVLTreeNode.valid][perm$R := exhaleMask#_917[r#20, AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_917, SecMask, r#20, AVLTreeNode.valid)) {
      assume Heap[r#20, AVLTreeNode.valid] < exhaleHeap#_916[r#20, AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_917);
    assume wf(Heap, exhaleMask#_917, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 263.11 might not hold. The permission at 263.25 might not be positive."} Fractions(50) > 0;
    assert {:msg "  253.2: The postcondition at 263.11 might not hold. Insufficient fraction at 263.25 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_917[r#20, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_917[r#20, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_917[r#20, AVLTreeNode.keys][perm$N]));
    exhaleMask#_917[r#20, AVLTreeNode.keys] := exhaleMask#_917[r#20, AVLTreeNode.keys][perm$R := exhaleMask#_917[r#20, AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_917);
    assume wf(Heap, exhaleMask#_917, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 264.11 might not hold. The permission at 264.25 might not be positive."} Fractions(50) > 0;
    assert {:msg "  253.2: The postcondition at 264.11 might not hold. Insufficient fraction at 264.25 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_917[r#20, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_917[r#20, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_917[r#20, AVLTreeNode.height][perm$N]));
    exhaleMask#_917[r#20, AVLTreeNode.height] := exhaleMask#_917[r#20, AVLTreeNode.height][perm$R := exhaleMask#_917[r#20, AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_917);
    assume wf(Heap, exhaleMask#_917, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 265.11 might not hold. The permission at 265.25 might not be positive."} Fractions(50) > 0;
    assert {:msg "  253.2: The postcondition at 265.11 might not hold. Insufficient fraction at 265.25 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_917[r#20, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_917[r#20, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_917[r#20, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_917[r#20, AVLTreeNode.balanceFactor] := exhaleMask#_917[r#20, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_917[r#20, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_917);
    assume wf(Heap, exhaleMask#_917, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
  }
  Mask := exhaleMask#_917;
  assume IsGoodExhaleState(exhaleHeap#_916, Heap, Mask, SecMask);
  Heap := exhaleHeap#_916;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  253.2: Method might lock/unlock more than allowed."} (forall lk#_922: ref :: {Heap[lk#_922, held]} {Heap[lk#_922, rdheld]} (((0 < Heap[lk#_922, held]) == (0 < old(Heap)[lk#_922, held])) && (Heap[lk#_922, rdheld] == old(Heap)[lk#_922, rdheld])) || false);
  assert {:msg "  253.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.pruneMax$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#35: ref where (r#35 == null) || (dtype(r#35) == AVLTreeNode#t), m#36: ref where (m#36 == null) || (dtype(m#36) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_923: int;
  var k#86#320: int where true;
  assume (0 < methodK#_923) && ((1000 * methodK#_923) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  349.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  if (!(r#35 == null)) {
    assert {:msg "  354.25: Receiver might be null."} r#35 != null;
    assume r#35 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[r#35, AVLTreeNode.valid] := Mask[r#35, AVLTreeNode.valid][perm$R := Mask[r#35, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#35, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assume r#35 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#35, AVLTreeNode.keys] := Mask[r#35, AVLTreeNode.keys][perm$R := Mask[r#35, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#35, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assume r#35 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#35, AVLTreeNode.height] := Mask[r#35, AVLTreeNode.height][perm$R := Mask[r#35, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#35, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assume r#35 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#35, AVLTreeNode.balanceFactor] := Mask[r#35, AVLTreeNode.balanceFactor][perm$R := Mask[r#35, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#35, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assert {:msg "  358.26: Receiver might be null."} true ==> (r#35 != null);
    assert {:msg "  358.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#35, AVLTreeNode.height);
    assert {:msg "  358.42: Receiver might be null."} true ==> (this != null);
    assert {:msg "  358.42: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
    assert {:msg "  358.53: Receiver might be null."} true && (!(Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#35 != null);
    assert {:msg "  358.53: Location might not be readable."} true && (!(Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask, SecMask, r#35, AVLTreeNode.height);
    assert {:msg "  358.71: Receiver might be null."} true && (!(Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
    assert {:msg "  358.71: Location might not be readable."} true && (!(Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
    assume (Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || ((Heap[r#35, AVLTreeNode.height] + 1) == old(Heap)[this, AVLTreeNode.height]);
  }
  if (!(r#35 == null)) {
    assert {:msg "  359.25: Receiver might be null."} true ==> (r#35 != null);
    assert {:msg "  359.25: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#35, AVLTreeNode.keys);
    assert {:msg "  359.43: Receiver might be null."} true ==> (this != null);
    assert {:msg "  359.43: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
    assume (Seq#Length(Heap[r#35, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this, AVLTreeNode.keys]);
  }
  assert {:msg "  360.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  360.15: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assume !(r#35 == null);
  }
  assert {:msg "  361.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  361.15: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] == 1) {
    assume r#35 == null;
  }
  assert {:msg "  362.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  362.15: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
  if (r#35 == null) {
  } else {
    assert {:msg "  362.35: Receiver might be null."} true ==> (r#35 != null);
    assert {:msg "  362.35: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#35, AVLTreeNode.height);
  }
  assert {:msg "  362.52: Receiver might be null."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]))) ==> (this != null);
  assert {:msg "  362.52: Location might not be readable."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]))) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
  if (r#35 == null) {
  } else {
    assert {:msg "  362.72: Receiver might be null."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]))) ==> (r#35 != null);
    assert {:msg "  362.72: Location might not be readable."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]))) ==> CanRead(Mask, SecMask, r#35, AVLTreeNode.height);
  }
  assume (old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height])) || (old(Heap)[this, AVLTreeNode.height] == (ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]) + 1));
  assume !(m#36 == null);
  assert {:msg "  365.11: Receiver might be null."} m#36 != null;
  assume m#36 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[m#36, AVLTreeNode.valid] := Mask[m#36, AVLTreeNode.valid][perm$R := Mask[m#36, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[m#36, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume m#36 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[m#36, AVLTreeNode.keys] := Mask[m#36, AVLTreeNode.keys][perm$R := Mask[m#36, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[m#36, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume m#36 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[m#36, AVLTreeNode.height] := Mask[m#36, AVLTreeNode.height][perm$R := Mask[m#36, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[m#36, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume m#36 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[m#36, AVLTreeNode.balanceFactor] := Mask[m#36, AVLTreeNode.balanceFactor][perm$R := Mask[m#36, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[m#36, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  369.11: Receiver might be null."} true ==> (m#36 != null);
  assert {:msg "  369.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, m#36, AVLTreeNode.height);
  assume Heap[m#36, AVLTreeNode.height] == 1;
  assert {:msg "  370.12: Receiver might be null."} true ==> (m#36 != null);
  assert {:msg "  370.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, m#36, AVLTreeNode.keys);
  assume Seq#Length(Heap[m#36, AVLTreeNode.keys]) == 1;
  if (r#35 == null) {
  } else {
    assert {:msg "  372.29: Receiver might be null."} true ==> (r#35 != null);
    assert {:msg "  372.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#35, AVLTreeNode.keys);
  }
  assert {:msg "  372.40: Receiver might be null."} true ==> (m#36 != null);
  assert {:msg "  372.40: Location might not be readable."} true ==> CanRead(Mask, SecMask, m#36, AVLTreeNode.keys);
  assert {:msg "  372.54: Receiver might be null."} true ==> (this != null);
  assert {:msg "  372.54: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  assume Seq#Equal(Seq#Append(ite(r#35 == null, Seq#Empty(), Heap[r#35, AVLTreeNode.keys]), Heap[m#36, AVLTreeNode.keys]), old(Heap)[this, AVLTreeNode.keys]);
  if (!(r#35 == null)) {
    assert {:msg "  373.11: Receiver might be null."} true && (0 <= k#86#320) ==> (r#35 != null);
    assert {:msg "  373.11: Location might not be readable."} true && (0 <= k#86#320) ==> CanRead(Mask, SecMask, r#35, AVLTreeNode.keys);
    assert {:msg "  373.11: Receiver might be null."} true && (0 <= k#86#320) && (k#86#320 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (r#35 != null);
    assert {:msg "  373.11: Location might not be readable."} true && (0 <= k#86#320) && (k#86#320 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, r#35, AVLTreeNode.keys);
    assert {:msg "  373.45: Sequence index might be negative."} true && (0 <= k#86#320) && (k#86#320 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 <= k#86#320);
    assert {:msg "  373.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#86#320) && (k#86#320 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (k#86#320 < Seq#Length(Heap[r#35, AVLTreeNode.keys]));
    assert {:msg "  373.49: Receiver might be null."} true && (0 <= k#86#320) && (k#86#320 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (m#36 != null);
    assert {:msg "  373.49: Location might not be readable."} true && (0 <= k#86#320) && (k#86#320 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, m#36, AVLTreeNode.keys);
    assert {:msg "  373.49: Sequence index might be negative."} true && (0 <= k#86#320) && (k#86#320 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 <= 0);
    assert {:msg "  373.49: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#86#320) && (k#86#320 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 < Seq#Length(Heap[m#36, AVLTreeNode.keys]));
    assume (forall k#86#319: int :: (0 <= k#86#319) && (k#86#319 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (Seq#Index(Heap[r#35, AVLTreeNode.keys], k#86#319) < Seq#Index(Heap[m#36, AVLTreeNode.keys], 0)));
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.pruneMax(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#35: ref where (r#35 == null) || (dtype(r#35) == AVLTreeNode#t), m#36: ref where (m#36 == null) || (dtype(m#36) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_923: int;
  var unfoldK#_924: int;
  var oldVers#_944: int;
  var newVers#_945: int;
  var cond#_946: bool;
  var methodCallK#_951: int;
  var this#327: ref where (this#327 == null) || (dtype(this#327) == AVLTreeNode#t);
  var callHeap#_947: HeapType;
  var callMask#_948: MaskType;
  var callSecMask#_949: MaskType;
  var callCredits#_950: CreditsType;
  var exhaleMask#_953: MaskType;
  var exhaleHeap#_952: HeapType;
  var isHeld#_968: int;
  var isRdHeld#_969: bool;
  var assertHeap#_970: HeapType;
  var assertMask#_971: MaskType;
  var assertSecMask#_972: MaskType;
  var assertCredits#_973: CreditsType;
  var exhaleMask#_975: MaskType;
  var exhaleHeap#_974: HeapType;
  var k#87#333: int where true;
  var nr#38: ref where (nr#38 == null) || (dtype(nr#38) == AVLTreeNode#t);
  var methodCallK#_980: int;
  var this#335: ref where (this#335 == null) || (dtype(this#335) == AVLTreeNode#t);
  var r#336: ref where (r#336 == null) || (dtype(r#336) == AVLTreeNode#t);
  var m#337: ref where (m#337 == null) || (dtype(m#337) == AVLTreeNode#t);
  var callHeap#_976: HeapType;
  var callMask#_977: MaskType;
  var callSecMask#_978: MaskType;
  var callCredits#_979: CreditsType;
  var exhaleMask#_982: MaskType;
  var exhaleHeap#_981: HeapType;
  var isHeld#_987: int;
  var isRdHeld#_988: bool;
  var bf#40: int where true;
  var methodCallK#_993: int;
  var this#339: ref where (this#339 == null) || (dtype(this#339) == AVLTreeNode#t);
  var bf#340: int where true;
  var callHeap#_989: HeapType;
  var callMask#_990: MaskType;
  var callSecMask#_991: MaskType;
  var callCredits#_992: CreditsType;
  var exhaleMask#_995: MaskType;
  var exhaleHeap#_994: HeapType;
  var isHeld#_1002: int;
  var isRdHeld#_1003: bool;
  var cond#_1004: bool;
  var methodCallK#_1009: int;
  var this#341: ref where (this#341 == null) || (dtype(this#341) == AVLTreeNode#t);
  var r#342: ref where (r#342 == null) || (dtype(r#342) == AVLTreeNode#t);
  var callHeap#_1005: HeapType;
  var callMask#_1006: MaskType;
  var callSecMask#_1007: MaskType;
  var callCredits#_1008: CreditsType;
  var exhaleMask#_1011: MaskType;
  var exhaleHeap#_1010: HeapType;
  var isHeld#_1026: int;
  var isRdHeld#_1027: bool;
  var methodCallK#_1032: int;
  var this#347: ref where (this#347 == null) || (dtype(this#347) == AVLTreeNode#t);
  var callHeap#_1028: HeapType;
  var callMask#_1029: MaskType;
  var callSecMask#_1030: MaskType;
  var callCredits#_1031: CreditsType;
  var exhaleMask#_1034: MaskType;
  var exhaleHeap#_1033: HeapType;
  var isHeld#_1049: int;
  var isRdHeld#_1050: bool;
  var assertHeap#_1051: HeapType;
  var assertMask#_1052: MaskType;
  var assertSecMask#_1053: MaskType;
  var assertCredits#_1054: CreditsType;
  var exhaleMask#_1056: MaskType;
  var exhaleHeap#_1055: HeapType;
  var k#88#353: int where true;
  var exhaleMask#_1058: MaskType;
  var exhaleHeap#_1057: HeapType;
  assume (0 < methodK#_923) && ((1000 * methodK#_923) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // unfold
  assume #AVLTreeNode.valid#trigger(this);
  assume (0 < unfoldK#_924) && (unfoldK#_924 < Fractions(1)) && ((1000 * unfoldK#_924) < methodK#_923);
  assert {:msg "  375.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  375.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  375.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[this, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[this, AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[this, AVLTreeNode.valid][perm$N]));
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#321: int :: (0 <= lk#79#321) && (lk#79#321 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#321) < Heap[this, AVLTreeNode.key]));
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#322: int :: (0 <= rk#80#322) && (rk#80#322 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#322)));
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] > 0;
    SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, this, AVLTreeNode.valid)) {
    oldVers#_944 := Heap[this, AVLTreeNode.valid];
    havoc newVers#_945;
    Heap[this, AVLTreeNode.valid] := newVers#_945;
    assume oldVers#_944 < Heap[this, AVLTreeNode.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#325: int :: (0 <= lk#79#325) && (lk#79#325 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#325) < Heap[this, AVLTreeNode.key]));
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#326: int :: (0 <= rk#80#326) && (rk#80#326 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#326)));
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_946 := Heap[this, AVLTreeNode.right] == null;
  assert {:msg "  377.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  377.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (cond#_946) {
    // assigment to r
    assert {:msg "  378.9: Receiver might be null."} true ==> (this != null);
    assert {:msg "  378.9: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    r#35 := Heap[this, AVLTreeNode.left];
    // update field left
    assert {:msg "  379.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
    Heap[this, AVLTreeNode.left] := null;
    assume wf(Heap, Mask, SecMask);
    assume (0 < methodCallK#_951) && ((1000 * methodCallK#_951) < Fractions(1)) && ((1000 * methodCallK#_951) < methodK#_923);
    // call close
    callHeap#_947 := Heap;
    callMask#_948 := Mask;
    callSecMask#_949 := SecMask;
    callCredits#_950 := Credits;
    assume wf(callHeap#_947, callMask#_948, callSecMask#_949);
    assert {:msg "  380.4: The target of the method call might be null."} this != null;
    this#327 := this;
    // begin exhale (precondition)
    exhaleMask#_953 := Mask;
    havoc exhaleHeap#_952;
    if (!(Heap[this#327, AVLTreeNode.left] == null)) {
      assert {:msg "  380.4: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#328: int :: (0 <= k#92#328) && (k#92#328 < Seq#Length(Heap[Heap[this#327, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#327, AVLTreeNode.left], AVLTreeNode.keys], k#92#328) < Heap[this#327, AVLTreeNode.key]));
    }
    if (!(Heap[this#327, AVLTreeNode.right] == null)) {
      assert {:msg "  380.4: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#329: int :: (0 <= k#93#329) && (k#93#329 < Seq#Length(Heap[Heap[this#327, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#327, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#327, AVLTreeNode.right], AVLTreeNode.keys], k#93#329)));
    }
    assert {:msg "  380.4: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#327, AVLTreeNode.left] == null, 0, Heap[Heap[this#327, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#327, AVLTreeNode.right] == null, 0, Heap[Heap[this#327, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
    assert {:msg "  380.4: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#327, AVLTreeNode.left] == null, 0, Heap[Heap[this#327, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#327, AVLTreeNode.right] == null, 0, Heap[Heap[this#327, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
    assert {:msg "  380.4: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  380.4: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_953[this#327, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_953[this#327, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_953[this#327, AVLTreeNode.key][perm$N]));
    exhaleMask#_953[this#327, AVLTreeNode.key] := exhaleMask#_953[this#327, AVLTreeNode.key][perm$R := exhaleMask#_953[this#327, AVLTreeNode.key][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_953);
    assume wf(Heap, exhaleMask#_953, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  380.4: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  380.4: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_953[this#327, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_953[this#327, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_953[this#327, AVLTreeNode.height][perm$N]));
    exhaleMask#_953[this#327, AVLTreeNode.height] := exhaleMask#_953[this#327, AVLTreeNode.height][perm$R := exhaleMask#_953[this#327, AVLTreeNode.height][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_953);
    assume wf(Heap, exhaleMask#_953, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  380.4: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  380.4: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_953[this#327, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_953[this#327, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_953[this#327, AVLTreeNode.left][perm$N]));
    exhaleMask#_953[this#327, AVLTreeNode.left] := exhaleMask#_953[this#327, AVLTreeNode.left][perm$R := exhaleMask#_953[this#327, AVLTreeNode.left][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_953);
    assume wf(Heap, exhaleMask#_953, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  380.4: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  380.4: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_953[this#327, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_953[this#327, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_953[this#327, AVLTreeNode.right][perm$N]));
    exhaleMask#_953[this#327, AVLTreeNode.right] := exhaleMask#_953[this#327, AVLTreeNode.right][perm$R := exhaleMask#_953[this#327, AVLTreeNode.right][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_953);
    assume wf(Heap, exhaleMask#_953, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  380.4: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  380.4: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_953[this#327, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_953[this#327, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_953[this#327, AVLTreeNode.keys][perm$N]));
    exhaleMask#_953[this#327, AVLTreeNode.keys] := exhaleMask#_953[this#327, AVLTreeNode.keys][perm$R := exhaleMask#_953[this#327, AVLTreeNode.keys][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_953);
    assume wf(Heap, exhaleMask#_953, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  380.4: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  380.4: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_953[this#327, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_953[this#327, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_953[this#327, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_953[this#327, AVLTreeNode.balanceFactor] := exhaleMask#_953[this#327, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_953[this#327, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_953);
    assume wf(Heap, exhaleMask#_953, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#327, AVLTreeNode.left] == null)) {
      assert {:msg "  380.4: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
      assert {:msg "  380.4: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (!CanRead(exhaleMask#_953, SecMask, Heap[this#327, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#327, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_952[Heap[this#327, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_953);
      assume wf(Heap, exhaleMask#_953, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#327, AVLTreeNode.left] == null)) {
      assert {:msg "  380.4: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
      assert {:msg "  380.4: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_953);
      assume wf(Heap, exhaleMask#_953, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#327, AVLTreeNode.left] == null)) {
      assert {:msg "  380.4: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
      assert {:msg "  380.4: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_953);
      assume wf(Heap, exhaleMask#_953, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#327, AVLTreeNode.left] == null)) {
      assert {:msg "  380.4: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
      assert {:msg "  380.4: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_953[Heap[this#327, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_953);
      assume wf(Heap, exhaleMask#_953, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#327, AVLTreeNode.right] == null)) {
      assert {:msg "  380.4: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
      assert {:msg "  380.4: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (!CanRead(exhaleMask#_953, SecMask, Heap[this#327, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#327, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_952[Heap[this#327, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_953);
      assume wf(Heap, exhaleMask#_953, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#327, AVLTreeNode.right] == null)) {
      assert {:msg "  380.4: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  380.4: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_953);
      assume wf(Heap, exhaleMask#_953, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#327, AVLTreeNode.right] == null)) {
      assert {:msg "  380.4: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  380.4: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_953);
      assume wf(Heap, exhaleMask#_953, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#327, AVLTreeNode.right] == null)) {
      assert {:msg "  380.4: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  380.4: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_953[Heap[this#327, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_953);
      assume wf(Heap, exhaleMask#_953, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_953;
    assume IsGoodExhaleState(exhaleHeap#_952, Heap, Mask, SecMask);
    Heap := exhaleHeap#_952;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    // inhale (postcondition)
    assume this#327 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[this#327, AVLTreeNode.valid] := Mask[this#327, AVLTreeNode.valid][perm$R := Mask[this#327, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#327, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#327 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[this#327, AVLTreeNode.height] := Mask[this#327, AVLTreeNode.height][perm$R := Mask[this#327, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#327, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#327 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[this#327, AVLTreeNode.keys] := Mask[this#327, AVLTreeNode.keys][perm$R := Mask[this#327, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#327, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#327 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[this#327, AVLTreeNode.balanceFactor] := Mask[this#327, AVLTreeNode.balanceFactor][perm$R := Mask[this#327, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#327, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Seq#Equal(Heap[this#327, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_947[this#327, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_947[callHeap#_947[this#327, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_947[this#327, AVLTreeNode.key])), ite(callHeap#_947[this#327, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_947[callHeap#_947[this#327, AVLTreeNode.right], AVLTreeNode.keys])));
    assume Heap[this#327, AVLTreeNode.height] == ite(ite(callHeap#_947[this#327, AVLTreeNode.left] == null, 0, callHeap#_947[callHeap#_947[this#327, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_947[this#327, AVLTreeNode.right] == null, 0, callHeap#_947[callHeap#_947[this#327, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_947[this#327, AVLTreeNode.left] == null, 0, callHeap#_947[callHeap#_947[this#327, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_947[this#327, AVLTreeNode.right] == null, 0, callHeap#_947[callHeap#_947[this#327, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap[this#327, AVLTreeNode.balanceFactor] == (ite(callHeap#_947[this#327, AVLTreeNode.left] == null, 0, callHeap#_947[callHeap#_947[this#327, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_947[this#327, AVLTreeNode.right] == null, 0, callHeap#_947[callHeap#_947[this#327, AVLTreeNode.right], AVLTreeNode.height]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    // assigment to m
    m#36 := this;
    // assert
    assertHeap#_970 := Heap;
    assertMask#_971 := Mask;
    assertSecMask#_972 := SecMask;
    assertCredits#_973 := Credits;
    assume wf(assertHeap#_970, assertMask#_971, assertSecMask#_972);
    // begin exhale (assert)
    exhaleMask#_975 := assertMask#_971;
    havoc exhaleHeap#_974;
    if (!(r#35 == null)) {
      assert {:msg "  382.11: Receiver might be null."} true && (0 <= k#87#333) ==> (r#35 != null);
      assert {:msg "  382.11: Location might not be readable."} true && (0 <= k#87#333) ==> CanRead(assertMask#_971, assertSecMask#_972, r#35, AVLTreeNode.keys);
      assert {:msg "  382.11: Receiver might be null."} true && (0 <= k#87#333) && (k#87#333 < Seq#Length(assertHeap#_970[r#35, AVLTreeNode.keys])) ==> (r#35 != null);
      assert {:msg "  382.11: Location might not be readable."} true && (0 <= k#87#333) && (k#87#333 < Seq#Length(assertHeap#_970[r#35, AVLTreeNode.keys])) ==> CanRead(assertMask#_971, assertSecMask#_972, r#35, AVLTreeNode.keys);
      assert {:msg "  382.45: Sequence index might be negative."} true && (0 <= k#87#333) && (k#87#333 < Seq#Length(assertHeap#_970[r#35, AVLTreeNode.keys])) ==> (0 <= k#87#333);
      assert {:msg "  382.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#87#333) && (k#87#333 < Seq#Length(assertHeap#_970[r#35, AVLTreeNode.keys])) ==> (k#87#333 < Seq#Length(assertHeap#_970[r#35, AVLTreeNode.keys]));
      assert {:msg "  382.49: Receiver might be null."} true && (0 <= k#87#333) && (k#87#333 < Seq#Length(assertHeap#_970[r#35, AVLTreeNode.keys])) ==> (m#36 != null);
      assert {:msg "  382.49: Location might not be readable."} true && (0 <= k#87#333) && (k#87#333 < Seq#Length(assertHeap#_970[r#35, AVLTreeNode.keys])) ==> CanRead(assertMask#_971, assertSecMask#_972, m#36, AVLTreeNode.keys);
      assert {:msg "  382.49: Sequence index might be negative."} true && (0 <= k#87#333) && (k#87#333 < Seq#Length(assertHeap#_970[r#35, AVLTreeNode.keys])) ==> (0 <= 0);
      assert {:msg "  382.49: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#87#333) && (k#87#333 < Seq#Length(assertHeap#_970[r#35, AVLTreeNode.keys])) ==> (0 < Seq#Length(assertHeap#_970[m#36, AVLTreeNode.keys]));
      assert {:msg "  382.4: Assertion might not hold. The expression at 382.23 might not evaluate to true."} (forall k#87#332: int :: (0 <= k#87#332) && (k#87#332 < Seq#Length(assertHeap#_970[r#35, AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_970[r#35, AVLTreeNode.keys], k#87#332) < Seq#Index(assertHeap#_970[m#36, AVLTreeNode.keys], 0)));
    }
    assertMask#_971 := exhaleMask#_975;
    assume IsGoodExhaleState(exhaleHeap#_974, assertHeap#_970, assertMask#_971, assertSecMask#_972);
    assertHeap#_970 := exhaleHeap#_974;
    assume IsGoodMask(assertMask#_971);
    assume wf(assertHeap#_970, assertMask#_971, assertSecMask#_972);
    // end exhale
  } else {
    // local var nr
    assume (0 < methodCallK#_980) && ((1000 * methodCallK#_980) < Fractions(1)) && ((1000 * methodCallK#_980) < methodK#_923);
    // call pruneMax
    callHeap#_976 := Heap;
    callMask#_977 := Mask;
    callSecMask#_978 := SecMask;
    callCredits#_979 := Credits;
    assume wf(callHeap#_976, callMask#_977, callSecMask#_978);
    assert {:msg "  387.17: Receiver might be null."} true ==> (this != null);
    assert {:msg "  387.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  387.4: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
    this#335 := Heap[this, AVLTreeNode.right];
    // begin exhale (precondition)
    exhaleMask#_982 := Mask;
    havoc exhaleHeap#_981;
    assert {:msg "  387.4: The precondition at 349.12 might not hold. The permission at 349.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  387.4: The precondition at 349.12 might not hold. Insufficient fraction at 349.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_982[this#335, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_982[this#335, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_982[this#335, AVLTreeNode.valid][perm$N]));
    exhaleMask#_982[this#335, AVLTreeNode.valid] := exhaleMask#_982[this#335, AVLTreeNode.valid][perm$R := exhaleMask#_982[this#335, AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_982, SecMask, this#335, AVLTreeNode.valid)) {
      assume Heap[this#335, AVLTreeNode.valid] < exhaleHeap#_981[this#335, AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_982);
    assume wf(Heap, exhaleMask#_982, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  387.4: The precondition at 350.12 might not hold. The permission at 350.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  387.4: The precondition at 350.12 might not hold. Insufficient fraction at 350.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_982[this#335, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_982[this#335, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_982[this#335, AVLTreeNode.keys][perm$N]));
    exhaleMask#_982[this#335, AVLTreeNode.keys] := exhaleMask#_982[this#335, AVLTreeNode.keys][perm$R := exhaleMask#_982[this#335, AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_982);
    assume wf(Heap, exhaleMask#_982, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  387.4: The precondition at 351.12 might not hold. The permission at 351.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  387.4: The precondition at 351.12 might not hold. Insufficient fraction at 351.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_982[this#335, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_982[this#335, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_982[this#335, AVLTreeNode.height][perm$N]));
    exhaleMask#_982[this#335, AVLTreeNode.height] := exhaleMask#_982[this#335, AVLTreeNode.height][perm$R := exhaleMask#_982[this#335, AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_982);
    assume wf(Heap, exhaleMask#_982, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  387.4: The precondition at 352.12 might not hold. The permission at 352.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  387.4: The precondition at 352.12 might not hold. Insufficient fraction at 352.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_982[this#335, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_982[this#335, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_982[this#335, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_982[this#335, AVLTreeNode.balanceFactor] := exhaleMask#_982[this#335, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_982[this#335, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_982);
    assume wf(Heap, exhaleMask#_982, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_982;
    assume IsGoodExhaleState(exhaleHeap#_981, Heap, Mask, SecMask);
    Heap := exhaleHeap#_981;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#336;
    havoc m#337;
    // inhale (postcondition)
    if (!(r#336 == null)) {
      assume r#336 != null;
      assume wf(Heap, Mask, SecMask);
      assume Fractions(100) > 0;
      Mask[r#336, AVLTreeNode.valid] := Mask[r#336, AVLTreeNode.valid][perm$R := Mask[r#336, AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#336, AVLTreeNode.valid]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#336 == null)) {
      assume r#336 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#336, AVLTreeNode.keys] := Mask[r#336, AVLTreeNode.keys][perm$R := Mask[r#336, AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#336, AVLTreeNode.keys]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#336 == null)) {
      assume r#336 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#336, AVLTreeNode.height] := Mask[r#336, AVLTreeNode.height][perm$R := Mask[r#336, AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#336, AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#336 == null)) {
      assume r#336 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#336, AVLTreeNode.balanceFactor] := Mask[r#336, AVLTreeNode.balanceFactor][perm$R := Mask[r#336, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#336, AVLTreeNode.balanceFactor]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#336 == null)) {
      assume (Heap[r#336, AVLTreeNode.height] == callHeap#_976[this#335, AVLTreeNode.height]) || ((Heap[r#336, AVLTreeNode.height] + 1) == callHeap#_976[this#335, AVLTreeNode.height]);
    }
    if (!(r#336 == null)) {
      assume (Seq#Length(Heap[r#336, AVLTreeNode.keys]) + 1) == Seq#Length(callHeap#_976[this#335, AVLTreeNode.keys]);
    }
    if (callHeap#_976[this#335, AVLTreeNode.height] > 1) {
      assume !(r#336 == null);
    }
    if (callHeap#_976[this#335, AVLTreeNode.height] == 1) {
      assume r#336 == null;
    }
    assume (callHeap#_976[this#335, AVLTreeNode.height] == ite(r#336 == null, 0, Heap[r#336, AVLTreeNode.height])) || (callHeap#_976[this#335, AVLTreeNode.height] == (ite(r#336 == null, 0, Heap[r#336, AVLTreeNode.height]) + 1));
    assume !(m#337 == null);
    assume m#337 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[m#337, AVLTreeNode.valid] := Mask[m#337, AVLTreeNode.valid][perm$R := Mask[m#337, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[m#337, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume m#337 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[m#337, AVLTreeNode.keys] := Mask[m#337, AVLTreeNode.keys][perm$R := Mask[m#337, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[m#337, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume m#337 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[m#337, AVLTreeNode.height] := Mask[m#337, AVLTreeNode.height][perm$R := Mask[m#337, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[m#337, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume m#337 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[m#337, AVLTreeNode.balanceFactor] := Mask[m#337, AVLTreeNode.balanceFactor][perm$R := Mask[m#337, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[m#337, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Heap[m#337, AVLTreeNode.height] == 1;
    assume Seq#Length(Heap[m#337, AVLTreeNode.keys]) == 1;
    assume Seq#Equal(Seq#Append(ite(r#336 == null, Seq#Empty(), Heap[r#336, AVLTreeNode.keys]), Heap[m#337, AVLTreeNode.keys]), callHeap#_976[this#335, AVLTreeNode.keys]);
    if (!(r#336 == null)) {
      assume (forall k#86#338: int :: (0 <= k#86#338) && (k#86#338 < Seq#Length(Heap[r#336, AVLTreeNode.keys])) ==> (Seq#Index(Heap[r#336, AVLTreeNode.keys], k#86#338) < Seq#Index(Heap[m#337, AVLTreeNode.keys], 0)));
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    nr#38 := r#336;
    m#36 := m#337;
    // update field right
    assert {:msg "  388.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
    Heap[this, AVLTreeNode.right] := nr#38;
    assume wf(Heap, Mask, SecMask);
    // local var bf
    assume (0 < methodCallK#_993) && ((1000 * methodCallK#_993) < Fractions(1)) && ((1000 * methodCallK#_993) < methodK#_923);
    // call getBalanceFactorI
    callHeap#_989 := Heap;
    callMask#_990 := Mask;
    callSecMask#_991 := SecMask;
    callCredits#_992 := Credits;
    assume wf(callHeap#_989, callMask#_990, callSecMask#_991);
    assert {:msg "  390.4: The target of the method call might be null."} this != null;
    this#339 := this;
    // begin exhale (precondition)
    exhaleMask#_995 := Mask;
    havoc exhaleHeap#_994;
    assert {:msg "  390.4: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_993 > 0;
    assert {:msg "  390.4: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_995[this#339, AVLTreeNode.left][perm$R] > 0;
    assume methodCallK#_993 < exhaleMask#_995[this#339, AVLTreeNode.left][perm$R];
    exhaleMask#_995[this#339, AVLTreeNode.left] := exhaleMask#_995[this#339, AVLTreeNode.left][perm$R := exhaleMask#_995[this#339, AVLTreeNode.left][perm$R] - methodCallK#_993];
    assume IsGoodMask(exhaleMask#_995);
    assume wf(Heap, exhaleMask#_995, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#339, AVLTreeNode.left] == null)) {
      assert {:msg "  390.4: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_993 > 0;
      assert {:msg "  390.4: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_995[Heap[this#339, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0;
      assume methodCallK#_993 < exhaleMask#_995[Heap[this#339, AVLTreeNode.left], AVLTreeNode.height][perm$R];
      exhaleMask#_995[Heap[this#339, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_995[Heap[this#339, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_995[Heap[this#339, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_993];
      assume IsGoodMask(exhaleMask#_995);
      assume wf(Heap, exhaleMask#_995, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assert {:msg "  390.4: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_993 > 0;
    assert {:msg "  390.4: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_995[this#339, AVLTreeNode.right][perm$R] > 0;
    assume methodCallK#_993 < exhaleMask#_995[this#339, AVLTreeNode.right][perm$R];
    exhaleMask#_995[this#339, AVLTreeNode.right] := exhaleMask#_995[this#339, AVLTreeNode.right][perm$R := exhaleMask#_995[this#339, AVLTreeNode.right][perm$R] - methodCallK#_993];
    assume IsGoodMask(exhaleMask#_995);
    assume wf(Heap, exhaleMask#_995, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#339, AVLTreeNode.right] == null)) {
      assert {:msg "  390.4: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_993 > 0;
      assert {:msg "  390.4: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_995[Heap[this#339, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0;
      assume methodCallK#_993 < exhaleMask#_995[Heap[this#339, AVLTreeNode.right], AVLTreeNode.height][perm$R];
      exhaleMask#_995[Heap[this#339, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_995[Heap[this#339, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_995[Heap[this#339, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_993];
      assume IsGoodMask(exhaleMask#_995);
      assume wf(Heap, exhaleMask#_995, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#339, AVLTreeNode.left] == null)) {
      assert {:msg "  390.4: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} Fractions(100) > 0;
      assert {:msg "  390.4: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_995[Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_995[Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_995[Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_995[Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_995[Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_995[Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (!CanRead(exhaleMask#_995, SecMask, Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_994[Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_995);
      assume wf(Heap, exhaleMask#_995, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#339, AVLTreeNode.right] == null)) {
      assert {:msg "  390.4: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} Fractions(100) > 0;
      assert {:msg "  390.4: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_995[Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_995[Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_995[Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_995[Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_995[Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_995[Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (!CanRead(exhaleMask#_995, SecMask, Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_994[Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_995);
      assume wf(Heap, exhaleMask#_995, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_995;
    assume IsGoodExhaleState(exhaleHeap#_994, Heap, Mask, SecMask);
    Heap := exhaleHeap#_994;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc bf#340;
    // inhale (postcondition)
    assume this#339 != null;
    assume wf(Heap, Mask, SecMask);
    assume (Heap[this#339, AVLTreeNode.left] == null) || (dtype(Heap[this#339, AVLTreeNode.left]) == AVLTreeNode#t);
    assume methodCallK#_993 > 0;
    Mask[this#339, AVLTreeNode.left] := Mask[this#339, AVLTreeNode.left][perm$R := Mask[this#339, AVLTreeNode.left][perm$R] + methodCallK#_993];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#339, AVLTreeNode.left]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#339, AVLTreeNode.left] == null)) {
      assume Heap[this#339, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume Fractions(100) > 0;
      Mask[Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[Heap[this#339, AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#339, AVLTreeNode.left] == null)) {
      assume Heap[this#339, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume methodCallK#_993 > 0;
      Mask[Heap[this#339, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#339, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#339, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_993];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[Heap[this#339, AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume this#339 != null;
    assume wf(Heap, Mask, SecMask);
    assume (Heap[this#339, AVLTreeNode.right] == null) || (dtype(Heap[this#339, AVLTreeNode.right]) == AVLTreeNode#t);
    assume methodCallK#_993 > 0;
    Mask[this#339, AVLTreeNode.right] := Mask[this#339, AVLTreeNode.right][perm$R := Mask[this#339, AVLTreeNode.right][perm$R] + methodCallK#_993];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#339, AVLTreeNode.right]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#339, AVLTreeNode.right] == null)) {
      assume Heap[this#339, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume Fractions(100) > 0;
      Mask[Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[Heap[this#339, AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#339, AVLTreeNode.right] == null)) {
      assume Heap[this#339, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume methodCallK#_993 > 0;
      Mask[Heap[this#339, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#339, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#339, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_993];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[Heap[this#339, AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume bf#340 == (ite(Heap[this#339, AVLTreeNode.left] == null, 0, Heap[Heap[this#339, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#339, AVLTreeNode.right] == null, 0, Heap[Heap[this#339, AVLTreeNode.right], AVLTreeNode.height]));
    if (bf#340 > 0) {
      assume !(Heap[this#339, AVLTreeNode.left] == null);
    }
    if (bf#340 < 0) {
      assume !(Heap[this#339, AVLTreeNode.right] == null);
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    bf#40 := bf#340;
    // if
    cond#_1004 := bf#40 == 2;
    if (cond#_1004) {
      assume (0 < methodCallK#_1009) && ((1000 * methodCallK#_1009) < Fractions(1)) && ((1000 * methodCallK#_1009) < methodK#_923);
      // call rebalanceLeft
      callHeap#_1005 := Heap;
      callMask#_1006 := Mask;
      callSecMask#_1007 := SecMask;
      callCredits#_1008 := Credits;
      assume wf(callHeap#_1005, callMask#_1006, callSecMask#_1007);
      assert {:msg "  392.5: The target of the method call might be null."} this != null;
      this#341 := this;
      // begin exhale (precondition)
      exhaleMask#_1011 := Mask;
      havoc exhaleHeap#_1010;
      assert {:msg "  392.5: The precondition at 608.12 might not hold. The expression at 608.12 might not evaluate to true."} !(Heap[this#341, AVLTreeNode.left] == null);
      assert {:msg "  392.5: The precondition at 613.12 might not hold. The expression at 613.12 might not evaluate to true."} (forall k#94#343: int :: (0 <= k#94#343) && (k#94#343 < Seq#Length(Heap[Heap[this#341, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#341, AVLTreeNode.left], AVLTreeNode.keys], k#94#343) < Heap[this#341, AVLTreeNode.key]));
      if (!(Heap[this#341, AVLTreeNode.right] == null)) {
        assert {:msg "  392.5: The precondition at 619.12 might not hold. The expression at 619.28 might not evaluate to true."} (forall k#95#344: int :: (0 <= k#95#344) && (k#95#344 < Seq#Length(Heap[Heap[this#341, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#341, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#341, AVLTreeNode.right], AVLTreeNode.keys], k#95#344)));
      }
      assert {:msg "  392.5: The precondition at 621.12 might not hold. The expression at 621.12 might not evaluate to true."} (Heap[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#341, AVLTreeNode.right] == null, 0, Heap[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height])) == 2;
      assert {:msg "  392.5: The precondition at 600.12 might not hold. The permission at 600.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  392.5: The precondition at 600.12 might not hold. Insufficient fraction at 600.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_1011[this#341, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_1011[this#341, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1011[this#341, AVLTreeNode.key][perm$N]));
      exhaleMask#_1011[this#341, AVLTreeNode.key] := exhaleMask#_1011[this#341, AVLTreeNode.key][perm$R := exhaleMask#_1011[this#341, AVLTreeNode.key][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1011);
      assume wf(Heap, exhaleMask#_1011, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 601.12 might not hold. The permission at 601.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  392.5: The precondition at 601.12 might not hold. Insufficient fraction at 601.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_1011[this#341, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_1011[this#341, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1011[this#341, AVLTreeNode.height][perm$N]));
      exhaleMask#_1011[this#341, AVLTreeNode.height] := exhaleMask#_1011[this#341, AVLTreeNode.height][perm$R := exhaleMask#_1011[this#341, AVLTreeNode.height][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1011);
      assume wf(Heap, exhaleMask#_1011, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 602.12 might not hold. The permission at 602.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  392.5: The precondition at 602.12 might not hold. Insufficient fraction at 602.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_1011[this#341, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_1011[this#341, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1011[this#341, AVLTreeNode.left][perm$N]));
      exhaleMask#_1011[this#341, AVLTreeNode.left] := exhaleMask#_1011[this#341, AVLTreeNode.left][perm$R := exhaleMask#_1011[this#341, AVLTreeNode.left][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1011);
      assume wf(Heap, exhaleMask#_1011, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 603.12 might not hold. The permission at 603.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  392.5: The precondition at 603.12 might not hold. Insufficient fraction at 603.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_1011[this#341, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_1011[this#341, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1011[this#341, AVLTreeNode.right][perm$N]));
      exhaleMask#_1011[this#341, AVLTreeNode.right] := exhaleMask#_1011[this#341, AVLTreeNode.right][perm$R := exhaleMask#_1011[this#341, AVLTreeNode.right][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1011);
      assume wf(Heap, exhaleMask#_1011, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 605.12 might not hold. The permission at 605.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  392.5: The precondition at 605.12 might not hold. Insufficient fraction at 605.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_1011[this#341, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_1011[this#341, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1011[this#341, AVLTreeNode.keys][perm$N]));
      exhaleMask#_1011[this#341, AVLTreeNode.keys] := exhaleMask#_1011[this#341, AVLTreeNode.keys][perm$R := exhaleMask#_1011[this#341, AVLTreeNode.keys][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1011);
      assume wf(Heap, exhaleMask#_1011, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 606.12 might not hold. The permission at 606.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  392.5: The precondition at 606.12 might not hold. Insufficient fraction at 606.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_1011[this#341, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_1011[this#341, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1011[this#341, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1011[this#341, AVLTreeNode.balanceFactor] := exhaleMask#_1011[this#341, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1011[this#341, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1011);
      assume wf(Heap, exhaleMask#_1011, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 609.12 might not hold. The permission at 609.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  392.5: The precondition at 609.12 might not hold. Insufficient fraction at 609.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (!CanRead(exhaleMask#_1011, SecMask, Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1010[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_1011);
      assume wf(Heap, exhaleMask#_1011, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 610.12 might not hold. The permission at 610.12 might not be positive."} Fractions(50) > 0;
      assert {:msg "  392.5: The precondition at 610.12 might not hold. Insufficient fraction at 610.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1011);
      assume wf(Heap, exhaleMask#_1011, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 611.12 might not hold. The permission at 611.12 might not be positive."} Fractions(50) > 0;
      assert {:msg "  392.5: The precondition at 611.12 might not hold. Insufficient fraction at 611.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1011);
      assume wf(Heap, exhaleMask#_1011, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 612.12 might not hold. The permission at 612.12 might not be positive."} Fractions(50) > 0;
      assert {:msg "  392.5: The precondition at 612.12 might not hold. Insufficient fraction at 612.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1011[Heap[this#341, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1011);
      assume wf(Heap, exhaleMask#_1011, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#341, AVLTreeNode.right] == null)) {
        assert {:msg "  392.5: The precondition at 615.12 might not hold. The permission at 615.28 might not be positive."} Fractions(100) > 0;
        assert {:msg "  392.5: The precondition at 615.12 might not hold. Insufficient fraction at 615.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_1011, SecMask, Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1010[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_1011);
        assume wf(Heap, exhaleMask#_1011, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#341, AVLTreeNode.right] == null)) {
        assert {:msg "  392.5: The precondition at 616.12 might not hold. The permission at 616.28 might not be positive."} Fractions(50) > 0;
        assert {:msg "  392.5: The precondition at 616.12 might not hold. Insufficient fraction at 616.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1011);
        assume wf(Heap, exhaleMask#_1011, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#341, AVLTreeNode.right] == null)) {
        assert {:msg "  392.5: The precondition at 617.12 might not hold. The permission at 617.28 might not be positive."} Fractions(50) > 0;
        assert {:msg "  392.5: The precondition at 617.12 might not hold. Insufficient fraction at 617.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1011);
        assume wf(Heap, exhaleMask#_1011, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#341, AVLTreeNode.right] == null)) {
        assert {:msg "  392.5: The precondition at 618.12 might not hold. The permission at 618.28 might not be positive."} Fractions(50) > 0;
        assert {:msg "  392.5: The precondition at 618.12 might not hold. Insufficient fraction at 618.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1011[Heap[this#341, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1011);
        assume wf(Heap, exhaleMask#_1011, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_1011;
      assume IsGoodExhaleState(exhaleHeap#_1010, Heap, Mask, SecMask);
      Heap := exhaleHeap#_1010;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      havoc r#342;
      // inhale (postcondition)
      assume !(r#342 == null);
      assume r#342 != null;
      assume wf(Heap, Mask, SecMask);
      assume Fractions(100) > 0;
      Mask[r#342, AVLTreeNode.valid] := Mask[r#342, AVLTreeNode.valid][perm$R := Mask[r#342, AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#342, AVLTreeNode.valid]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#342 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#342, AVLTreeNode.height] := Mask[r#342, AVLTreeNode.height][perm$R := Mask[r#342, AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#342, AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#342 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#342, AVLTreeNode.keys] := Mask[r#342, AVLTreeNode.keys][perm$R := Mask[r#342, AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#342, AVLTreeNode.keys]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#342 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#342, AVLTreeNode.balanceFactor] := Mask[r#342, AVLTreeNode.balanceFactor][perm$R := Mask[r#342, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#342, AVLTreeNode.balanceFactor]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume (Heap[r#342, AVLTreeNode.height] == callHeap#_1005[callHeap#_1005[this#341, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#342, AVLTreeNode.height] == (callHeap#_1005[callHeap#_1005[this#341, AVLTreeNode.left], AVLTreeNode.height] + 1));
      assume Seq#Equal(Heap[r#342, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_1005[callHeap#_1005[this#341, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_1005[this#341, AVLTreeNode.key])), ite(callHeap#_1005[this#341, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1005[callHeap#_1005[this#341, AVLTreeNode.right], AVLTreeNode.keys])));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      r#35 := r#342;
    } else {
      assume (0 < methodCallK#_1032) && ((1000 * methodCallK#_1032) < Fractions(1)) && ((1000 * methodCallK#_1032) < methodK#_923);
      // call close
      callHeap#_1028 := Heap;
      callMask#_1029 := Mask;
      callSecMask#_1030 := SecMask;
      callCredits#_1031 := Credits;
      assume wf(callHeap#_1028, callMask#_1029, callSecMask#_1030);
      assert {:msg "  394.5: The target of the method call might be null."} this != null;
      this#347 := this;
      // begin exhale (precondition)
      exhaleMask#_1034 := Mask;
      havoc exhaleHeap#_1033;
      if (!(Heap[this#347, AVLTreeNode.left] == null)) {
        assert {:msg "  394.5: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#348: int :: (0 <= k#92#348) && (k#92#348 < Seq#Length(Heap[Heap[this#347, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#347, AVLTreeNode.left], AVLTreeNode.keys], k#92#348) < Heap[this#347, AVLTreeNode.key]));
      }
      if (!(Heap[this#347, AVLTreeNode.right] == null)) {
        assert {:msg "  394.5: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#349: int :: (0 <= k#93#349) && (k#93#349 < Seq#Length(Heap[Heap[this#347, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#347, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#347, AVLTreeNode.right], AVLTreeNode.keys], k#93#349)));
      }
      assert {:msg "  394.5: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#347, AVLTreeNode.left] == null, 0, Heap[Heap[this#347, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#347, AVLTreeNode.right] == null, 0, Heap[Heap[this#347, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
      assert {:msg "  394.5: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#347, AVLTreeNode.left] == null, 0, Heap[Heap[this#347, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#347, AVLTreeNode.right] == null, 0, Heap[Heap[this#347, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
      assert {:msg "  394.5: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  394.5: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_1034[this#347, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_1034[this#347, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1034[this#347, AVLTreeNode.key][perm$N]));
      exhaleMask#_1034[this#347, AVLTreeNode.key] := exhaleMask#_1034[this#347, AVLTreeNode.key][perm$R := exhaleMask#_1034[this#347, AVLTreeNode.key][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1034);
      assume wf(Heap, exhaleMask#_1034, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  394.5: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  394.5: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_1034[this#347, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_1034[this#347, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1034[this#347, AVLTreeNode.height][perm$N]));
      exhaleMask#_1034[this#347, AVLTreeNode.height] := exhaleMask#_1034[this#347, AVLTreeNode.height][perm$R := exhaleMask#_1034[this#347, AVLTreeNode.height][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1034);
      assume wf(Heap, exhaleMask#_1034, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  394.5: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  394.5: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_1034[this#347, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_1034[this#347, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1034[this#347, AVLTreeNode.left][perm$N]));
      exhaleMask#_1034[this#347, AVLTreeNode.left] := exhaleMask#_1034[this#347, AVLTreeNode.left][perm$R := exhaleMask#_1034[this#347, AVLTreeNode.left][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1034);
      assume wf(Heap, exhaleMask#_1034, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  394.5: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  394.5: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_1034[this#347, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_1034[this#347, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1034[this#347, AVLTreeNode.right][perm$N]));
      exhaleMask#_1034[this#347, AVLTreeNode.right] := exhaleMask#_1034[this#347, AVLTreeNode.right][perm$R := exhaleMask#_1034[this#347, AVLTreeNode.right][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1034);
      assume wf(Heap, exhaleMask#_1034, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  394.5: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  394.5: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_1034[this#347, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_1034[this#347, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1034[this#347, AVLTreeNode.keys][perm$N]));
      exhaleMask#_1034[this#347, AVLTreeNode.keys] := exhaleMask#_1034[this#347, AVLTreeNode.keys][perm$R := exhaleMask#_1034[this#347, AVLTreeNode.keys][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1034);
      assume wf(Heap, exhaleMask#_1034, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  394.5: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  394.5: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_1034[this#347, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_1034[this#347, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1034[this#347, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1034[this#347, AVLTreeNode.balanceFactor] := exhaleMask#_1034[this#347, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1034[this#347, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1034);
      assume wf(Heap, exhaleMask#_1034, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#347, AVLTreeNode.left] == null)) {
        assert {:msg "  394.5: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
        assert {:msg "  394.5: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_1034, SecMask, Heap[this#347, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#347, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1033[Heap[this#347, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_1034);
        assume wf(Heap, exhaleMask#_1034, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#347, AVLTreeNode.left] == null)) {
        assert {:msg "  394.5: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
        assert {:msg "  394.5: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1034);
        assume wf(Heap, exhaleMask#_1034, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#347, AVLTreeNode.left] == null)) {
        assert {:msg "  394.5: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
        assert {:msg "  394.5: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1034);
        assume wf(Heap, exhaleMask#_1034, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#347, AVLTreeNode.left] == null)) {
        assert {:msg "  394.5: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
        assert {:msg "  394.5: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1034[Heap[this#347, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1034);
        assume wf(Heap, exhaleMask#_1034, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#347, AVLTreeNode.right] == null)) {
        assert {:msg "  394.5: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
        assert {:msg "  394.5: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_1034, SecMask, Heap[this#347, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#347, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1033[Heap[this#347, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_1034);
        assume wf(Heap, exhaleMask#_1034, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#347, AVLTreeNode.right] == null)) {
        assert {:msg "  394.5: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
        assert {:msg "  394.5: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1034);
        assume wf(Heap, exhaleMask#_1034, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#347, AVLTreeNode.right] == null)) {
        assert {:msg "  394.5: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
        assert {:msg "  394.5: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1034);
        assume wf(Heap, exhaleMask#_1034, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#347, AVLTreeNode.right] == null)) {
        assert {:msg "  394.5: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
        assert {:msg "  394.5: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1034[Heap[this#347, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1034);
        assume wf(Heap, exhaleMask#_1034, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_1034;
      assume IsGoodExhaleState(exhaleHeap#_1033, Heap, Mask, SecMask);
      Heap := exhaleHeap#_1033;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      // inhale (postcondition)
      assume this#347 != null;
      assume wf(Heap, Mask, SecMask);
      assume Fractions(100) > 0;
      Mask[this#347, AVLTreeNode.valid] := Mask[this#347, AVLTreeNode.valid][perm$R := Mask[this#347, AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#347, AVLTreeNode.valid]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#347 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[this#347, AVLTreeNode.height] := Mask[this#347, AVLTreeNode.height][perm$R := Mask[this#347, AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#347, AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#347 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[this#347, AVLTreeNode.keys] := Mask[this#347, AVLTreeNode.keys][perm$R := Mask[this#347, AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#347, AVLTreeNode.keys]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#347 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[this#347, AVLTreeNode.balanceFactor] := Mask[this#347, AVLTreeNode.balanceFactor][perm$R := Mask[this#347, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#347, AVLTreeNode.balanceFactor]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume Seq#Equal(Heap[this#347, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1028[this#347, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1028[callHeap#_1028[this#347, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1028[this#347, AVLTreeNode.key])), ite(callHeap#_1028[this#347, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1028[callHeap#_1028[this#347, AVLTreeNode.right], AVLTreeNode.keys])));
      assume Heap[this#347, AVLTreeNode.height] == ite(ite(callHeap#_1028[this#347, AVLTreeNode.left] == null, 0, callHeap#_1028[callHeap#_1028[this#347, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1028[this#347, AVLTreeNode.right] == null, 0, callHeap#_1028[callHeap#_1028[this#347, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1028[this#347, AVLTreeNode.left] == null, 0, callHeap#_1028[callHeap#_1028[this#347, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1028[this#347, AVLTreeNode.right] == null, 0, callHeap#_1028[callHeap#_1028[this#347, AVLTreeNode.right], AVLTreeNode.height]) + 1);
      assume Heap[this#347, AVLTreeNode.balanceFactor] == (ite(callHeap#_1028[this#347, AVLTreeNode.left] == null, 0, callHeap#_1028[callHeap#_1028[this#347, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1028[this#347, AVLTreeNode.right] == null, 0, callHeap#_1028[callHeap#_1028[this#347, AVLTreeNode.right], AVLTreeNode.height]));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      // assigment to r
      r#35 := this;
    }
    // assert
    assertHeap#_1051 := Heap;
    assertMask#_1052 := Mask;
    assertSecMask#_1053 := SecMask;
    assertCredits#_1054 := Credits;
    assume wf(assertHeap#_1051, assertMask#_1052, assertSecMask#_1053);
    // begin exhale (assert)
    exhaleMask#_1056 := assertMask#_1052;
    havoc exhaleHeap#_1055;
    if (!(r#35 == null)) {
      assert {:msg "  397.11: Receiver might be null."} true && (0 <= k#88#353) ==> (r#35 != null);
      assert {:msg "  397.11: Location might not be readable."} true && (0 <= k#88#353) ==> CanRead(assertMask#_1052, assertSecMask#_1053, r#35, AVLTreeNode.keys);
      assert {:msg "  397.11: Receiver might be null."} true && (0 <= k#88#353) && (k#88#353 < Seq#Length(assertHeap#_1051[r#35, AVLTreeNode.keys])) ==> (r#35 != null);
      assert {:msg "  397.11: Location might not be readable."} true && (0 <= k#88#353) && (k#88#353 < Seq#Length(assertHeap#_1051[r#35, AVLTreeNode.keys])) ==> CanRead(assertMask#_1052, assertSecMask#_1053, r#35, AVLTreeNode.keys);
      assert {:msg "  397.45: Sequence index might be negative."} true && (0 <= k#88#353) && (k#88#353 < Seq#Length(assertHeap#_1051[r#35, AVLTreeNode.keys])) ==> (0 <= k#88#353);
      assert {:msg "  397.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#88#353) && (k#88#353 < Seq#Length(assertHeap#_1051[r#35, AVLTreeNode.keys])) ==> (k#88#353 < Seq#Length(assertHeap#_1051[r#35, AVLTreeNode.keys]));
      assert {:msg "  397.49: Receiver might be null."} true && (0 <= k#88#353) && (k#88#353 < Seq#Length(assertHeap#_1051[r#35, AVLTreeNode.keys])) ==> (m#36 != null);
      assert {:msg "  397.49: Location might not be readable."} true && (0 <= k#88#353) && (k#88#353 < Seq#Length(assertHeap#_1051[r#35, AVLTreeNode.keys])) ==> CanRead(assertMask#_1052, assertSecMask#_1053, m#36, AVLTreeNode.keys);
      assert {:msg "  397.49: Sequence index might be negative."} true && (0 <= k#88#353) && (k#88#353 < Seq#Length(assertHeap#_1051[r#35, AVLTreeNode.keys])) ==> (0 <= 0);
      assert {:msg "  397.49: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#88#353) && (k#88#353 < Seq#Length(assertHeap#_1051[r#35, AVLTreeNode.keys])) ==> (0 < Seq#Length(assertHeap#_1051[m#36, AVLTreeNode.keys]));
      assert {:msg "  397.4: Assertion might not hold. The expression at 397.23 might not evaluate to true."} (forall k#88#352: int :: (0 <= k#88#352) && (k#88#352 < Seq#Length(assertHeap#_1051[r#35, AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1051[r#35, AVLTreeNode.keys], k#88#352) < Seq#Index(assertHeap#_1051[m#36, AVLTreeNode.keys], 0)));
    }
    assertMask#_1052 := exhaleMask#_1056;
    assume IsGoodExhaleState(exhaleHeap#_1055, assertHeap#_1051, assertMask#_1052, assertSecMask#_1053);
    assertHeap#_1051 := exhaleHeap#_1055;
    assume IsGoodMask(assertMask#_1052);
    assume wf(assertHeap#_1051, assertMask#_1052, assertSecMask#_1053);
    // end exhale
  }
  // begin exhale (postcondition)
  exhaleMask#_1058 := Mask;
  havoc exhaleHeap#_1057;
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 358.11 might not hold. The expression at 358.26 might not evaluate to true."} (Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || ((Heap[r#35, AVLTreeNode.height] + 1) == old(Heap)[this, AVLTreeNode.height]);
  }
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 359.11 might not hold. The expression at 359.24 might not evaluate to true."} (Seq#Length(Heap[r#35, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this, AVLTreeNode.keys]);
  }
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assert {:msg "  348.2: The postcondition at 360.11 might not hold. The expression at 360.30 might not evaluate to true."} !(r#35 == null);
  }
  if (old(Heap)[this, AVLTreeNode.height] == 1) {
    assert {:msg "  348.2: The postcondition at 361.11 might not hold. The expression at 361.30 might not evaluate to true."} r#35 == null;
  }
  assert {:msg "  348.2: The postcondition at 362.11 might not hold. The expression at 362.11 might not evaluate to true."} (old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height])) || (old(Heap)[this, AVLTreeNode.height] == (ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]) + 1));
  assert {:msg "  348.2: The postcondition at 364.11 might not hold. The expression at 364.11 might not evaluate to true."} !(m#36 == null);
  assert {:msg "  348.2: The postcondition at 369.11 might not hold. The expression at 369.11 might not evaluate to true."} Heap[m#36, AVLTreeNode.height] == 1;
  assert {:msg "  348.2: The postcondition at 370.11 might not hold. The expression at 370.11 might not evaluate to true."} Seq#Length(Heap[m#36, AVLTreeNode.keys]) == 1;
  assert {:msg "  348.2: The postcondition at 372.11 might not hold. The expression at 372.11 might not evaluate to true."} Seq#Equal(Seq#Append(ite(r#35 == null, Seq#Empty(), Heap[r#35, AVLTreeNode.keys]), Heap[m#36, AVLTreeNode.keys]), old(Heap)[this, AVLTreeNode.keys]);
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 373.11 might not hold. The expression at 373.23 might not evaluate to true."} (forall k#86#355: int :: (0 <= k#86#355) && (k#86#355 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (Seq#Index(Heap[r#35, AVLTreeNode.keys], k#86#355) < Seq#Index(Heap[m#36, AVLTreeNode.keys], 0)));
  }
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 354.11 might not hold. The permission at 354.25 might not be positive."} Fractions(100) > 0;
    assert {:msg "  348.2: The postcondition at 354.11 might not hold. Insufficient fraction at 354.25 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1058[r#35, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1058[r#35, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1058[r#35, AVLTreeNode.valid][perm$N]));
    exhaleMask#_1058[r#35, AVLTreeNode.valid] := exhaleMask#_1058[r#35, AVLTreeNode.valid][perm$R := exhaleMask#_1058[r#35, AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_1058, SecMask, r#35, AVLTreeNode.valid)) {
      assume Heap[r#35, AVLTreeNode.valid] < exhaleHeap#_1057[r#35, AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1058);
    assume wf(Heap, exhaleMask#_1058, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 355.11 might not hold. The permission at 355.25 might not be positive."} Fractions(50) > 0;
    assert {:msg "  348.2: The postcondition at 355.11 might not hold. Insufficient fraction at 355.25 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1058[r#35, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1058[r#35, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1058[r#35, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1058[r#35, AVLTreeNode.keys] := exhaleMask#_1058[r#35, AVLTreeNode.keys][perm$R := exhaleMask#_1058[r#35, AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1058);
    assume wf(Heap, exhaleMask#_1058, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 356.11 might not hold. The permission at 356.25 might not be positive."} Fractions(50) > 0;
    assert {:msg "  348.2: The postcondition at 356.11 might not hold. Insufficient fraction at 356.25 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1058[r#35, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1058[r#35, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1058[r#35, AVLTreeNode.height][perm$N]));
    exhaleMask#_1058[r#35, AVLTreeNode.height] := exhaleMask#_1058[r#35, AVLTreeNode.height][perm$R := exhaleMask#_1058[r#35, AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1058);
    assume wf(Heap, exhaleMask#_1058, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 357.11 might not hold. The permission at 357.25 might not be positive."} Fractions(50) > 0;
    assert {:msg "  348.2: The postcondition at 357.11 might not hold. Insufficient fraction at 357.25 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1058[r#35, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1058[r#35, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1058[r#35, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1058[r#35, AVLTreeNode.balanceFactor] := exhaleMask#_1058[r#35, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1058[r#35, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1058);
    assume wf(Heap, exhaleMask#_1058, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  348.2: The postcondition at 365.11 might not hold. The permission at 365.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  348.2: The postcondition at 365.11 might not hold. Insufficient fraction at 365.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1058[m#36, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1058[m#36, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1058[m#36, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1058[m#36, AVLTreeNode.valid] := exhaleMask#_1058[m#36, AVLTreeNode.valid][perm$R := exhaleMask#_1058[m#36, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (!CanRead(exhaleMask#_1058, SecMask, m#36, AVLTreeNode.valid)) {
    assume Heap[m#36, AVLTreeNode.valid] < exhaleHeap#_1057[m#36, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_1058);
  assume wf(Heap, exhaleMask#_1058, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  348.2: The postcondition at 366.11 might not hold. The permission at 366.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  348.2: The postcondition at 366.11 might not hold. Insufficient fraction at 366.11 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1058[m#36, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1058[m#36, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1058[m#36, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1058[m#36, AVLTreeNode.keys] := exhaleMask#_1058[m#36, AVLTreeNode.keys][perm$R := exhaleMask#_1058[m#36, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_1058);
  assume wf(Heap, exhaleMask#_1058, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  348.2: The postcondition at 367.11 might not hold. The permission at 367.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  348.2: The postcondition at 367.11 might not hold. Insufficient fraction at 367.11 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1058[m#36, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1058[m#36, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1058[m#36, AVLTreeNode.height][perm$N]));
  exhaleMask#_1058[m#36, AVLTreeNode.height] := exhaleMask#_1058[m#36, AVLTreeNode.height][perm$R := exhaleMask#_1058[m#36, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_1058);
  assume wf(Heap, exhaleMask#_1058, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  348.2: The postcondition at 368.11 might not hold. The permission at 368.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  348.2: The postcondition at 368.11 might not hold. Insufficient fraction at 368.11 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1058[m#36, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1058[m#36, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1058[m#36, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1058[m#36, AVLTreeNode.balanceFactor] := exhaleMask#_1058[m#36, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1058[m#36, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_1058);
  assume wf(Heap, exhaleMask#_1058, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1058;
  assume IsGoodExhaleState(exhaleHeap#_1057, Heap, Mask, SecMask);
  Heap := exhaleHeap#_1057;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  348.2: Method might lock/unlock more than allowed."} (forall lk#_1067: ref :: {Heap[lk#_1067, held]} {Heap[lk#_1067, rdheld]} (((0 < Heap[lk#_1067, held]) == (0 < old(Heap)[lk#_1067, held])) && (Heap[lk#_1067, rdheld] == old(Heap)[lk#_1067, rdheld])) || false);
  assert {:msg "  348.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.pruneMin$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#41: ref where (r#41 == null) || (dtype(r#41) == AVLTreeNode#t), m#42: ref where (m#42 == null) || (dtype(m#42) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1068: int;
  var k#89#358: int where true;
  assume (0 < methodK#_1068) && ((1000 * methodK#_1068) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  404.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  if (!(r#41 == null)) {
    assert {:msg "  409.25: Receiver might be null."} r#41 != null;
    assume r#41 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[r#41, AVLTreeNode.valid] := Mask[r#41, AVLTreeNode.valid][perm$R := Mask[r#41, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#41, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assume r#41 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#41, AVLTreeNode.keys] := Mask[r#41, AVLTreeNode.keys][perm$R := Mask[r#41, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#41, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assume r#41 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#41, AVLTreeNode.height] := Mask[r#41, AVLTreeNode.height][perm$R := Mask[r#41, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#41, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assume r#41 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#41, AVLTreeNode.balanceFactor] := Mask[r#41, AVLTreeNode.balanceFactor][perm$R := Mask[r#41, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#41, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assert {:msg "  413.26: Receiver might be null."} true ==> (r#41 != null);
    assert {:msg "  413.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#41, AVLTreeNode.height);
    assert {:msg "  413.42: Receiver might be null."} true ==> (this != null);
    assert {:msg "  413.42: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
    assert {:msg "  413.53: Receiver might be null."} true && (!(Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#41 != null);
    assert {:msg "  413.53: Location might not be readable."} true && (!(Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask, SecMask, r#41, AVLTreeNode.height);
    assert {:msg "  413.69: Receiver might be null."} true && (!(Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
    assert {:msg "  413.69: Location might not be readable."} true && (!(Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
    assume (Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
  }
  if (!(r#41 == null)) {
    assert {:msg "  414.25: Receiver might be null."} true ==> (r#41 != null);
    assert {:msg "  414.25: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#41, AVLTreeNode.keys);
    assert {:msg "  414.43: Receiver might be null."} true ==> (this != null);
    assert {:msg "  414.43: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
    assume (Seq#Length(Heap[r#41, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this, AVLTreeNode.keys]);
  }
  assert {:msg "  415.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  415.15: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assume !(r#41 == null);
  }
  assert {:msg "  416.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  416.15: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] == 1) {
    assume r#41 == null;
  }
  assert {:msg "  417.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  417.15: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
  if (r#41 == null) {
  } else {
    assert {:msg "  417.35: Receiver might be null."} true ==> (r#41 != null);
    assert {:msg "  417.35: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#41, AVLTreeNode.height);
  }
  assert {:msg "  417.52: Receiver might be null."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]))) ==> (this != null);
  assert {:msg "  417.52: Location might not be readable."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]))) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
  if (r#41 == null) {
  } else {
    assert {:msg "  417.72: Receiver might be null."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]))) ==> (r#41 != null);
    assert {:msg "  417.72: Location might not be readable."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]))) ==> CanRead(Mask, SecMask, r#41, AVLTreeNode.height);
  }
  assume (old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height])) || (old(Heap)[this, AVLTreeNode.height] == (ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]) + 1));
  assume !(m#42 == null);
  assert {:msg "  420.11: Receiver might be null."} m#42 != null;
  assume m#42 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[m#42, AVLTreeNode.valid] := Mask[m#42, AVLTreeNode.valid][perm$R := Mask[m#42, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[m#42, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume m#42 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[m#42, AVLTreeNode.keys] := Mask[m#42, AVLTreeNode.keys][perm$R := Mask[m#42, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[m#42, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume m#42 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[m#42, AVLTreeNode.height] := Mask[m#42, AVLTreeNode.height][perm$R := Mask[m#42, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[m#42, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume m#42 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[m#42, AVLTreeNode.balanceFactor] := Mask[m#42, AVLTreeNode.balanceFactor][perm$R := Mask[m#42, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[m#42, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  424.11: Receiver might be null."} true ==> (m#42 != null);
  assert {:msg "  424.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, m#42, AVLTreeNode.height);
  assume Heap[m#42, AVLTreeNode.height] == 1;
  assert {:msg "  425.12: Receiver might be null."} true ==> (m#42 != null);
  assert {:msg "  425.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, m#42, AVLTreeNode.keys);
  assume Seq#Length(Heap[m#42, AVLTreeNode.keys]) == 1;
  assert {:msg "  427.11: Receiver might be null."} true ==> (m#42 != null);
  assert {:msg "  427.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, m#42, AVLTreeNode.keys);
  if (r#41 == null) {
  } else {
    assert {:msg "  427.39: Receiver might be null."} true ==> (r#41 != null);
    assert {:msg "  427.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#41, AVLTreeNode.keys);
  }
  assert {:msg "  427.54: Receiver might be null."} true ==> (this != null);
  assert {:msg "  427.54: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.keys);
  assume Seq#Equal(Seq#Append(Heap[m#42, AVLTreeNode.keys], ite(r#41 == null, Seq#Empty(), Heap[r#41, AVLTreeNode.keys])), old(Heap)[this, AVLTreeNode.keys]);
  if (!(r#41 == null)) {
    assert {:msg "  428.11: Receiver might be null."} true && (0 <= k#89#358) ==> (r#41 != null);
    assert {:msg "  428.11: Location might not be readable."} true && (0 <= k#89#358) ==> CanRead(Mask, SecMask, r#41, AVLTreeNode.keys);
    assert {:msg "  428.45: Receiver might be null."} true && (0 <= k#89#358) && (k#89#358 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (m#42 != null);
    assert {:msg "  428.45: Location might not be readable."} true && (0 <= k#89#358) && (k#89#358 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, m#42, AVLTreeNode.keys);
    assert {:msg "  428.45: Sequence index might be negative."} true && (0 <= k#89#358) && (k#89#358 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (0 <= 0);
    assert {:msg "  428.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#89#358) && (k#89#358 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (0 < Seq#Length(Heap[m#42, AVLTreeNode.keys]));
    assert {:msg "  428.11: Receiver might be null."} true && (0 <= k#89#358) && (k#89#358 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (r#41 != null);
    assert {:msg "  428.11: Location might not be readable."} true && (0 <= k#89#358) && (k#89#358 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, r#41, AVLTreeNode.keys);
    assert {:msg "  428.57: Sequence index might be negative."} true && (0 <= k#89#358) && (k#89#358 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (0 <= k#89#358);
    assert {:msg "  428.57: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#89#358) && (k#89#358 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (k#89#358 < Seq#Length(Heap[r#41, AVLTreeNode.keys]));
    assume (forall k#89#357: int :: (0 <= k#89#357) && (k#89#357 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (Seq#Index(Heap[m#42, AVLTreeNode.keys], 0) < Seq#Index(Heap[r#41, AVLTreeNode.keys], k#89#357)));
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.pruneMin(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#41: ref where (r#41 == null) || (dtype(r#41) == AVLTreeNode#t), m#42: ref where (m#42 == null) || (dtype(m#42) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1068: int;
  var unfoldK#_1069: int;
  var oldVers#_1089: int;
  var newVers#_1090: int;
  var cond#_1091: bool;
  var methodCallK#_1096: int;
  var this#365: ref where (this#365 == null) || (dtype(this#365) == AVLTreeNode#t);
  var callHeap#_1092: HeapType;
  var callMask#_1093: MaskType;
  var callSecMask#_1094: MaskType;
  var callCredits#_1095: CreditsType;
  var exhaleMask#_1098: MaskType;
  var exhaleHeap#_1097: HeapType;
  var isHeld#_1113: int;
  var isRdHeld#_1114: bool;
  var assertHeap#_1115: HeapType;
  var assertMask#_1116: MaskType;
  var assertSecMask#_1117: MaskType;
  var assertCredits#_1118: CreditsType;
  var exhaleMask#_1120: MaskType;
  var exhaleHeap#_1119: HeapType;
  var assertHeap#_1121: HeapType;
  var assertMask#_1122: MaskType;
  var assertSecMask#_1123: MaskType;
  var assertCredits#_1124: CreditsType;
  var exhaleMask#_1126: MaskType;
  var exhaleHeap#_1125: HeapType;
  var k#90#371: int where true;
  var nl#44: ref where (nl#44 == null) || (dtype(nl#44) == AVLTreeNode#t);
  var methodCallK#_1131: int;
  var this#373: ref where (this#373 == null) || (dtype(this#373) == AVLTreeNode#t);
  var r#374: ref where (r#374 == null) || (dtype(r#374) == AVLTreeNode#t);
  var m#375: ref where (m#375 == null) || (dtype(m#375) == AVLTreeNode#t);
  var callHeap#_1127: HeapType;
  var callMask#_1128: MaskType;
  var callSecMask#_1129: MaskType;
  var callCredits#_1130: CreditsType;
  var exhaleMask#_1133: MaskType;
  var exhaleHeap#_1132: HeapType;
  var isHeld#_1138: int;
  var isRdHeld#_1139: bool;
  var bf#46: int where true;
  var methodCallK#_1144: int;
  var this#377: ref where (this#377 == null) || (dtype(this#377) == AVLTreeNode#t);
  var bf#378: int where true;
  var callHeap#_1140: HeapType;
  var callMask#_1141: MaskType;
  var callSecMask#_1142: MaskType;
  var callCredits#_1143: CreditsType;
  var exhaleMask#_1146: MaskType;
  var exhaleHeap#_1145: HeapType;
  var isHeld#_1153: int;
  var isRdHeld#_1154: bool;
  var cond#_1155: bool;
  var methodCallK#_1160: int;
  var this#379: ref where (this#379 == null) || (dtype(this#379) == AVLTreeNode#t);
  var r#380: ref where (r#380 == null) || (dtype(r#380) == AVLTreeNode#t);
  var callHeap#_1156: HeapType;
  var callMask#_1157: MaskType;
  var callSecMask#_1158: MaskType;
  var callCredits#_1159: CreditsType;
  var exhaleMask#_1162: MaskType;
  var exhaleHeap#_1161: HeapType;
  var isHeld#_1177: int;
  var isRdHeld#_1178: bool;
  var assertHeap#_1179: HeapType;
  var assertMask#_1180: MaskType;
  var assertSecMask#_1181: MaskType;
  var assertCredits#_1182: CreditsType;
  var exhaleMask#_1184: MaskType;
  var exhaleHeap#_1183: HeapType;
  var methodCallK#_1189: int;
  var this#385: ref where (this#385 == null) || (dtype(this#385) == AVLTreeNode#t);
  var callHeap#_1185: HeapType;
  var callMask#_1186: MaskType;
  var callSecMask#_1187: MaskType;
  var callCredits#_1188: CreditsType;
  var exhaleMask#_1191: MaskType;
  var exhaleHeap#_1190: HeapType;
  var isHeld#_1206: int;
  var isRdHeld#_1207: bool;
  var assertHeap#_1208: HeapType;
  var assertMask#_1209: MaskType;
  var assertSecMask#_1210: MaskType;
  var assertCredits#_1211: CreditsType;
  var exhaleMask#_1213: MaskType;
  var exhaleHeap#_1212: HeapType;
  var assertHeap#_1214: HeapType;
  var assertMask#_1215: MaskType;
  var assertSecMask#_1216: MaskType;
  var assertCredits#_1217: CreditsType;
  var exhaleMask#_1219: MaskType;
  var exhaleHeap#_1218: HeapType;
  var k#91#391: int where true;
  var exhaleMask#_1221: MaskType;
  var exhaleHeap#_1220: HeapType;
  assume (0 < methodK#_1068) && ((1000 * methodK#_1068) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // unfold
  assume #AVLTreeNode.valid#trigger(this);
  assume (0 < unfoldK#_1069) && (unfoldK#_1069 < Fractions(1)) && ((1000 * unfoldK#_1069) < methodK#_1068);
  assert {:msg "  430.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  430.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  430.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[this, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[this, AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[this, AVLTreeNode.valid][perm$N]));
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#359: int :: (0 <= lk#79#359) && (lk#79#359 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#359) < Heap[this, AVLTreeNode.key]));
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#360: int :: (0 <= rk#80#360) && (rk#80#360 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#360)));
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] > 0;
    SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, this, AVLTreeNode.valid)) {
    oldVers#_1089 := Heap[this, AVLTreeNode.valid];
    havoc newVers#_1090;
    Heap[this, AVLTreeNode.valid] := newVers#_1090;
    assume oldVers#_1089 < Heap[this, AVLTreeNode.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#363: int :: (0 <= lk#79#363) && (lk#79#363 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#363) < Heap[this, AVLTreeNode.key]));
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#364: int :: (0 <= rk#80#364) && (rk#80#364 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#364)));
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_1091 := Heap[this, AVLTreeNode.left] == null;
  assert {:msg "  431.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  431.7: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (cond#_1091) {
    // assigment to r
    assert {:msg "  432.9: Receiver might be null."} true ==> (this != null);
    assert {:msg "  432.9: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    r#41 := Heap[this, AVLTreeNode.right];
    // update field right
    assert {:msg "  433.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
    Heap[this, AVLTreeNode.right] := null;
    assume wf(Heap, Mask, SecMask);
    assume (0 < methodCallK#_1096) && ((1000 * methodCallK#_1096) < Fractions(1)) && ((1000 * methodCallK#_1096) < methodK#_1068);
    // call close
    callHeap#_1092 := Heap;
    callMask#_1093 := Mask;
    callSecMask#_1094 := SecMask;
    callCredits#_1095 := Credits;
    assume wf(callHeap#_1092, callMask#_1093, callSecMask#_1094);
    assert {:msg "  434.4: The target of the method call might be null."} this != null;
    this#365 := this;
    // begin exhale (precondition)
    exhaleMask#_1098 := Mask;
    havoc exhaleHeap#_1097;
    if (!(Heap[this#365, AVLTreeNode.left] == null)) {
      assert {:msg "  434.4: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#366: int :: (0 <= k#92#366) && (k#92#366 < Seq#Length(Heap[Heap[this#365, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#365, AVLTreeNode.left], AVLTreeNode.keys], k#92#366) < Heap[this#365, AVLTreeNode.key]));
    }
    if (!(Heap[this#365, AVLTreeNode.right] == null)) {
      assert {:msg "  434.4: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#367: int :: (0 <= k#93#367) && (k#93#367 < Seq#Length(Heap[Heap[this#365, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#365, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#365, AVLTreeNode.right], AVLTreeNode.keys], k#93#367)));
    }
    assert {:msg "  434.4: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#365, AVLTreeNode.left] == null, 0, Heap[Heap[this#365, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#365, AVLTreeNode.right] == null, 0, Heap[Heap[this#365, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
    assert {:msg "  434.4: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#365, AVLTreeNode.left] == null, 0, Heap[Heap[this#365, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#365, AVLTreeNode.right] == null, 0, Heap[Heap[this#365, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
    assert {:msg "  434.4: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  434.4: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_1098[this#365, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_1098[this#365, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1098[this#365, AVLTreeNode.key][perm$N]));
    exhaleMask#_1098[this#365, AVLTreeNode.key] := exhaleMask#_1098[this#365, AVLTreeNode.key][perm$R := exhaleMask#_1098[this#365, AVLTreeNode.key][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1098);
    assume wf(Heap, exhaleMask#_1098, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  434.4: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  434.4: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_1098[this#365, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_1098[this#365, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1098[this#365, AVLTreeNode.height][perm$N]));
    exhaleMask#_1098[this#365, AVLTreeNode.height] := exhaleMask#_1098[this#365, AVLTreeNode.height][perm$R := exhaleMask#_1098[this#365, AVLTreeNode.height][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1098);
    assume wf(Heap, exhaleMask#_1098, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  434.4: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  434.4: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_1098[this#365, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_1098[this#365, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1098[this#365, AVLTreeNode.left][perm$N]));
    exhaleMask#_1098[this#365, AVLTreeNode.left] := exhaleMask#_1098[this#365, AVLTreeNode.left][perm$R := exhaleMask#_1098[this#365, AVLTreeNode.left][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1098);
    assume wf(Heap, exhaleMask#_1098, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  434.4: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  434.4: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_1098[this#365, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_1098[this#365, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1098[this#365, AVLTreeNode.right][perm$N]));
    exhaleMask#_1098[this#365, AVLTreeNode.right] := exhaleMask#_1098[this#365, AVLTreeNode.right][perm$R := exhaleMask#_1098[this#365, AVLTreeNode.right][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1098);
    assume wf(Heap, exhaleMask#_1098, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  434.4: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  434.4: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_1098[this#365, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_1098[this#365, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1098[this#365, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1098[this#365, AVLTreeNode.keys] := exhaleMask#_1098[this#365, AVLTreeNode.keys][perm$R := exhaleMask#_1098[this#365, AVLTreeNode.keys][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1098);
    assume wf(Heap, exhaleMask#_1098, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  434.4: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  434.4: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_1098[this#365, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_1098[this#365, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1098[this#365, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1098[this#365, AVLTreeNode.balanceFactor] := exhaleMask#_1098[this#365, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1098[this#365, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1098);
    assume wf(Heap, exhaleMask#_1098, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#365, AVLTreeNode.left] == null)) {
      assert {:msg "  434.4: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
      assert {:msg "  434.4: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (!CanRead(exhaleMask#_1098, SecMask, Heap[this#365, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#365, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1097[Heap[this#365, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_1098);
      assume wf(Heap, exhaleMask#_1098, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#365, AVLTreeNode.left] == null)) {
      assert {:msg "  434.4: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
      assert {:msg "  434.4: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1098);
      assume wf(Heap, exhaleMask#_1098, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#365, AVLTreeNode.left] == null)) {
      assert {:msg "  434.4: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
      assert {:msg "  434.4: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1098);
      assume wf(Heap, exhaleMask#_1098, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#365, AVLTreeNode.left] == null)) {
      assert {:msg "  434.4: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
      assert {:msg "  434.4: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1098[Heap[this#365, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1098);
      assume wf(Heap, exhaleMask#_1098, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#365, AVLTreeNode.right] == null)) {
      assert {:msg "  434.4: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
      assert {:msg "  434.4: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (!CanRead(exhaleMask#_1098, SecMask, Heap[this#365, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#365, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1097[Heap[this#365, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_1098);
      assume wf(Heap, exhaleMask#_1098, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#365, AVLTreeNode.right] == null)) {
      assert {:msg "  434.4: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  434.4: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1098);
      assume wf(Heap, exhaleMask#_1098, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#365, AVLTreeNode.right] == null)) {
      assert {:msg "  434.4: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  434.4: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1098);
      assume wf(Heap, exhaleMask#_1098, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#365, AVLTreeNode.right] == null)) {
      assert {:msg "  434.4: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  434.4: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1098[Heap[this#365, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1098);
      assume wf(Heap, exhaleMask#_1098, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_1098;
    assume IsGoodExhaleState(exhaleHeap#_1097, Heap, Mask, SecMask);
    Heap := exhaleHeap#_1097;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    // inhale (postcondition)
    assume this#365 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[this#365, AVLTreeNode.valid] := Mask[this#365, AVLTreeNode.valid][perm$R := Mask[this#365, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#365, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#365 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[this#365, AVLTreeNode.height] := Mask[this#365, AVLTreeNode.height][perm$R := Mask[this#365, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#365, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#365 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[this#365, AVLTreeNode.keys] := Mask[this#365, AVLTreeNode.keys][perm$R := Mask[this#365, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#365, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#365 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[this#365, AVLTreeNode.balanceFactor] := Mask[this#365, AVLTreeNode.balanceFactor][perm$R := Mask[this#365, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#365, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Seq#Equal(Heap[this#365, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1092[this#365, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1092[callHeap#_1092[this#365, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1092[this#365, AVLTreeNode.key])), ite(callHeap#_1092[this#365, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1092[callHeap#_1092[this#365, AVLTreeNode.right], AVLTreeNode.keys])));
    assume Heap[this#365, AVLTreeNode.height] == ite(ite(callHeap#_1092[this#365, AVLTreeNode.left] == null, 0, callHeap#_1092[callHeap#_1092[this#365, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1092[this#365, AVLTreeNode.right] == null, 0, callHeap#_1092[callHeap#_1092[this#365, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1092[this#365, AVLTreeNode.left] == null, 0, callHeap#_1092[callHeap#_1092[this#365, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1092[this#365, AVLTreeNode.right] == null, 0, callHeap#_1092[callHeap#_1092[this#365, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap[this#365, AVLTreeNode.balanceFactor] == (ite(callHeap#_1092[this#365, AVLTreeNode.left] == null, 0, callHeap#_1092[callHeap#_1092[this#365, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1092[this#365, AVLTreeNode.right] == null, 0, callHeap#_1092[callHeap#_1092[this#365, AVLTreeNode.right], AVLTreeNode.height]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    // assigment to m
    m#42 := this;
    // assert
    assertHeap#_1115 := Heap;
    assertMask#_1116 := Mask;
    assertSecMask#_1117 := SecMask;
    assertCredits#_1118 := Credits;
    assume wf(assertHeap#_1115, assertMask#_1116, assertSecMask#_1117);
    // begin exhale (assert)
    exhaleMask#_1120 := assertMask#_1116;
    havoc exhaleHeap#_1119;
    if (!(r#41 == null)) {
      assert {:msg "  436.24: Receiver might be null."} true ==> (r#41 != null);
      assert {:msg "  436.24: Location might not be readable."} true ==> CanRead(assertMask#_1116, assertSecMask#_1117, r#41, AVLTreeNode.height);
      assert {:msg "  436.40: Receiver might be null."} true ==> (this != null);
      assert {:msg "  436.40: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
      assert {:msg "  436.51: Receiver might be null."} true && (!(assertHeap#_1115[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#41 != null);
      assert {:msg "  436.51: Location might not be readable."} true && (!(assertHeap#_1115[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(assertMask#_1116, assertSecMask#_1117, r#41, AVLTreeNode.height);
      assert {:msg "  436.67: Receiver might be null."} true && (!(assertHeap#_1115[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
      assert {:msg "  436.67: Location might not be readable."} true && (!(assertHeap#_1115[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
      assert {:msg "  436.4: Assertion might not hold. The expression at 436.24 might not evaluate to true."} (assertHeap#_1115[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (assertHeap#_1115[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
    }
    assertMask#_1116 := exhaleMask#_1120;
    assume IsGoodExhaleState(exhaleHeap#_1119, assertHeap#_1115, assertMask#_1116, assertSecMask#_1117);
    assertHeap#_1115 := exhaleHeap#_1119;
    assume IsGoodMask(assertMask#_1116);
    assume wf(assertHeap#_1115, assertMask#_1116, assertSecMask#_1117);
    // end exhale
    // assert
    assertHeap#_1121 := Heap;
    assertMask#_1122 := Mask;
    assertSecMask#_1123 := SecMask;
    assertCredits#_1124 := Credits;
    assume wf(assertHeap#_1121, assertMask#_1122, assertSecMask#_1123);
    // begin exhale (assert)
    exhaleMask#_1126 := assertMask#_1122;
    havoc exhaleHeap#_1125;
    if (!(r#41 == null)) {
      assert {:msg "  437.11: Receiver might be null."} true && (0 <= k#90#371) ==> (r#41 != null);
      assert {:msg "  437.11: Location might not be readable."} true && (0 <= k#90#371) ==> CanRead(assertMask#_1122, assertSecMask#_1123, r#41, AVLTreeNode.keys);
      assert {:msg "  437.45: Receiver might be null."} true && (0 <= k#90#371) && (k#90#371 < Seq#Length(assertHeap#_1121[r#41, AVLTreeNode.keys])) ==> (m#42 != null);
      assert {:msg "  437.45: Location might not be readable."} true && (0 <= k#90#371) && (k#90#371 < Seq#Length(assertHeap#_1121[r#41, AVLTreeNode.keys])) ==> CanRead(assertMask#_1122, assertSecMask#_1123, m#42, AVLTreeNode.keys);
      assert {:msg "  437.45: Sequence index might be negative."} true && (0 <= k#90#371) && (k#90#371 < Seq#Length(assertHeap#_1121[r#41, AVLTreeNode.keys])) ==> (0 <= 0);
      assert {:msg "  437.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#90#371) && (k#90#371 < Seq#Length(assertHeap#_1121[r#41, AVLTreeNode.keys])) ==> (0 < Seq#Length(assertHeap#_1121[m#42, AVLTreeNode.keys]));
      assert {:msg "  437.11: Receiver might be null."} true && (0 <= k#90#371) && (k#90#371 < Seq#Length(assertHeap#_1121[r#41, AVLTreeNode.keys])) ==> (r#41 != null);
      assert {:msg "  437.11: Location might not be readable."} true && (0 <= k#90#371) && (k#90#371 < Seq#Length(assertHeap#_1121[r#41, AVLTreeNode.keys])) ==> CanRead(assertMask#_1122, assertSecMask#_1123, r#41, AVLTreeNode.keys);
      assert {:msg "  437.57: Sequence index might be negative."} true && (0 <= k#90#371) && (k#90#371 < Seq#Length(assertHeap#_1121[r#41, AVLTreeNode.keys])) ==> (0 <= k#90#371);
      assert {:msg "  437.57: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#90#371) && (k#90#371 < Seq#Length(assertHeap#_1121[r#41, AVLTreeNode.keys])) ==> (k#90#371 < Seq#Length(assertHeap#_1121[r#41, AVLTreeNode.keys]));
      assert {:msg "  437.4: Assertion might not hold. The expression at 437.23 might not evaluate to true."} (forall k#90#370: int :: (0 <= k#90#370) && (k#90#370 < Seq#Length(assertHeap#_1121[r#41, AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1121[m#42, AVLTreeNode.keys], 0) < Seq#Index(assertHeap#_1121[r#41, AVLTreeNode.keys], k#90#370)));
    }
    assertMask#_1122 := exhaleMask#_1126;
    assume IsGoodExhaleState(exhaleHeap#_1125, assertHeap#_1121, assertMask#_1122, assertSecMask#_1123);
    assertHeap#_1121 := exhaleHeap#_1125;
    assume IsGoodMask(assertMask#_1122);
    assume wf(assertHeap#_1121, assertMask#_1122, assertSecMask#_1123);
    // end exhale
  } else {
    // local var nl
    assume (0 < methodCallK#_1131) && ((1000 * methodCallK#_1131) < Fractions(1)) && ((1000 * methodCallK#_1131) < methodK#_1068);
    // call pruneMin
    callHeap#_1127 := Heap;
    callMask#_1128 := Mask;
    callSecMask#_1129 := SecMask;
    callCredits#_1130 := Credits;
    assume wf(callHeap#_1127, callMask#_1128, callSecMask#_1129);
    assert {:msg "  440.17: Receiver might be null."} true ==> (this != null);
    assert {:msg "  440.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  440.4: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
    this#373 := Heap[this, AVLTreeNode.left];
    // begin exhale (precondition)
    exhaleMask#_1133 := Mask;
    havoc exhaleHeap#_1132;
    assert {:msg "  440.4: The precondition at 404.12 might not hold. The permission at 404.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  440.4: The precondition at 404.12 might not hold. Insufficient fraction at 404.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1133[this#373, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1133[this#373, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1133[this#373, AVLTreeNode.valid][perm$N]));
    exhaleMask#_1133[this#373, AVLTreeNode.valid] := exhaleMask#_1133[this#373, AVLTreeNode.valid][perm$R := exhaleMask#_1133[this#373, AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_1133, SecMask, this#373, AVLTreeNode.valid)) {
      assume Heap[this#373, AVLTreeNode.valid] < exhaleHeap#_1132[this#373, AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1133);
    assume wf(Heap, exhaleMask#_1133, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  440.4: The precondition at 405.12 might not hold. The permission at 405.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  440.4: The precondition at 405.12 might not hold. Insufficient fraction at 405.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1133[this#373, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1133[this#373, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1133[this#373, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1133[this#373, AVLTreeNode.keys] := exhaleMask#_1133[this#373, AVLTreeNode.keys][perm$R := exhaleMask#_1133[this#373, AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1133);
    assume wf(Heap, exhaleMask#_1133, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  440.4: The precondition at 406.12 might not hold. The permission at 406.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  440.4: The precondition at 406.12 might not hold. Insufficient fraction at 406.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1133[this#373, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1133[this#373, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1133[this#373, AVLTreeNode.height][perm$N]));
    exhaleMask#_1133[this#373, AVLTreeNode.height] := exhaleMask#_1133[this#373, AVLTreeNode.height][perm$R := exhaleMask#_1133[this#373, AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1133);
    assume wf(Heap, exhaleMask#_1133, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  440.4: The precondition at 407.12 might not hold. The permission at 407.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  440.4: The precondition at 407.12 might not hold. Insufficient fraction at 407.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1133[this#373, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1133[this#373, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1133[this#373, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1133[this#373, AVLTreeNode.balanceFactor] := exhaleMask#_1133[this#373, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1133[this#373, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1133);
    assume wf(Heap, exhaleMask#_1133, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_1133;
    assume IsGoodExhaleState(exhaleHeap#_1132, Heap, Mask, SecMask);
    Heap := exhaleHeap#_1132;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#374;
    havoc m#375;
    // inhale (postcondition)
    if (!(r#374 == null)) {
      assume r#374 != null;
      assume wf(Heap, Mask, SecMask);
      assume Fractions(100) > 0;
      Mask[r#374, AVLTreeNode.valid] := Mask[r#374, AVLTreeNode.valid][perm$R := Mask[r#374, AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#374, AVLTreeNode.valid]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#374 == null)) {
      assume r#374 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#374, AVLTreeNode.keys] := Mask[r#374, AVLTreeNode.keys][perm$R := Mask[r#374, AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#374, AVLTreeNode.keys]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#374 == null)) {
      assume r#374 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#374, AVLTreeNode.height] := Mask[r#374, AVLTreeNode.height][perm$R := Mask[r#374, AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#374, AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#374 == null)) {
      assume r#374 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#374, AVLTreeNode.balanceFactor] := Mask[r#374, AVLTreeNode.balanceFactor][perm$R := Mask[r#374, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#374, AVLTreeNode.balanceFactor]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#374 == null)) {
      assume (Heap[r#374, AVLTreeNode.height] == callHeap#_1127[this#373, AVLTreeNode.height]) || (Heap[r#374, AVLTreeNode.height] == (callHeap#_1127[this#373, AVLTreeNode.height] - 1));
    }
    if (!(r#374 == null)) {
      assume (Seq#Length(Heap[r#374, AVLTreeNode.keys]) + 1) == Seq#Length(callHeap#_1127[this#373, AVLTreeNode.keys]);
    }
    if (callHeap#_1127[this#373, AVLTreeNode.height] > 1) {
      assume !(r#374 == null);
    }
    if (callHeap#_1127[this#373, AVLTreeNode.height] == 1) {
      assume r#374 == null;
    }
    assume (callHeap#_1127[this#373, AVLTreeNode.height] == ite(r#374 == null, 0, Heap[r#374, AVLTreeNode.height])) || (callHeap#_1127[this#373, AVLTreeNode.height] == (ite(r#374 == null, 0, Heap[r#374, AVLTreeNode.height]) + 1));
    assume !(m#375 == null);
    assume m#375 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[m#375, AVLTreeNode.valid] := Mask[m#375, AVLTreeNode.valid][perm$R := Mask[m#375, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[m#375, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume m#375 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[m#375, AVLTreeNode.keys] := Mask[m#375, AVLTreeNode.keys][perm$R := Mask[m#375, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[m#375, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume m#375 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[m#375, AVLTreeNode.height] := Mask[m#375, AVLTreeNode.height][perm$R := Mask[m#375, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[m#375, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume m#375 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[m#375, AVLTreeNode.balanceFactor] := Mask[m#375, AVLTreeNode.balanceFactor][perm$R := Mask[m#375, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[m#375, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Heap[m#375, AVLTreeNode.height] == 1;
    assume Seq#Length(Heap[m#375, AVLTreeNode.keys]) == 1;
    assume Seq#Equal(Seq#Append(Heap[m#375, AVLTreeNode.keys], ite(r#374 == null, Seq#Empty(), Heap[r#374, AVLTreeNode.keys])), callHeap#_1127[this#373, AVLTreeNode.keys]);
    if (!(r#374 == null)) {
      assume (forall k#89#376: int :: (0 <= k#89#376) && (k#89#376 < Seq#Length(Heap[r#374, AVLTreeNode.keys])) ==> (Seq#Index(Heap[m#375, AVLTreeNode.keys], 0) < Seq#Index(Heap[r#374, AVLTreeNode.keys], k#89#376)));
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    nl#44 := r#374;
    m#42 := m#375;
    // update field left
    assert {:msg "  441.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
    Heap[this, AVLTreeNode.left] := nl#44;
    assume wf(Heap, Mask, SecMask);
    // local var bf
    assume (0 < methodCallK#_1144) && ((1000 * methodCallK#_1144) < Fractions(1)) && ((1000 * methodCallK#_1144) < methodK#_1068);
    // call getBalanceFactorI
    callHeap#_1140 := Heap;
    callMask#_1141 := Mask;
    callSecMask#_1142 := SecMask;
    callCredits#_1143 := Credits;
    assume wf(callHeap#_1140, callMask#_1141, callSecMask#_1142);
    assert {:msg "  443.4: The target of the method call might be null."} this != null;
    this#377 := this;
    // begin exhale (precondition)
    exhaleMask#_1146 := Mask;
    havoc exhaleHeap#_1145;
    assert {:msg "  443.4: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_1144 > 0;
    assert {:msg "  443.4: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_1146[this#377, AVLTreeNode.left][perm$R] > 0;
    assume methodCallK#_1144 < exhaleMask#_1146[this#377, AVLTreeNode.left][perm$R];
    exhaleMask#_1146[this#377, AVLTreeNode.left] := exhaleMask#_1146[this#377, AVLTreeNode.left][perm$R := exhaleMask#_1146[this#377, AVLTreeNode.left][perm$R] - methodCallK#_1144];
    assume IsGoodMask(exhaleMask#_1146);
    assume wf(Heap, exhaleMask#_1146, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#377, AVLTreeNode.left] == null)) {
      assert {:msg "  443.4: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_1144 > 0;
      assert {:msg "  443.4: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_1146[Heap[this#377, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0;
      assume methodCallK#_1144 < exhaleMask#_1146[Heap[this#377, AVLTreeNode.left], AVLTreeNode.height][perm$R];
      exhaleMask#_1146[Heap[this#377, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1146[Heap[this#377, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1146[Heap[this#377, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_1144];
      assume IsGoodMask(exhaleMask#_1146);
      assume wf(Heap, exhaleMask#_1146, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assert {:msg "  443.4: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_1144 > 0;
    assert {:msg "  443.4: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_1146[this#377, AVLTreeNode.right][perm$R] > 0;
    assume methodCallK#_1144 < exhaleMask#_1146[this#377, AVLTreeNode.right][perm$R];
    exhaleMask#_1146[this#377, AVLTreeNode.right] := exhaleMask#_1146[this#377, AVLTreeNode.right][perm$R := exhaleMask#_1146[this#377, AVLTreeNode.right][perm$R] - methodCallK#_1144];
    assume IsGoodMask(exhaleMask#_1146);
    assume wf(Heap, exhaleMask#_1146, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#377, AVLTreeNode.right] == null)) {
      assert {:msg "  443.4: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_1144 > 0;
      assert {:msg "  443.4: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_1146[Heap[this#377, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0;
      assume methodCallK#_1144 < exhaleMask#_1146[Heap[this#377, AVLTreeNode.right], AVLTreeNode.height][perm$R];
      exhaleMask#_1146[Heap[this#377, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1146[Heap[this#377, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1146[Heap[this#377, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_1144];
      assume IsGoodMask(exhaleMask#_1146);
      assume wf(Heap, exhaleMask#_1146, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#377, AVLTreeNode.left] == null)) {
      assert {:msg "  443.4: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} Fractions(100) > 0;
      assert {:msg "  443.4: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1146[Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1146[Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1146[Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1146[Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1146[Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1146[Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (!CanRead(exhaleMask#_1146, SecMask, Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1145[Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_1146);
      assume wf(Heap, exhaleMask#_1146, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#377, AVLTreeNode.right] == null)) {
      assert {:msg "  443.4: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} Fractions(100) > 0;
      assert {:msg "  443.4: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1146[Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1146[Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1146[Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1146[Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1146[Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1146[Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (!CanRead(exhaleMask#_1146, SecMask, Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1145[Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_1146);
      assume wf(Heap, exhaleMask#_1146, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_1146;
    assume IsGoodExhaleState(exhaleHeap#_1145, Heap, Mask, SecMask);
    Heap := exhaleHeap#_1145;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc bf#378;
    // inhale (postcondition)
    assume this#377 != null;
    assume wf(Heap, Mask, SecMask);
    assume (Heap[this#377, AVLTreeNode.left] == null) || (dtype(Heap[this#377, AVLTreeNode.left]) == AVLTreeNode#t);
    assume methodCallK#_1144 > 0;
    Mask[this#377, AVLTreeNode.left] := Mask[this#377, AVLTreeNode.left][perm$R := Mask[this#377, AVLTreeNode.left][perm$R] + methodCallK#_1144];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#377, AVLTreeNode.left]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#377, AVLTreeNode.left] == null)) {
      assume Heap[this#377, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume Fractions(100) > 0;
      Mask[Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[Heap[this#377, AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#377, AVLTreeNode.left] == null)) {
      assume Heap[this#377, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume methodCallK#_1144 > 0;
      Mask[Heap[this#377, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#377, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#377, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_1144];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[Heap[this#377, AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume this#377 != null;
    assume wf(Heap, Mask, SecMask);
    assume (Heap[this#377, AVLTreeNode.right] == null) || (dtype(Heap[this#377, AVLTreeNode.right]) == AVLTreeNode#t);
    assume methodCallK#_1144 > 0;
    Mask[this#377, AVLTreeNode.right] := Mask[this#377, AVLTreeNode.right][perm$R := Mask[this#377, AVLTreeNode.right][perm$R] + methodCallK#_1144];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[this#377, AVLTreeNode.right]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#377, AVLTreeNode.right] == null)) {
      assume Heap[this#377, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume Fractions(100) > 0;
      Mask[Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[Heap[this#377, AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#377, AVLTreeNode.right] == null)) {
      assume Heap[this#377, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume methodCallK#_1144 > 0;
      Mask[Heap[this#377, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#377, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#377, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_1144];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[Heap[this#377, AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume bf#378 == (ite(Heap[this#377, AVLTreeNode.left] == null, 0, Heap[Heap[this#377, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#377, AVLTreeNode.right] == null, 0, Heap[Heap[this#377, AVLTreeNode.right], AVLTreeNode.height]));
    if (bf#378 > 0) {
      assume !(Heap[this#377, AVLTreeNode.left] == null);
    }
    if (bf#378 < 0) {
      assume !(Heap[this#377, AVLTreeNode.right] == null);
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    bf#46 := bf#378;
    // if
    cond#_1155 := bf#46 == (0 - 2);
    if (cond#_1155) {
      assume (0 < methodCallK#_1160) && ((1000 * methodCallK#_1160) < Fractions(1)) && ((1000 * methodCallK#_1160) < methodK#_1068);
      // call rebalanceRight
      callHeap#_1156 := Heap;
      callMask#_1157 := Mask;
      callSecMask#_1158 := SecMask;
      callCredits#_1159 := Credits;
      assume wf(callHeap#_1156, callMask#_1157, callSecMask#_1158);
      assert {:msg "  445.5: The target of the method call might be null."} this != null;
      this#379 := this;
      // begin exhale (precondition)
      exhaleMask#_1162 := Mask;
      havoc exhaleHeap#_1161;
      if (!(Heap[this#379, AVLTreeNode.left] == null)) {
        assert {:msg "  445.5: The precondition at 758.12 might not hold. The expression at 758.25 might not evaluate to true."} (forall k#104#381: int :: (0 <= k#104#381) && (k#104#381 < Seq#Length(Heap[Heap[this#379, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#379, AVLTreeNode.left], AVLTreeNode.keys], k#104#381) < Heap[this#379, AVLTreeNode.key]));
      }
      assert {:msg "  445.5: The precondition at 760.12 might not hold. The expression at 760.12 might not evaluate to true."} !(Heap[this#379, AVLTreeNode.right] == null);
      assert {:msg "  445.5: The precondition at 765.12 might not hold. The expression at 765.12 might not evaluate to true."} (forall k#105#382: int :: (0 <= k#105#382) && (k#105#382 < Seq#Length(Heap[Heap[this#379, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#379, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#379, AVLTreeNode.right], AVLTreeNode.keys], k#105#382)));
      assert {:msg "  445.5: The precondition at 768.12 might not hold. The expression at 768.12 might not evaluate to true."} (ite(Heap[this#379, AVLTreeNode.left] == null, 0, Heap[Heap[this#379, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#379, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
      assert {:msg "  445.5: The precondition at 746.12 might not hold. The permission at 746.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  445.5: The precondition at 746.12 might not hold. Insufficient fraction at 746.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_1162[this#379, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_1162[this#379, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1162[this#379, AVLTreeNode.key][perm$N]));
      exhaleMask#_1162[this#379, AVLTreeNode.key] := exhaleMask#_1162[this#379, AVLTreeNode.key][perm$R := exhaleMask#_1162[this#379, AVLTreeNode.key][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1162);
      assume wf(Heap, exhaleMask#_1162, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 747.12 might not hold. The permission at 747.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  445.5: The precondition at 747.12 might not hold. Insufficient fraction at 747.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_1162[this#379, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_1162[this#379, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1162[this#379, AVLTreeNode.height][perm$N]));
      exhaleMask#_1162[this#379, AVLTreeNode.height] := exhaleMask#_1162[this#379, AVLTreeNode.height][perm$R := exhaleMask#_1162[this#379, AVLTreeNode.height][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1162);
      assume wf(Heap, exhaleMask#_1162, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 748.12 might not hold. The permission at 748.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  445.5: The precondition at 748.12 might not hold. Insufficient fraction at 748.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_1162[this#379, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_1162[this#379, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1162[this#379, AVLTreeNode.left][perm$N]));
      exhaleMask#_1162[this#379, AVLTreeNode.left] := exhaleMask#_1162[this#379, AVLTreeNode.left][perm$R := exhaleMask#_1162[this#379, AVLTreeNode.left][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1162);
      assume wf(Heap, exhaleMask#_1162, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 749.12 might not hold. The permission at 749.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  445.5: The precondition at 749.12 might not hold. Insufficient fraction at 749.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_1162[this#379, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_1162[this#379, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1162[this#379, AVLTreeNode.right][perm$N]));
      exhaleMask#_1162[this#379, AVLTreeNode.right] := exhaleMask#_1162[this#379, AVLTreeNode.right][perm$R := exhaleMask#_1162[this#379, AVLTreeNode.right][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1162);
      assume wf(Heap, exhaleMask#_1162, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 751.12 might not hold. The permission at 751.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  445.5: The precondition at 751.12 might not hold. Insufficient fraction at 751.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_1162[this#379, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_1162[this#379, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1162[this#379, AVLTreeNode.keys][perm$N]));
      exhaleMask#_1162[this#379, AVLTreeNode.keys] := exhaleMask#_1162[this#379, AVLTreeNode.keys][perm$R := exhaleMask#_1162[this#379, AVLTreeNode.keys][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1162);
      assume wf(Heap, exhaleMask#_1162, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 752.12 might not hold. The permission at 752.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  445.5: The precondition at 752.12 might not hold. Insufficient fraction at 752.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_1162[this#379, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_1162[this#379, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1162[this#379, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1162[this#379, AVLTreeNode.balanceFactor] := exhaleMask#_1162[this#379, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1162[this#379, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1162);
      assume wf(Heap, exhaleMask#_1162, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#379, AVLTreeNode.left] == null)) {
        assert {:msg "  445.5: The precondition at 754.12 might not hold. The permission at 754.25 might not be positive."} Fractions(100) > 0;
        assert {:msg "  445.5: The precondition at 754.12 might not hold. Insufficient fraction at 754.25 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_1162, SecMask, Heap[this#379, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#379, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1161[Heap[this#379, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_1162);
        assume wf(Heap, exhaleMask#_1162, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#379, AVLTreeNode.left] == null)) {
        assert {:msg "  445.5: The precondition at 755.12 might not hold. The permission at 755.25 might not be positive."} Fractions(50) > 0;
        assert {:msg "  445.5: The precondition at 755.12 might not hold. Insufficient fraction at 755.25 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1162);
        assume wf(Heap, exhaleMask#_1162, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#379, AVLTreeNode.left] == null)) {
        assert {:msg "  445.5: The precondition at 756.12 might not hold. The permission at 756.25 might not be positive."} Fractions(50) > 0;
        assert {:msg "  445.5: The precondition at 756.12 might not hold. Insufficient fraction at 756.25 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1162);
        assume wf(Heap, exhaleMask#_1162, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#379, AVLTreeNode.left] == null)) {
        assert {:msg "  445.5: The precondition at 757.12 might not hold. The permission at 757.25 might not be positive."} Fractions(50) > 0;
        assert {:msg "  445.5: The precondition at 757.12 might not hold. Insufficient fraction at 757.25 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1162[Heap[this#379, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1162);
        assume wf(Heap, exhaleMask#_1162, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assert {:msg "  445.5: The precondition at 761.12 might not hold. The permission at 761.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  445.5: The precondition at 761.12 might not hold. Insufficient fraction at 761.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (!CanRead(exhaleMask#_1162, SecMask, Heap[this#379, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#379, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1161[Heap[this#379, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_1162);
      assume wf(Heap, exhaleMask#_1162, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 762.12 might not hold. The permission at 762.12 might not be positive."} Fractions(50) > 0;
      assert {:msg "  445.5: The precondition at 762.12 might not hold. Insufficient fraction at 762.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1162);
      assume wf(Heap, exhaleMask#_1162, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 763.12 might not hold. The permission at 763.12 might not be positive."} Fractions(50) > 0;
      assert {:msg "  445.5: The precondition at 763.12 might not hold. Insufficient fraction at 763.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1162);
      assume wf(Heap, exhaleMask#_1162, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 764.12 might not hold. The permission at 764.12 might not be positive."} Fractions(50) > 0;
      assert {:msg "  445.5: The precondition at 764.12 might not hold. Insufficient fraction at 764.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1162[Heap[this#379, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1162);
      assume wf(Heap, exhaleMask#_1162, SecMask);
      assume wf(Heap, Mask, SecMask);
      Mask := exhaleMask#_1162;
      assume IsGoodExhaleState(exhaleHeap#_1161, Heap, Mask, SecMask);
      Heap := exhaleHeap#_1161;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      havoc r#380;
      // inhale (postcondition)
      assume !(r#380 == null);
      assume r#380 != null;
      assume wf(Heap, Mask, SecMask);
      assume Fractions(100) > 0;
      Mask[r#380, AVLTreeNode.valid] := Mask[r#380, AVLTreeNode.valid][perm$R := Mask[r#380, AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#380, AVLTreeNode.valid]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#380 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#380, AVLTreeNode.height] := Mask[r#380, AVLTreeNode.height][perm$R := Mask[r#380, AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#380, AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#380 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#380, AVLTreeNode.keys] := Mask[r#380, AVLTreeNode.keys][perm$R := Mask[r#380, AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#380, AVLTreeNode.keys]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#380 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[r#380, AVLTreeNode.balanceFactor] := Mask[r#380, AVLTreeNode.balanceFactor][perm$R := Mask[r#380, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[r#380, AVLTreeNode.balanceFactor]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume (Heap[r#380, AVLTreeNode.height] == callHeap#_1156[callHeap#_1156[this#379, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#380, AVLTreeNode.height] == (callHeap#_1156[callHeap#_1156[this#379, AVLTreeNode.right], AVLTreeNode.height] + 1));
      assume Seq#Equal(Heap[r#380, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1156[this#379, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1156[callHeap#_1156[this#379, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1156[this#379, AVLTreeNode.key])), callHeap#_1156[callHeap#_1156[this#379, AVLTreeNode.right], AVLTreeNode.keys]));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      r#41 := r#380;
      // assert
      assertHeap#_1179 := Heap;
      assertMask#_1180 := Mask;
      assertSecMask#_1181 := SecMask;
      assertCredits#_1182 := Credits;
      assume wf(assertHeap#_1179, assertMask#_1180, assertSecMask#_1181);
      // begin exhale (assert)
      exhaleMask#_1184 := assertMask#_1180;
      havoc exhaleHeap#_1183;
      if (!(r#41 == null)) {
        assert {:msg "  446.27: Receiver might be null."} true ==> (r#41 != null);
        assert {:msg "  446.27: Location might not be readable."} true ==> CanRead(assertMask#_1180, assertSecMask#_1181, r#41, AVLTreeNode.height);
        assert {:msg "  446.43: Receiver might be null."} true ==> (this != null);
        assert {:msg "  446.43: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
        assert {:msg "  446.54: Receiver might be null."} true && (!(assertHeap#_1179[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#41 != null);
        assert {:msg "  446.54: Location might not be readable."} true && (!(assertHeap#_1179[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(assertMask#_1180, assertSecMask#_1181, r#41, AVLTreeNode.height);
        assert {:msg "  446.70: Receiver might be null."} true && (!(assertHeap#_1179[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
        assert {:msg "  446.70: Location might not be readable."} true && (!(assertHeap#_1179[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
        assert {:msg "  446.5: Assertion might not hold. The expression at 446.27 might not evaluate to true."} (assertHeap#_1179[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (assertHeap#_1179[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
      }
      assertMask#_1180 := exhaleMask#_1184;
      assume IsGoodExhaleState(exhaleHeap#_1183, assertHeap#_1179, assertMask#_1180, assertSecMask#_1181);
      assertHeap#_1179 := exhaleHeap#_1183;
      assume IsGoodMask(assertMask#_1180);
      assume wf(assertHeap#_1179, assertMask#_1180, assertSecMask#_1181);
      // end exhale
    } else {
      assume (0 < methodCallK#_1189) && ((1000 * methodCallK#_1189) < Fractions(1)) && ((1000 * methodCallK#_1189) < methodK#_1068);
      // call close
      callHeap#_1185 := Heap;
      callMask#_1186 := Mask;
      callSecMask#_1187 := SecMask;
      callCredits#_1188 := Credits;
      assume wf(callHeap#_1185, callMask#_1186, callSecMask#_1187);
      assert {:msg "  448.5: The target of the method call might be null."} this != null;
      this#385 := this;
      // begin exhale (precondition)
      exhaleMask#_1191 := Mask;
      havoc exhaleHeap#_1190;
      if (!(Heap[this#385, AVLTreeNode.left] == null)) {
        assert {:msg "  448.5: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#386: int :: (0 <= k#92#386) && (k#92#386 < Seq#Length(Heap[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys], k#92#386) < Heap[this#385, AVLTreeNode.key]));
      }
      if (!(Heap[this#385, AVLTreeNode.right] == null)) {
        assert {:msg "  448.5: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#387: int :: (0 <= k#93#387) && (k#93#387 < Seq#Length(Heap[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#385, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys], k#93#387)));
      }
      assert {:msg "  448.5: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#385, AVLTreeNode.left] == null, 0, Heap[Heap[this#385, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#385, AVLTreeNode.right] == null, 0, Heap[Heap[this#385, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
      assert {:msg "  448.5: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#385, AVLTreeNode.left] == null, 0, Heap[Heap[this#385, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#385, AVLTreeNode.right] == null, 0, Heap[Heap[this#385, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
      assert {:msg "  448.5: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  448.5: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_1191[this#385, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_1191[this#385, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1191[this#385, AVLTreeNode.key][perm$N]));
      exhaleMask#_1191[this#385, AVLTreeNode.key] := exhaleMask#_1191[this#385, AVLTreeNode.key][perm$R := exhaleMask#_1191[this#385, AVLTreeNode.key][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1191);
      assume wf(Heap, exhaleMask#_1191, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  448.5: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  448.5: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_1191[this#385, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_1191[this#385, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1191[this#385, AVLTreeNode.height][perm$N]));
      exhaleMask#_1191[this#385, AVLTreeNode.height] := exhaleMask#_1191[this#385, AVLTreeNode.height][perm$R := exhaleMask#_1191[this#385, AVLTreeNode.height][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1191);
      assume wf(Heap, exhaleMask#_1191, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  448.5: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  448.5: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_1191[this#385, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_1191[this#385, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1191[this#385, AVLTreeNode.left][perm$N]));
      exhaleMask#_1191[this#385, AVLTreeNode.left] := exhaleMask#_1191[this#385, AVLTreeNode.left][perm$R := exhaleMask#_1191[this#385, AVLTreeNode.left][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1191);
      assume wf(Heap, exhaleMask#_1191, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  448.5: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  448.5: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_1191[this#385, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_1191[this#385, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1191[this#385, AVLTreeNode.right][perm$N]));
      exhaleMask#_1191[this#385, AVLTreeNode.right] := exhaleMask#_1191[this#385, AVLTreeNode.right][perm$R := exhaleMask#_1191[this#385, AVLTreeNode.right][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1191);
      assume wf(Heap, exhaleMask#_1191, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  448.5: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  448.5: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_1191[this#385, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_1191[this#385, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1191[this#385, AVLTreeNode.keys][perm$N]));
      exhaleMask#_1191[this#385, AVLTreeNode.keys] := exhaleMask#_1191[this#385, AVLTreeNode.keys][perm$R := exhaleMask#_1191[this#385, AVLTreeNode.keys][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1191);
      assume wf(Heap, exhaleMask#_1191, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  448.5: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  448.5: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_1191[this#385, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_1191[this#385, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1191[this#385, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1191[this#385, AVLTreeNode.balanceFactor] := exhaleMask#_1191[this#385, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1191[this#385, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
      assume IsGoodMask(exhaleMask#_1191);
      assume wf(Heap, exhaleMask#_1191, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#385, AVLTreeNode.left] == null)) {
        assert {:msg "  448.5: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
        assert {:msg "  448.5: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_1191, SecMask, Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1190[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_1191);
        assume wf(Heap, exhaleMask#_1191, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#385, AVLTreeNode.left] == null)) {
        assert {:msg "  448.5: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
        assert {:msg "  448.5: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1191);
        assume wf(Heap, exhaleMask#_1191, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#385, AVLTreeNode.left] == null)) {
        assert {:msg "  448.5: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
        assert {:msg "  448.5: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1191);
        assume wf(Heap, exhaleMask#_1191, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#385, AVLTreeNode.left] == null)) {
        assert {:msg "  448.5: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
        assert {:msg "  448.5: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1191[Heap[this#385, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1191);
        assume wf(Heap, exhaleMask#_1191, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#385, AVLTreeNode.right] == null)) {
        assert {:msg "  448.5: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
        assert {:msg "  448.5: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_1191, SecMask, Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1190[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_1191);
        assume wf(Heap, exhaleMask#_1191, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#385, AVLTreeNode.right] == null)) {
        assert {:msg "  448.5: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
        assert {:msg "  448.5: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1191);
        assume wf(Heap, exhaleMask#_1191, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#385, AVLTreeNode.right] == null)) {
        assert {:msg "  448.5: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
        assert {:msg "  448.5: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1191);
        assume wf(Heap, exhaleMask#_1191, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#385, AVLTreeNode.right] == null)) {
        assert {:msg "  448.5: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
        assert {:msg "  448.5: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1191[Heap[this#385, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        assume IsGoodMask(exhaleMask#_1191);
        assume wf(Heap, exhaleMask#_1191, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_1191;
      assume IsGoodExhaleState(exhaleHeap#_1190, Heap, Mask, SecMask);
      Heap := exhaleHeap#_1190;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      // inhale (postcondition)
      assume this#385 != null;
      assume wf(Heap, Mask, SecMask);
      assume Fractions(100) > 0;
      Mask[this#385, AVLTreeNode.valid] := Mask[this#385, AVLTreeNode.valid][perm$R := Mask[this#385, AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#385, AVLTreeNode.valid]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#385 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[this#385, AVLTreeNode.height] := Mask[this#385, AVLTreeNode.height][perm$R := Mask[this#385, AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#385, AVLTreeNode.height]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#385 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[this#385, AVLTreeNode.keys] := Mask[this#385, AVLTreeNode.keys][perm$R := Mask[this#385, AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#385, AVLTreeNode.keys]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#385 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume Fractions(50) > 0;
      Mask[this#385, AVLTreeNode.balanceFactor] := Mask[this#385, AVLTreeNode.balanceFactor][perm$R := Mask[this#385, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(Mask);
      assume IsGoodState(heapFragment(Heap[this#385, AVLTreeNode.balanceFactor]));
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume Seq#Equal(Heap[this#385, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1185[this#385, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1185[callHeap#_1185[this#385, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1185[this#385, AVLTreeNode.key])), ite(callHeap#_1185[this#385, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1185[callHeap#_1185[this#385, AVLTreeNode.right], AVLTreeNode.keys])));
      assume Heap[this#385, AVLTreeNode.height] == ite(ite(callHeap#_1185[this#385, AVLTreeNode.left] == null, 0, callHeap#_1185[callHeap#_1185[this#385, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1185[this#385, AVLTreeNode.right] == null, 0, callHeap#_1185[callHeap#_1185[this#385, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1185[this#385, AVLTreeNode.left] == null, 0, callHeap#_1185[callHeap#_1185[this#385, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1185[this#385, AVLTreeNode.right] == null, 0, callHeap#_1185[callHeap#_1185[this#385, AVLTreeNode.right], AVLTreeNode.height]) + 1);
      assume Heap[this#385, AVLTreeNode.balanceFactor] == (ite(callHeap#_1185[this#385, AVLTreeNode.left] == null, 0, callHeap#_1185[callHeap#_1185[this#385, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1185[this#385, AVLTreeNode.right] == null, 0, callHeap#_1185[callHeap#_1185[this#385, AVLTreeNode.right], AVLTreeNode.height]));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      // assigment to r
      r#41 := this;
      // assert
      assertHeap#_1208 := Heap;
      assertMask#_1209 := Mask;
      assertSecMask#_1210 := SecMask;
      assertCredits#_1211 := Credits;
      assume wf(assertHeap#_1208, assertMask#_1209, assertSecMask#_1210);
      // begin exhale (assert)
      exhaleMask#_1213 := assertMask#_1209;
      havoc exhaleHeap#_1212;
      if (!(r#41 == null)) {
        assert {:msg "  450.27: Receiver might be null."} true ==> (r#41 != null);
        assert {:msg "  450.27: Location might not be readable."} true ==> CanRead(assertMask#_1209, assertSecMask#_1210, r#41, AVLTreeNode.height);
        assert {:msg "  450.43: Receiver might be null."} true ==> (this != null);
        assert {:msg "  450.43: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
        assert {:msg "  450.54: Receiver might be null."} true && (!(assertHeap#_1208[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#41 != null);
        assert {:msg "  450.54: Location might not be readable."} true && (!(assertHeap#_1208[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(assertMask#_1209, assertSecMask#_1210, r#41, AVLTreeNode.height);
        assert {:msg "  450.70: Receiver might be null."} true && (!(assertHeap#_1208[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
        assert {:msg "  450.70: Location might not be readable."} true && (!(assertHeap#_1208[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.height);
        assert {:msg "  450.5: Assertion might not hold. The expression at 450.27 might not evaluate to true."} (assertHeap#_1208[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (assertHeap#_1208[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
      }
      assertMask#_1209 := exhaleMask#_1213;
      assume IsGoodExhaleState(exhaleHeap#_1212, assertHeap#_1208, assertMask#_1209, assertSecMask#_1210);
      assertHeap#_1208 := exhaleHeap#_1212;
      assume IsGoodMask(assertMask#_1209);
      assume wf(assertHeap#_1208, assertMask#_1209, assertSecMask#_1210);
      // end exhale
    }
    // assert
    assertHeap#_1214 := Heap;
    assertMask#_1215 := Mask;
    assertSecMask#_1216 := SecMask;
    assertCredits#_1217 := Credits;
    assume wf(assertHeap#_1214, assertMask#_1215, assertSecMask#_1216);
    // begin exhale (assert)
    exhaleMask#_1219 := assertMask#_1215;
    havoc exhaleHeap#_1218;
    if (!(r#41 == null)) {
      assert {:msg "  452.11: Receiver might be null."} true && (0 <= k#91#391) ==> (r#41 != null);
      assert {:msg "  452.11: Location might not be readable."} true && (0 <= k#91#391) ==> CanRead(assertMask#_1215, assertSecMask#_1216, r#41, AVLTreeNode.keys);
      assert {:msg "  452.45: Receiver might be null."} true && (0 <= k#91#391) && (k#91#391 < Seq#Length(assertHeap#_1214[r#41, AVLTreeNode.keys])) ==> (m#42 != null);
      assert {:msg "  452.45: Location might not be readable."} true && (0 <= k#91#391) && (k#91#391 < Seq#Length(assertHeap#_1214[r#41, AVLTreeNode.keys])) ==> CanRead(assertMask#_1215, assertSecMask#_1216, m#42, AVLTreeNode.keys);
      assert {:msg "  452.45: Sequence index might be negative."} true && (0 <= k#91#391) && (k#91#391 < Seq#Length(assertHeap#_1214[r#41, AVLTreeNode.keys])) ==> (0 <= 0);
      assert {:msg "  452.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#91#391) && (k#91#391 < Seq#Length(assertHeap#_1214[r#41, AVLTreeNode.keys])) ==> (0 < Seq#Length(assertHeap#_1214[m#42, AVLTreeNode.keys]));
      assert {:msg "  452.11: Receiver might be null."} true && (0 <= k#91#391) && (k#91#391 < Seq#Length(assertHeap#_1214[r#41, AVLTreeNode.keys])) ==> (r#41 != null);
      assert {:msg "  452.11: Location might not be readable."} true && (0 <= k#91#391) && (k#91#391 < Seq#Length(assertHeap#_1214[r#41, AVLTreeNode.keys])) ==> CanRead(assertMask#_1215, assertSecMask#_1216, r#41, AVLTreeNode.keys);
      assert {:msg "  452.57: Sequence index might be negative."} true && (0 <= k#91#391) && (k#91#391 < Seq#Length(assertHeap#_1214[r#41, AVLTreeNode.keys])) ==> (0 <= k#91#391);
      assert {:msg "  452.57: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#91#391) && (k#91#391 < Seq#Length(assertHeap#_1214[r#41, AVLTreeNode.keys])) ==> (k#91#391 < Seq#Length(assertHeap#_1214[r#41, AVLTreeNode.keys]));
      assert {:msg "  452.4: Assertion might not hold. The expression at 452.23 might not evaluate to true."} (forall k#91#390: int :: (0 <= k#91#390) && (k#91#390 < Seq#Length(assertHeap#_1214[r#41, AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1214[m#42, AVLTreeNode.keys], 0) < Seq#Index(assertHeap#_1214[r#41, AVLTreeNode.keys], k#91#390)));
    }
    assertMask#_1215 := exhaleMask#_1219;
    assume IsGoodExhaleState(exhaleHeap#_1218, assertHeap#_1214, assertMask#_1215, assertSecMask#_1216);
    assertHeap#_1214 := exhaleHeap#_1218;
    assume IsGoodMask(assertMask#_1215);
    assume wf(assertHeap#_1214, assertMask#_1215, assertSecMask#_1216);
    // end exhale
  }
  // begin exhale (postcondition)
  exhaleMask#_1221 := Mask;
  havoc exhaleHeap#_1220;
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 413.11 might not hold. The expression at 413.26 might not evaluate to true."} (Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
  }
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 414.11 might not hold. The expression at 414.24 might not evaluate to true."} (Seq#Length(Heap[r#41, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this, AVLTreeNode.keys]);
  }
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assert {:msg "  403.2: The postcondition at 415.11 might not hold. The expression at 415.30 might not evaluate to true."} !(r#41 == null);
  }
  if (old(Heap)[this, AVLTreeNode.height] == 1) {
    assert {:msg "  403.2: The postcondition at 416.11 might not hold. The expression at 416.30 might not evaluate to true."} r#41 == null;
  }
  assert {:msg "  403.2: The postcondition at 417.11 might not hold. The expression at 417.11 might not evaluate to true."} (old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height])) || (old(Heap)[this, AVLTreeNode.height] == (ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]) + 1));
  assert {:msg "  403.2: The postcondition at 419.11 might not hold. The expression at 419.11 might not evaluate to true."} !(m#42 == null);
  assert {:msg "  403.2: The postcondition at 424.11 might not hold. The expression at 424.11 might not evaluate to true."} Heap[m#42, AVLTreeNode.height] == 1;
  assert {:msg "  403.2: The postcondition at 425.11 might not hold. The expression at 425.11 might not evaluate to true."} Seq#Length(Heap[m#42, AVLTreeNode.keys]) == 1;
  assert {:msg "  403.2: The postcondition at 427.11 might not hold. The expression at 427.11 might not evaluate to true."} Seq#Equal(Seq#Append(Heap[m#42, AVLTreeNode.keys], ite(r#41 == null, Seq#Empty(), Heap[r#41, AVLTreeNode.keys])), old(Heap)[this, AVLTreeNode.keys]);
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 428.11 might not hold. The expression at 428.23 might not evaluate to true."} (forall k#89#393: int :: (0 <= k#89#393) && (k#89#393 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (Seq#Index(Heap[m#42, AVLTreeNode.keys], 0) < Seq#Index(Heap[r#41, AVLTreeNode.keys], k#89#393)));
  }
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 409.11 might not hold. The permission at 409.25 might not be positive."} Fractions(100) > 0;
    assert {:msg "  403.2: The postcondition at 409.11 might not hold. Insufficient fraction at 409.25 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1221[r#41, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1221[r#41, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1221[r#41, AVLTreeNode.valid][perm$N]));
    exhaleMask#_1221[r#41, AVLTreeNode.valid] := exhaleMask#_1221[r#41, AVLTreeNode.valid][perm$R := exhaleMask#_1221[r#41, AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_1221, SecMask, r#41, AVLTreeNode.valid)) {
      assume Heap[r#41, AVLTreeNode.valid] < exhaleHeap#_1220[r#41, AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1221);
    assume wf(Heap, exhaleMask#_1221, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 410.11 might not hold. The permission at 410.25 might not be positive."} Fractions(50) > 0;
    assert {:msg "  403.2: The postcondition at 410.11 might not hold. Insufficient fraction at 410.25 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1221[r#41, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1221[r#41, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1221[r#41, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1221[r#41, AVLTreeNode.keys] := exhaleMask#_1221[r#41, AVLTreeNode.keys][perm$R := exhaleMask#_1221[r#41, AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1221);
    assume wf(Heap, exhaleMask#_1221, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 411.11 might not hold. The permission at 411.25 might not be positive."} Fractions(50) > 0;
    assert {:msg "  403.2: The postcondition at 411.11 might not hold. Insufficient fraction at 411.25 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1221[r#41, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1221[r#41, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1221[r#41, AVLTreeNode.height][perm$N]));
    exhaleMask#_1221[r#41, AVLTreeNode.height] := exhaleMask#_1221[r#41, AVLTreeNode.height][perm$R := exhaleMask#_1221[r#41, AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1221);
    assume wf(Heap, exhaleMask#_1221, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 412.11 might not hold. The permission at 412.25 might not be positive."} Fractions(50) > 0;
    assert {:msg "  403.2: The postcondition at 412.11 might not hold. Insufficient fraction at 412.25 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1221[r#41, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1221[r#41, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1221[r#41, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1221[r#41, AVLTreeNode.balanceFactor] := exhaleMask#_1221[r#41, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1221[r#41, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1221);
    assume wf(Heap, exhaleMask#_1221, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  403.2: The postcondition at 420.11 might not hold. The permission at 420.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  403.2: The postcondition at 420.11 might not hold. Insufficient fraction at 420.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1221[m#42, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1221[m#42, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1221[m#42, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1221[m#42, AVLTreeNode.valid] := exhaleMask#_1221[m#42, AVLTreeNode.valid][perm$R := exhaleMask#_1221[m#42, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (!CanRead(exhaleMask#_1221, SecMask, m#42, AVLTreeNode.valid)) {
    assume Heap[m#42, AVLTreeNode.valid] < exhaleHeap#_1220[m#42, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_1221);
  assume wf(Heap, exhaleMask#_1221, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  403.2: The postcondition at 421.11 might not hold. The permission at 421.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  403.2: The postcondition at 421.11 might not hold. Insufficient fraction at 421.11 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1221[m#42, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1221[m#42, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1221[m#42, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1221[m#42, AVLTreeNode.keys] := exhaleMask#_1221[m#42, AVLTreeNode.keys][perm$R := exhaleMask#_1221[m#42, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_1221);
  assume wf(Heap, exhaleMask#_1221, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  403.2: The postcondition at 422.11 might not hold. The permission at 422.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  403.2: The postcondition at 422.11 might not hold. Insufficient fraction at 422.11 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1221[m#42, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1221[m#42, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1221[m#42, AVLTreeNode.height][perm$N]));
  exhaleMask#_1221[m#42, AVLTreeNode.height] := exhaleMask#_1221[m#42, AVLTreeNode.height][perm$R := exhaleMask#_1221[m#42, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_1221);
  assume wf(Heap, exhaleMask#_1221, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  403.2: The postcondition at 423.11 might not hold. The permission at 423.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  403.2: The postcondition at 423.11 might not hold. Insufficient fraction at 423.11 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1221[m#42, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1221[m#42, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1221[m#42, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1221[m#42, AVLTreeNode.balanceFactor] := exhaleMask#_1221[m#42, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1221[m#42, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_1221);
  assume wf(Heap, exhaleMask#_1221, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1221;
  assume IsGoodExhaleState(exhaleHeap#_1220, Heap, Mask, SecMask);
  Heap := exhaleHeap#_1220;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  403.2: Method might lock/unlock more than allowed."} (forall lk#_1230: ref :: {Heap[lk#_1230, held]} {Heap[lk#_1230, rdheld]} (((0 < Heap[lk#_1230, held]) == (0 < old(Heap)[lk#_1230, held])) && (Heap[lk#_1230, rdheld] == old(Heap)[lk#_1230, rdheld])) || false);
  assert {:msg "  403.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.has$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#47: int where true) returns (b#48: bool where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1231: int;
  assume (0 < methodK#_1231) && ((1000 * methodK#_1231) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  457.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_1231 > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + methodK#_1231];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  460.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_1231 > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + methodK#_1231];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  462.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  462.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.keys);
  assume b#48 == Seq#Contains(Heap[this, AVLTreeNode.keys], k#47);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.has(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#47: int where true) returns (b#48: bool where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1231: int;
  var unfoldK#_1232: int;
  var oldVers#_1252: int;
  var newVers#_1253: int;
  var cond#_1254: bool;
  var assertHeap#_1255: HeapType;
  var assertMask#_1256: MaskType;
  var assertSecMask#_1257: MaskType;
  var assertCredits#_1258: CreditsType;
  var exhaleMask#_1260: MaskType;
  var exhaleHeap#_1259: HeapType;
  var cond#_1261: bool;
  var cond#_1262: bool;
  var methodCallK#_1267: int;
  var this#401: ref where (this#401 == null) || (dtype(this#401) == AVLTreeNode#t);
  var k#402: int where true;
  var b#403: bool where true;
  var callHeap#_1263: HeapType;
  var callMask#_1264: MaskType;
  var callSecMask#_1265: MaskType;
  var callCredits#_1266: CreditsType;
  var exhaleMask#_1269: MaskType;
  var exhaleHeap#_1268: HeapType;
  var isHeld#_1272: int;
  var isRdHeld#_1273: bool;
  var cond#_1274: bool;
  var methodCallK#_1279: int;
  var this#404: ref where (this#404 == null) || (dtype(this#404) == AVLTreeNode#t);
  var k#405: int where true;
  var b#406: bool where true;
  var callHeap#_1275: HeapType;
  var callMask#_1276: MaskType;
  var callSecMask#_1277: MaskType;
  var callCredits#_1278: CreditsType;
  var exhaleMask#_1281: MaskType;
  var exhaleHeap#_1280: HeapType;
  var isHeld#_1284: int;
  var isRdHeld#_1285: bool;
  var foldK#_1289: int;
  var exhaleMask#_1291: MaskType;
  var exhaleHeap#_1290: HeapType;
  var predRec#_1286: ref;
  var predVer#_1287: int;
  var predFlag#_1288: bool;
  var exhaleMask#_1307: MaskType;
  var exhaleHeap#_1306: HeapType;
  assume (0 < methodK#_1231) && ((1000 * methodK#_1231) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_1231 > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + methodK#_1231];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // unfold
  assume #AVLTreeNode.valid#trigger(this);
  assume (0 < unfoldK#_1232) && (unfoldK#_1232 < Fractions(1)) && ((1000 * unfoldK#_1232) < methodK#_1231);
  assert {:msg "  464.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  464.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  464.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[this, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[this, AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[this, AVLTreeNode.valid][perm$N]));
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#395: int :: (0 <= lk#79#395) && (lk#79#395 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#395) < Heap[this, AVLTreeNode.key]));
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#396: int :: (0 <= rk#80#396) && (rk#80#396 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#396)));
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] > 0;
    SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, this, AVLTreeNode.valid)) {
    oldVers#_1252 := Heap[this, AVLTreeNode.valid];
    havoc newVers#_1253;
    Heap[this, AVLTreeNode.valid] := newVers#_1253;
    assume oldVers#_1252 < Heap[this, AVLTreeNode.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#399: int :: (0 <= lk#79#399) && (lk#79#399 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#399) < Heap[this, AVLTreeNode.key]));
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#400: int :: (0 <= rk#80#400) && (rk#80#400 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#400)));
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_1254 := k#47 == Heap[this, AVLTreeNode.key];
  assert {:msg "  465.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  465.10: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  if (cond#_1254) {
    // assigment to b
    b#48 := true;
    // assert
    assertHeap#_1255 := Heap;
    assertMask#_1256 := Mask;
    assertSecMask#_1257 := SecMask;
    assertCredits#_1258 := Credits;
    assume wf(assertHeap#_1255, assertMask#_1256, assertSecMask#_1257);
    // begin exhale (assert)
    exhaleMask#_1260 := assertMask#_1256;
    havoc exhaleHeap#_1259;
    assert {:msg "  467.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  467.12: Location might not be readable."} true ==> CanRead(assertMask#_1256, assertSecMask#_1257, this, AVLTreeNode.key);
    assert {:msg "  467.11: Sequence index might be negative."} true ==> (0 <= 0);
    assert {:msg "  467.11: Sequence index might be larger than or equal to the length of the sequence."} true ==> (0 < Seq#Length(Seq#Singleton(assertHeap#_1255[this, AVLTreeNode.key])));
    assert {:msg "  467.4: Assertion might not hold. The expression at 467.11 might not evaluate to true."} Seq#Index(Seq#Singleton(assertHeap#_1255[this, AVLTreeNode.key]), 0) == k#47;
    assertMask#_1256 := exhaleMask#_1260;
    assume IsGoodExhaleState(exhaleHeap#_1259, assertHeap#_1255, assertMask#_1256, assertSecMask#_1257);
    assertHeap#_1255 := exhaleHeap#_1259;
    assume IsGoodMask(assertMask#_1256);
    assume wf(assertHeap#_1255, assertMask#_1256, assertSecMask#_1257);
    // end exhale
  } else {
    // if
    cond#_1261 := k#47 < Heap[this, AVLTreeNode.key];
    assert {:msg "  469.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  469.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    if (cond#_1261) {
      // if
      cond#_1262 := !(Heap[this, AVLTreeNode.left] == null);
      assert {:msg "  470.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  470.9: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
      if (cond#_1262) {
        assume (0 < methodCallK#_1267) && ((1000 * methodCallK#_1267) < Fractions(1)) && ((1000 * methodCallK#_1267) < methodK#_1231);
        // call has
        callHeap#_1263 := Heap;
        callMask#_1264 := Mask;
        callSecMask#_1265 := SecMask;
        callCredits#_1266 := Credits;
        assume wf(callHeap#_1263, callMask#_1264, callSecMask#_1265);
        assert {:msg "  471.16: Receiver might be null."} true ==> (this != null);
        assert {:msg "  471.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
        assert {:msg "  471.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#401 := Heap[this, AVLTreeNode.left];
        k#402 := k#47;
        // begin exhale (precondition)
        exhaleMask#_1269 := Mask;
        havoc exhaleHeap#_1268;
        assert {:msg "  471.6: The precondition at 458.12 might not hold. The permission at 458.12 might not be positive."} methodCallK#_1267 > 0;
        assert {:msg "  471.6: The precondition at 458.12 might not hold. Insufficient fraction at 458.12 for AVLTreeNode.keys."} exhaleMask#_1269[this#401, AVLTreeNode.keys][perm$R] > 0;
        assume methodCallK#_1267 < exhaleMask#_1269[this#401, AVLTreeNode.keys][perm$R];
        exhaleMask#_1269[this#401, AVLTreeNode.keys] := exhaleMask#_1269[this#401, AVLTreeNode.keys][perm$R := exhaleMask#_1269[this#401, AVLTreeNode.keys][perm$R] - methodCallK#_1267];
        assume IsGoodMask(exhaleMask#_1269);
        assume wf(Heap, exhaleMask#_1269, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  471.6: The precondition at 457.12 might not hold. The permission at 457.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  471.6: The precondition at 457.12 might not hold. Insufficient fraction at 457.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1269[this#401, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1269[this#401, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1269[this#401, AVLTreeNode.valid][perm$N]));
        exhaleMask#_1269[this#401, AVLTreeNode.valid] := exhaleMask#_1269[this#401, AVLTreeNode.valid][perm$R := exhaleMask#_1269[this#401, AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_1269, SecMask, this#401, AVLTreeNode.valid)) {
          assume Heap[this#401, AVLTreeNode.valid] < exhaleHeap#_1268[this#401, AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_1269);
        assume wf(Heap, exhaleMask#_1269, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_1269;
        assume IsGoodExhaleState(exhaleHeap#_1268, Heap, Mask, SecMask);
        Heap := exhaleHeap#_1268;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc b#403;
        // inhale (postcondition)
        assume this#401 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[this#401, AVLTreeNode.valid] := Mask[this#401, AVLTreeNode.valid][perm$R := Mask[this#401, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#401, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#401 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_1267 > 0;
        Mask[this#401, AVLTreeNode.keys] := Mask[this#401, AVLTreeNode.keys][perm$R := Mask[this#401, AVLTreeNode.keys][perm$R] + methodCallK#_1267];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#401, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume b#403 == Seq#Contains(Heap[this#401, AVLTreeNode.keys], k#402);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        b#48 := b#403;
      } else {
        // assigment to b
        b#48 := false;
      }
    } else {
      // if
      cond#_1274 := !(Heap[this, AVLTreeNode.right] == null);
      assert {:msg "  476.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  476.9: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
      if (cond#_1274) {
        assume (0 < methodCallK#_1279) && ((1000 * methodCallK#_1279) < Fractions(1)) && ((1000 * methodCallK#_1279) < methodK#_1231);
        // call has
        callHeap#_1275 := Heap;
        callMask#_1276 := Mask;
        callSecMask#_1277 := SecMask;
        callCredits#_1278 := Credits;
        assume wf(callHeap#_1275, callMask#_1276, callSecMask#_1277);
        assert {:msg "  477.16: Receiver might be null."} true ==> (this != null);
        assert {:msg "  477.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
        assert {:msg "  477.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#404 := Heap[this, AVLTreeNode.right];
        k#405 := k#47;
        // begin exhale (precondition)
        exhaleMask#_1281 := Mask;
        havoc exhaleHeap#_1280;
        assert {:msg "  477.6: The precondition at 458.12 might not hold. The permission at 458.12 might not be positive."} methodCallK#_1279 > 0;
        assert {:msg "  477.6: The precondition at 458.12 might not hold. Insufficient fraction at 458.12 for AVLTreeNode.keys."} exhaleMask#_1281[this#404, AVLTreeNode.keys][perm$R] > 0;
        assume methodCallK#_1279 < exhaleMask#_1281[this#404, AVLTreeNode.keys][perm$R];
        exhaleMask#_1281[this#404, AVLTreeNode.keys] := exhaleMask#_1281[this#404, AVLTreeNode.keys][perm$R := exhaleMask#_1281[this#404, AVLTreeNode.keys][perm$R] - methodCallK#_1279];
        assume IsGoodMask(exhaleMask#_1281);
        assume wf(Heap, exhaleMask#_1281, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  477.6: The precondition at 457.12 might not hold. The permission at 457.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  477.6: The precondition at 457.12 might not hold. Insufficient fraction at 457.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1281[this#404, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1281[this#404, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1281[this#404, AVLTreeNode.valid][perm$N]));
        exhaleMask#_1281[this#404, AVLTreeNode.valid] := exhaleMask#_1281[this#404, AVLTreeNode.valid][perm$R := exhaleMask#_1281[this#404, AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (!CanRead(exhaleMask#_1281, SecMask, this#404, AVLTreeNode.valid)) {
          assume Heap[this#404, AVLTreeNode.valid] < exhaleHeap#_1280[this#404, AVLTreeNode.valid];
        }
        assume IsGoodMask(exhaleMask#_1281);
        assume wf(Heap, exhaleMask#_1281, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_1281;
        assume IsGoodExhaleState(exhaleHeap#_1280, Heap, Mask, SecMask);
        Heap := exhaleHeap#_1280;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc b#406;
        // inhale (postcondition)
        assume this#404 != null;
        assume wf(Heap, Mask, SecMask);
        assume Fractions(100) > 0;
        Mask[this#404, AVLTreeNode.valid] := Mask[this#404, AVLTreeNode.valid][perm$R := Mask[this#404, AVLTreeNode.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#404, AVLTreeNode.valid]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#404 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_1279 > 0;
        Mask[this#404, AVLTreeNode.keys] := Mask[this#404, AVLTreeNode.keys][perm$R := Mask[this#404, AVLTreeNode.keys][perm$R] + methodCallK#_1279];
        assume IsGoodMask(Mask);
        assume IsGoodState(heapFragment(Heap[this#404, AVLTreeNode.keys]));
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume b#406 == Seq#Contains(Heap[this#404, AVLTreeNode.keys], k#405);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        b#48 := b#406;
      } else {
        // assigment to b
        b#48 := false;
      }
    }
  }
  // fold
  assume #AVLTreeNode.valid#trigger(this);
  assume (0 < foldK#_1289) && ((1000 * foldK#_1289) < Fractions(1)) && ((1000 * foldK#_1289) < methodK#_1231);
  assert {:msg "  483.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_1291 := Mask;
  havoc exhaleHeap#_1290;
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 129.22 might not evaluate to true."} (forall lk#79#407: int :: (0 <= lk#79#407) && (lk#79#407 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#407) < Heap[this, AVLTreeNode.key]));
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 130.22 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 136.24 might not evaluate to true."} (forall rk#80#408: int :: (0 <= rk#80#408) && (rk#80#408 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#408)));
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 137.23 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 139.6 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 140.6 might not evaluate to true."} Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 141.7 might not evaluate to true."} (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 146.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 147.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 148.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 149.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 150.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] > 0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 117.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 117.6 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_1291[this, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_1291[this, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1291[this, AVLTreeNode.key][perm$N]));
  exhaleMask#_1291[this, AVLTreeNode.key] := exhaleMask#_1291[this, AVLTreeNode.key][perm$R := exhaleMask#_1291[this, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_1291);
  assume wf(Heap, exhaleMask#_1291, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 118.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 118.6 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1291[this, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1291[this, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1291[this, AVLTreeNode.height][perm$N]));
  exhaleMask#_1291[this, AVLTreeNode.height] := exhaleMask#_1291[this, AVLTreeNode.height][perm$R := exhaleMask#_1291[this, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_1291);
  assume wf(Heap, exhaleMask#_1291, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 119.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 119.6 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_1291[this, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_1291[this, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1291[this, AVLTreeNode.left][perm$N]));
  exhaleMask#_1291[this, AVLTreeNode.left] := exhaleMask#_1291[this, AVLTreeNode.left][perm$R := exhaleMask#_1291[this, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_1291);
  assume wf(Heap, exhaleMask#_1291, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 120.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 120.6 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_1291[this, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_1291[this, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1291[this, AVLTreeNode.right][perm$N]));
  exhaleMask#_1291[this, AVLTreeNode.right] := exhaleMask#_1291[this, AVLTreeNode.right][perm$R := exhaleMask#_1291[this, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_1291);
  assume wf(Heap, exhaleMask#_1291, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 122.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 122.6 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1291[this, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1291[this, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1291[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1291[this, AVLTreeNode.keys] := exhaleMask#_1291[this, AVLTreeNode.keys][perm$R := exhaleMask#_1291[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_1291);
  assume wf(Heap, exhaleMask#_1291, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 123.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 123.6 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1291[this, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1291[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1291[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1291[this, AVLTreeNode.balanceFactor] := exhaleMask#_1291[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1291[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_1291);
  assume wf(Heap, exhaleMask#_1291, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 125.22 might not be positive."} Fractions(100) > 0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 125.22 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    if (!CanRead(exhaleMask#_1291, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1290[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1291);
    assume wf(Heap, exhaleMask#_1291, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 126.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 126.22 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1291);
    assume wf(Heap, exhaleMask#_1291, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 127.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 127.22 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1291);
    assume wf(Heap, exhaleMask#_1291, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 128.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 128.22 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1291[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1291);
    assume wf(Heap, exhaleMask#_1291, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 132.23 might not be positive."} Fractions(100) > 0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 132.23 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    if (!CanRead(exhaleMask#_1291, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1290[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1291);
    assume wf(Heap, exhaleMask#_1291, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 133.23 might not be positive."} Fractions(50) > 0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 133.23 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1291);
    assume wf(Heap, exhaleMask#_1291, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 134.23 might not be positive."} Fractions(50) > 0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 134.23 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1291);
    assume wf(Heap, exhaleMask#_1291, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 135.23 might not be positive."} Fractions(50) > 0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 135.23 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1291[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1291);
    assume wf(Heap, exhaleMask#_1291, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_1291;
  assume IsGoodExhaleState(exhaleHeap#_1290, Heap, Mask, SecMask);
  Heap := exhaleHeap#_1290;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  predRec#_1286 := this;
  predVer#_1287 := Heap[this, AVLTreeNode.valid];
  predFlag#_1288 := true;
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_1307 := Mask;
  havoc exhaleHeap#_1306;
  assert {:msg "  456.2: The postcondition at 462.11 might not hold. The expression at 462.11 might not evaluate to true."} b#48 == Seq#Contains(Heap[this, AVLTreeNode.keys], k#47);
  assert {:msg "  456.2: The postcondition at 460.11 might not hold. The permission at 460.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  456.2: The postcondition at 460.11 might not hold. Insufficient fraction at 460.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1307[this, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1307[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1307[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1307[this, AVLTreeNode.valid] := exhaleMask#_1307[this, AVLTreeNode.valid][perm$R := exhaleMask#_1307[this, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_1287 == Heap[this, AVLTreeNode.valid]) && (predRec#_1286 == this) && true && (!cond#_1254) && (!cond#_1261) && (!cond#_1274) && predFlag#_1288)) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#411: int :: (0 <= lk#79#411) && (lk#79#411 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#411) < Heap[this, AVLTreeNode.key]));
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#412: int :: (0 <= rk#80#412) && (rk#80#412 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#412)));
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] > 0;
    SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(exhaleMask#_1307, SecMask, this, AVLTreeNode.valid)) {
    assume Heap[this, AVLTreeNode.valid] < exhaleHeap#_1306[this, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_1307);
  assume wf(Heap, exhaleMask#_1307, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  456.2: The postcondition at 461.11 might not hold. The permission at 461.11 might not be positive."} methodK#_1231 > 0;
  assert {:msg "  456.2: The postcondition at 461.11 might not hold. Insufficient fraction at 461.11 for AVLTreeNode.keys."} (methodK#_1231 <= exhaleMask#_1307[this, AVLTreeNode.keys][perm$R]) && ((methodK#_1231 == exhaleMask#_1307[this, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1307[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1307[this, AVLTreeNode.keys] := exhaleMask#_1307[this, AVLTreeNode.keys][perm$R := exhaleMask#_1307[this, AVLTreeNode.keys][perm$R] - methodK#_1231];
  assume IsGoodMask(exhaleMask#_1307);
  assume wf(Heap, exhaleMask#_1307, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1307;
  assume IsGoodExhaleState(exhaleHeap#_1306, Heap, Mask, SecMask);
  Heap := exhaleHeap#_1306;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  456.2: Method might lock/unlock more than allowed."} (forall lk#_1326: ref :: {Heap[lk#_1326, held]} {Heap[lk#_1326, rdheld]} (((0 < Heap[lk#_1326, held]) == (0 < old(Heap)[lk#_1326, held])) && (Heap[lk#_1326, rdheld] == old(Heap)[lk#_1326, rdheld])) || false);
  assert {:msg "  456.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.getBalanceFactor$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#49: int where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1327: int;
  var predRec#_1328: ref;
  var predFlag#_1330: bool;
  var predVer#_1329: int;
  var unfoldingK#_1336: int;
  var predFlag#_1335: bool;
  var unfoldingHeap#_1331: HeapType;
  var unfoldingMask#_1332: MaskType;
  var unfoldingSecMask#_1333: MaskType;
  var unfoldingCredits#_1334: CreditsType;
  var oldVers#_1356: int;
  var newVers#_1357: int;
  var predRec#_1374: ref;
  var predFlag#_1376: bool;
  var predVer#_1375: int;
  var unfoldingK#_1382: int;
  var predFlag#_1381: bool;
  var unfoldingHeap#_1377: HeapType;
  var unfoldingMask#_1378: MaskType;
  var unfoldingSecMask#_1379: MaskType;
  var unfoldingCredits#_1380: CreditsType;
  var oldVers#_1402: int;
  var newVers#_1403: int;
  assume (0 < methodK#_1327) && ((1000 * methodK#_1327) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  488.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_1327 > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + methodK#_1327];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  491.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_1327 > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + methodK#_1327];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  493.17: Receiver might be null."} true ==> (this != null);
  assert {:msg "  493.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.balanceFactor);
  assume bf#49 == Heap[this, AVLTreeNode.balanceFactor];
  predRec#_1328 := this;
  predFlag#_1330 := true;
  assume #AVLTreeNode.valid#trigger(this);
  predVer#_1329 := Heap[this, AVLTreeNode.valid];
  // unfolding
  assume (0 < unfoldingK#_1336) && ((1000 * unfoldingK#_1336) < Fractions(1));
  predFlag#_1335 := true;
  assert {:msg "  495.21: Receiver might be null."} true ==> (this != null);
  unfoldingHeap#_1331 := Heap;
  unfoldingMask#_1332 := Mask;
  unfoldingSecMask#_1333 := SecMask;
  unfoldingCredits#_1334 := Credits;
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  // begin exhale (unfolding)
  assert {:msg "  495.11: Unfolding might fail. The permission at 495.21 might not be positive."} Fractions(100) > 0;
  assert {:msg "  495.11: Unfolding might fail. Insufficient fraction at 495.21 for AVLTreeNode.valid."} (Fractions(100) <= unfoldingMask#_1332[this, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == unfoldingMask#_1332[this, AVLTreeNode.valid][perm$R]) ==> (0 <= unfoldingMask#_1332[this, AVLTreeNode.valid][perm$N]));
  unfoldingMask#_1332[this, AVLTreeNode.valid] := unfoldingMask#_1332[this, AVLTreeNode.valid][perm$R := unfoldingMask#_1332[this, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#415: int :: (0 <= lk#79#415) && (lk#79#415 < Seq#Length(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#415) < unfoldingHeap#_1331[this, AVLTreeNode.key]));
    }
    if (!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#416: int :: (0 <= rk#80#416) && (rk#80#416 < Seq#Length(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1331[this, AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#416)));
    }
    if (!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(unfoldingHeap#_1331[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1331[this, AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1331[this, AVLTreeNode.key])), ite(unfoldingHeap#_1331[this, AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(unfoldingHeap#_1331[this, AVLTreeNode.keys], unfoldingHeap#_1331[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1331[this, AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1331[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume unfoldingHeap#_1331[this, AVLTreeNode.height] == ite(ite(unfoldingHeap#_1331[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1331[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1331[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1331[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume unfoldingHeap#_1331[this, AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1331[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1331[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume unfoldingHeap#_1331[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume unfoldingHeap#_1331[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume unfoldingHeap#_1331[this, AVLTreeNode.height] > 0;
    unfoldingSecMask#_1333[this, AVLTreeNode.key] := unfoldingSecMask#_1333[this, AVLTreeNode.key][perm$R := unfoldingSecMask#_1333[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (unfoldingSecMask#_1333[this, AVLTreeNode.key][perm$R] < 0) {
      unfoldingSecMask#_1333[this, AVLTreeNode.key] := unfoldingSecMask#_1333[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    unfoldingSecMask#_1333[this, AVLTreeNode.height] := unfoldingSecMask#_1333[this, AVLTreeNode.height][perm$R := unfoldingSecMask#_1333[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (unfoldingSecMask#_1333[this, AVLTreeNode.height][perm$R] < 0) {
      unfoldingSecMask#_1333[this, AVLTreeNode.height] := unfoldingSecMask#_1333[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    unfoldingSecMask#_1333[this, AVLTreeNode.left] := unfoldingSecMask#_1333[this, AVLTreeNode.left][perm$R := unfoldingSecMask#_1333[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (unfoldingSecMask#_1333[this, AVLTreeNode.left][perm$R] < 0) {
      unfoldingSecMask#_1333[this, AVLTreeNode.left] := unfoldingSecMask#_1333[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    unfoldingSecMask#_1333[this, AVLTreeNode.right] := unfoldingSecMask#_1333[this, AVLTreeNode.right][perm$R := unfoldingSecMask#_1333[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (unfoldingSecMask#_1333[this, AVLTreeNode.right][perm$R] < 0) {
      unfoldingSecMask#_1333[this, AVLTreeNode.right] := unfoldingSecMask#_1333[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    unfoldingSecMask#_1333[this, AVLTreeNode.keys] := unfoldingSecMask#_1333[this, AVLTreeNode.keys][perm$R := unfoldingSecMask#_1333[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (unfoldingSecMask#_1333[this, AVLTreeNode.keys][perm$R] < 0) {
      unfoldingSecMask#_1333[this, AVLTreeNode.keys] := unfoldingSecMask#_1333[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    unfoldingSecMask#_1333[this, AVLTreeNode.balanceFactor] := unfoldingSecMask#_1333[this, AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1333[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (unfoldingSecMask#_1333[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      unfoldingSecMask#_1333[this, AVLTreeNode.balanceFactor] := unfoldingSecMask#_1333[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    if (!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) {
      unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
      assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    }
    if (!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) {
      unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
      assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    }
    if (!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) {
      unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
      assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    }
    if (!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) {
      unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
      assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    }
    if (!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) {
      unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
      assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    }
    if (!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) {
      unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
      assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    }
    if (!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) {
      unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
      assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    }
    if (!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) {
      unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1333[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
      assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    }
    assume wf(unfoldingHeap#_1331, unfoldingSecMask#_1333, unfoldingSecMask#_1333);
    // end exhale
  }
  if (!CanRead(unfoldingMask#_1332, unfoldingSecMask#_1333, this, AVLTreeNode.valid)) {
    oldVers#_1356 := unfoldingHeap#_1331[this, AVLTreeNode.valid];
    havoc newVers#_1357;
    unfoldingHeap#_1331[this, AVLTreeNode.valid] := newVers#_1357;
    assume oldVers#_1356 < unfoldingHeap#_1331[this, AVLTreeNode.valid];
  }
  assume IsGoodMask(unfoldingMask#_1332);
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume IsGoodMask(unfoldingMask#_1332);
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  // end exhale
  // inhale (unfolding)
  assume this != null;
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume true;
  assume Fractions(100) > 0;
  unfoldingMask#_1332[this, AVLTreeNode.key] := unfoldingMask#_1332[this, AVLTreeNode.key][perm$R := unfoldingMask#_1332[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(unfoldingMask#_1332);
  assume IsGoodState(heapFragment(unfoldingHeap#_1331[this, AVLTreeNode.key]));
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume this != null;
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume true;
  assume Fractions(50) > 0;
  unfoldingMask#_1332[this, AVLTreeNode.height] := unfoldingMask#_1332[this, AVLTreeNode.height][perm$R := unfoldingMask#_1332[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(unfoldingMask#_1332);
  assume IsGoodState(heapFragment(unfoldingHeap#_1331[this, AVLTreeNode.height]));
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume this != null;
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume (unfoldingHeap#_1331[this, AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1331[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  unfoldingMask#_1332[this, AVLTreeNode.left] := unfoldingMask#_1332[this, AVLTreeNode.left][perm$R := unfoldingMask#_1332[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(unfoldingMask#_1332);
  assume IsGoodState(heapFragment(unfoldingHeap#_1331[this, AVLTreeNode.left]));
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume this != null;
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume (unfoldingHeap#_1331[this, AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1331[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  unfoldingMask#_1332[this, AVLTreeNode.right] := unfoldingMask#_1332[this, AVLTreeNode.right][perm$R := unfoldingMask#_1332[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(unfoldingMask#_1332);
  assume IsGoodState(heapFragment(unfoldingHeap#_1331[this, AVLTreeNode.right]));
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume this != null;
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume true;
  assume Fractions(50) > 0;
  unfoldingMask#_1332[this, AVLTreeNode.keys] := unfoldingMask#_1332[this, AVLTreeNode.keys][perm$R := unfoldingMask#_1332[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(unfoldingMask#_1332);
  assume IsGoodState(heapFragment(unfoldingHeap#_1331[this, AVLTreeNode.keys]));
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume this != null;
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume true;
  assume Fractions(50) > 0;
  unfoldingMask#_1332[this, AVLTreeNode.balanceFactor] := unfoldingMask#_1332[this, AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1332[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(unfoldingMask#_1332);
  assume IsGoodState(heapFragment(unfoldingHeap#_1331[this, AVLTreeNode.balanceFactor]));
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  if (!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1331[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume Fractions(100) > 0;
    unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1332);
    assume IsGoodState(heapFragment(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  }
  if (!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1331[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1332);
    assume IsGoodState(heapFragment(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  }
  if (!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1331[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1332);
    assume IsGoodState(heapFragment(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  }
  if (!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1331[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1332);
    assume IsGoodState(heapFragment(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  }
  if (!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#419: int :: (0 <= lk#79#419) && (lk#79#419 < Seq#Length(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#419) < unfoldingHeap#_1331[this, AVLTreeNode.key]));
  }
  if (!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1331[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume Fractions(100) > 0;
    unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1332);
    assume IsGoodState(heapFragment(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  }
  if (!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1331[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1332);
    assume IsGoodState(heapFragment(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  }
  if (!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1331[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1332);
    assume IsGoodState(heapFragment(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  }
  if (!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1331[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1332[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1332);
    assume IsGoodState(heapFragment(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
    assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  }
  if (!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#420: int :: (0 <= rk#80#420) && (rk#80#420 < Seq#Length(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1331[this, AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#420)));
  }
  if (!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(unfoldingHeap#_1331[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1331[this, AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1331[this, AVLTreeNode.key])), ite(unfoldingHeap#_1331[this, AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(unfoldingHeap#_1331[this, AVLTreeNode.keys], unfoldingHeap#_1331[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1331[this, AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1331[this, AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1331[this, AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1331[this, AVLTreeNode.key])));
  assume unfoldingHeap#_1331[this, AVLTreeNode.height] == ite(ite(unfoldingHeap#_1331[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1331[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1331[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1331[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume unfoldingHeap#_1331[this, AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1331[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1331[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1331[unfoldingHeap#_1331[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume unfoldingHeap#_1331[this, AVLTreeNode.balanceFactor] <= 1;
  assume unfoldingHeap#_1331[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume unfoldingHeap#_1331[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(unfoldingMask#_1332);
  assume wf(unfoldingHeap#_1331, unfoldingMask#_1332, unfoldingSecMask#_1333);
  // end inhale
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#421: int :: (0 <= lk#79#421) && (lk#79#421 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#421) < Heap[this, AVLTreeNode.key]));
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#422: int :: (0 <= rk#80#422) && (rk#80#422 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#422)));
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] > 0;
    SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#425: int :: (0 <= lk#79#425) && (lk#79#425 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#425) < Heap[this, AVLTreeNode.key]));
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#426: int :: (0 <= rk#80#426) && (rk#80#426 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#426)));
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assert {:msg "  495.39: Receiver might be null."} true && (bf#49 > 0) ==> (this != null);
  assert {:msg "  495.39: Location might not be readable."} true && (bf#49 > 0) ==> CanRead(unfoldingMask#_1332, unfoldingSecMask#_1333, this, AVLTreeNode.left);
  assume (bf#49 > 0) ==> (!(Heap[this, AVLTreeNode.left] == null));
  predRec#_1374 := this;
  predFlag#_1376 := true;
  assume #AVLTreeNode.valid#trigger(this);
  predVer#_1375 := Heap[this, AVLTreeNode.valid];
  // unfolding
  assume (0 < unfoldingK#_1382) && ((1000 * unfoldingK#_1382) < Fractions(1));
  predFlag#_1381 := true;
  assert {:msg "  496.21: Receiver might be null."} true ==> (this != null);
  unfoldingHeap#_1377 := Heap;
  unfoldingMask#_1378 := Mask;
  unfoldingSecMask#_1379 := SecMask;
  unfoldingCredits#_1380 := Credits;
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  // begin exhale (unfolding)
  assert {:msg "  496.11: Unfolding might fail. The permission at 496.21 might not be positive."} Fractions(100) > 0;
  assert {:msg "  496.11: Unfolding might fail. Insufficient fraction at 496.21 for AVLTreeNode.valid."} (Fractions(100) <= unfoldingMask#_1378[this, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == unfoldingMask#_1378[this, AVLTreeNode.valid][perm$R]) ==> (0 <= unfoldingMask#_1378[this, AVLTreeNode.valid][perm$N]));
  unfoldingMask#_1378[this, AVLTreeNode.valid] := unfoldingMask#_1378[this, AVLTreeNode.valid][perm$R := unfoldingMask#_1378[this, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if ((false || ((predVer#_1329 == unfoldingHeap#_1377[this, AVLTreeNode.valid]) && (predRec#_1328 == this) && true && predFlag#_1330)) || ((Heap[this, AVLTreeNode.valid] == unfoldingHeap#_1377[this, AVLTreeNode.valid]) && (this == this) && true && predFlag#_1335)) {
    if ((Heap[this, AVLTreeNode.valid] == unfoldingHeap#_1377[this, AVLTreeNode.valid]) && (this == this) && true && predFlag#_1335) {
    } else {
    }
    // begin exhale (update SecMask)
    if (!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#427: int :: (0 <= lk#79#427) && (lk#79#427 < Seq#Length(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#427) < unfoldingHeap#_1377[this, AVLTreeNode.key]));
    }
    if (!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#428: int :: (0 <= rk#80#428) && (rk#80#428 < Seq#Length(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1377[this, AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#428)));
    }
    if (!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(unfoldingHeap#_1377[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1377[this, AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1377[this, AVLTreeNode.key])), ite(unfoldingHeap#_1377[this, AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(unfoldingHeap#_1377[this, AVLTreeNode.keys], unfoldingHeap#_1377[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1377[this, AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1377[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume unfoldingHeap#_1377[this, AVLTreeNode.height] == ite(ite(unfoldingHeap#_1377[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1377[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1377[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1377[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume unfoldingHeap#_1377[this, AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1377[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1377[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume unfoldingHeap#_1377[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume unfoldingHeap#_1377[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume unfoldingHeap#_1377[this, AVLTreeNode.height] > 0;
    unfoldingSecMask#_1379[this, AVLTreeNode.key] := unfoldingSecMask#_1379[this, AVLTreeNode.key][perm$R := unfoldingSecMask#_1379[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (unfoldingSecMask#_1379[this, AVLTreeNode.key][perm$R] < 0) {
      unfoldingSecMask#_1379[this, AVLTreeNode.key] := unfoldingSecMask#_1379[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    unfoldingSecMask#_1379[this, AVLTreeNode.height] := unfoldingSecMask#_1379[this, AVLTreeNode.height][perm$R := unfoldingSecMask#_1379[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (unfoldingSecMask#_1379[this, AVLTreeNode.height][perm$R] < 0) {
      unfoldingSecMask#_1379[this, AVLTreeNode.height] := unfoldingSecMask#_1379[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    unfoldingSecMask#_1379[this, AVLTreeNode.left] := unfoldingSecMask#_1379[this, AVLTreeNode.left][perm$R := unfoldingSecMask#_1379[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (unfoldingSecMask#_1379[this, AVLTreeNode.left][perm$R] < 0) {
      unfoldingSecMask#_1379[this, AVLTreeNode.left] := unfoldingSecMask#_1379[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    unfoldingSecMask#_1379[this, AVLTreeNode.right] := unfoldingSecMask#_1379[this, AVLTreeNode.right][perm$R := unfoldingSecMask#_1379[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (unfoldingSecMask#_1379[this, AVLTreeNode.right][perm$R] < 0) {
      unfoldingSecMask#_1379[this, AVLTreeNode.right] := unfoldingSecMask#_1379[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    unfoldingSecMask#_1379[this, AVLTreeNode.keys] := unfoldingSecMask#_1379[this, AVLTreeNode.keys][perm$R := unfoldingSecMask#_1379[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (unfoldingSecMask#_1379[this, AVLTreeNode.keys][perm$R] < 0) {
      unfoldingSecMask#_1379[this, AVLTreeNode.keys] := unfoldingSecMask#_1379[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    unfoldingSecMask#_1379[this, AVLTreeNode.balanceFactor] := unfoldingSecMask#_1379[this, AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1379[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (unfoldingSecMask#_1379[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      unfoldingSecMask#_1379[this, AVLTreeNode.balanceFactor] := unfoldingSecMask#_1379[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    if (!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) {
      unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
      assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    }
    if (!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) {
      unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
      assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    }
    if (!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) {
      unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
      assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    }
    if (!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) {
      unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
      assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    }
    if (!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) {
      unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
      assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    }
    if (!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) {
      unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
      assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    }
    if (!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) {
      unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
      assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    }
    if (!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) {
      unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1379[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
      assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    }
    assume wf(unfoldingHeap#_1377, unfoldingSecMask#_1379, unfoldingSecMask#_1379);
    // end exhale
  }
  if (!CanRead(unfoldingMask#_1378, unfoldingSecMask#_1379, this, AVLTreeNode.valid)) {
    oldVers#_1402 := unfoldingHeap#_1377[this, AVLTreeNode.valid];
    havoc newVers#_1403;
    unfoldingHeap#_1377[this, AVLTreeNode.valid] := newVers#_1403;
    assume oldVers#_1402 < unfoldingHeap#_1377[this, AVLTreeNode.valid];
  }
  assume IsGoodMask(unfoldingMask#_1378);
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume IsGoodMask(unfoldingMask#_1378);
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  // end exhale
  // inhale (unfolding)
  assume this != null;
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume true;
  assume Fractions(100) > 0;
  unfoldingMask#_1378[this, AVLTreeNode.key] := unfoldingMask#_1378[this, AVLTreeNode.key][perm$R := unfoldingMask#_1378[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(unfoldingMask#_1378);
  assume IsGoodState(heapFragment(unfoldingHeap#_1377[this, AVLTreeNode.key]));
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume this != null;
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume true;
  assume Fractions(50) > 0;
  unfoldingMask#_1378[this, AVLTreeNode.height] := unfoldingMask#_1378[this, AVLTreeNode.height][perm$R := unfoldingMask#_1378[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(unfoldingMask#_1378);
  assume IsGoodState(heapFragment(unfoldingHeap#_1377[this, AVLTreeNode.height]));
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume this != null;
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume (unfoldingHeap#_1377[this, AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1377[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  unfoldingMask#_1378[this, AVLTreeNode.left] := unfoldingMask#_1378[this, AVLTreeNode.left][perm$R := unfoldingMask#_1378[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(unfoldingMask#_1378);
  assume IsGoodState(heapFragment(unfoldingHeap#_1377[this, AVLTreeNode.left]));
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume this != null;
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume (unfoldingHeap#_1377[this, AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1377[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  unfoldingMask#_1378[this, AVLTreeNode.right] := unfoldingMask#_1378[this, AVLTreeNode.right][perm$R := unfoldingMask#_1378[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(unfoldingMask#_1378);
  assume IsGoodState(heapFragment(unfoldingHeap#_1377[this, AVLTreeNode.right]));
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume this != null;
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume true;
  assume Fractions(50) > 0;
  unfoldingMask#_1378[this, AVLTreeNode.keys] := unfoldingMask#_1378[this, AVLTreeNode.keys][perm$R := unfoldingMask#_1378[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(unfoldingMask#_1378);
  assume IsGoodState(heapFragment(unfoldingHeap#_1377[this, AVLTreeNode.keys]));
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume this != null;
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume true;
  assume Fractions(50) > 0;
  unfoldingMask#_1378[this, AVLTreeNode.balanceFactor] := unfoldingMask#_1378[this, AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1378[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(unfoldingMask#_1378);
  assume IsGoodState(heapFragment(unfoldingHeap#_1377[this, AVLTreeNode.balanceFactor]));
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  if (!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1377[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume Fractions(100) > 0;
    unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1378);
    assume IsGoodState(heapFragment(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  }
  if (!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1377[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1378);
    assume IsGoodState(heapFragment(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  }
  if (!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1377[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1378);
    assume IsGoodState(heapFragment(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  }
  if (!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1377[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1378);
    assume IsGoodState(heapFragment(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  }
  if (!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#431: int :: (0 <= lk#79#431) && (lk#79#431 < Seq#Length(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#431) < unfoldingHeap#_1377[this, AVLTreeNode.key]));
  }
  if (!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1377[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume Fractions(100) > 0;
    unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1378);
    assume IsGoodState(heapFragment(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  }
  if (!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1377[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1378);
    assume IsGoodState(heapFragment(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  }
  if (!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1377[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1378);
    assume IsGoodState(heapFragment(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  }
  if (!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1377[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1378[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1378);
    assume IsGoodState(heapFragment(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
    assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  }
  if (!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#432: int :: (0 <= rk#80#432) && (rk#80#432 < Seq#Length(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1377[this, AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#432)));
  }
  if (!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(unfoldingHeap#_1377[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1377[this, AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1377[this, AVLTreeNode.key])), ite(unfoldingHeap#_1377[this, AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(unfoldingHeap#_1377[this, AVLTreeNode.keys], unfoldingHeap#_1377[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1377[this, AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1377[this, AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1377[this, AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1377[this, AVLTreeNode.key])));
  assume unfoldingHeap#_1377[this, AVLTreeNode.height] == ite(ite(unfoldingHeap#_1377[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1377[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1377[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1377[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume unfoldingHeap#_1377[this, AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1377[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1377[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1377[unfoldingHeap#_1377[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume unfoldingHeap#_1377[this, AVLTreeNode.balanceFactor] <= 1;
  assume unfoldingHeap#_1377[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume unfoldingHeap#_1377[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(unfoldingMask#_1378);
  assume wf(unfoldingHeap#_1377, unfoldingMask#_1378, unfoldingSecMask#_1379);
  // end inhale
  if ((false || ((predVer#_1329 == Heap[this, AVLTreeNode.valid]) && (predRec#_1328 == this) && true && predFlag#_1330)) || ((Heap[this, AVLTreeNode.valid] == Heap[this, AVLTreeNode.valid]) && (this == this) && true && predFlag#_1335)) {
    if ((Heap[this, AVLTreeNode.valid] == Heap[this, AVLTreeNode.valid]) && (this == this) && true && predFlag#_1335) {
    } else {
    }
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#433: int :: (0 <= lk#79#433) && (lk#79#433 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#433) < Heap[this, AVLTreeNode.key]));
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#434: int :: (0 <= rk#80#434) && (rk#80#434 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#434)));
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] > 0;
    SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#437: int :: (0 <= lk#79#437) && (lk#79#437 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#437) < Heap[this, AVLTreeNode.key]));
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#438: int :: (0 <= rk#80#438) && (rk#80#438 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#438)));
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assert {:msg "  496.39: Receiver might be null."} true && (bf#49 < 0) ==> (this != null);
  assert {:msg "  496.39: Location might not be readable."} true && (bf#49 < 0) ==> CanRead(unfoldingMask#_1378, unfoldingSecMask#_1379, this, AVLTreeNode.right);
  assume (bf#49 < 0) ==> (!(Heap[this, AVLTreeNode.right] == null));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.getBalanceFactor(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#49: int where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1327: int;
  var unfoldK#_1420: int;
  var oldVers#_1440: int;
  var newVers#_1441: int;
  var lh#51: int where true;
  var rh#53: int where true;
  var foldK#_1445: int;
  var exhaleMask#_1447: MaskType;
  var exhaleHeap#_1446: HeapType;
  var predRec#_1442: ref;
  var predVer#_1443: int;
  var predFlag#_1444: bool;
  var exhaleMask#_1463: MaskType;
  var exhaleHeap#_1462: HeapType;
  assume (0 < methodK#_1327) && ((1000 * methodK#_1327) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_1327 > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + methodK#_1327];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // unfold
  assume #AVLTreeNode.valid#trigger(this);
  assume (0 < unfoldK#_1420) && (unfoldK#_1420 < Fractions(1)) && ((1000 * unfoldK#_1420) < methodK#_1327);
  assert {:msg "  498.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  498.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  498.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[this, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[this, AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[this, AVLTreeNode.valid][perm$N]));
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#439: int :: (0 <= lk#79#439) && (lk#79#439 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#439) < Heap[this, AVLTreeNode.key]));
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#440: int :: (0 <= rk#80#440) && (rk#80#440 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#440)));
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] > 0;
    SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, this, AVLTreeNode.valid)) {
    oldVers#_1440 := Heap[this, AVLTreeNode.valid];
    havoc newVers#_1441;
    Heap[this, AVLTreeNode.valid] := newVers#_1441;
    assume oldVers#_1440 < Heap[this, AVLTreeNode.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#443: int :: (0 <= lk#79#443) && (lk#79#443 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#443) < Heap[this, AVLTreeNode.key]));
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#444: int :: (0 <= rk#80#444) && (rk#80#444 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#444)));
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // local var lh
  // assigment to lh
  assert {:msg "  499.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  499.20: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  499.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  499.38: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  499.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  499.38: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  lh#51 := ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  // local var rh
  // assigment to rh
  assert {:msg "  500.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  500.20: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  500.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  500.38: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  500.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  500.38: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  rh#53 := ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  // assigment to bf
  bf#49 := lh#51 - rh#53;
  // fold
  assume #AVLTreeNode.valid#trigger(this);
  assume (0 < foldK#_1445) && ((1000 * foldK#_1445) < Fractions(1)) && ((1000 * foldK#_1445) < methodK#_1327);
  assert {:msg "  506.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_1447 := Mask;
  havoc exhaleHeap#_1446;
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 129.22 might not evaluate to true."} (forall lk#79#445: int :: (0 <= lk#79#445) && (lk#79#445 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#445) < Heap[this, AVLTreeNode.key]));
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 130.22 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 136.24 might not evaluate to true."} (forall rk#80#446: int :: (0 <= rk#80#446) && (rk#80#446 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#446)));
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 137.23 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 139.6 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 140.6 might not evaluate to true."} Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 141.7 might not evaluate to true."} (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 146.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 147.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 148.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 149.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 150.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] > 0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 117.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 117.6 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_1447[this, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_1447[this, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1447[this, AVLTreeNode.key][perm$N]));
  exhaleMask#_1447[this, AVLTreeNode.key] := exhaleMask#_1447[this, AVLTreeNode.key][perm$R := exhaleMask#_1447[this, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_1447);
  assume wf(Heap, exhaleMask#_1447, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 118.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 118.6 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1447[this, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1447[this, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1447[this, AVLTreeNode.height][perm$N]));
  exhaleMask#_1447[this, AVLTreeNode.height] := exhaleMask#_1447[this, AVLTreeNode.height][perm$R := exhaleMask#_1447[this, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_1447);
  assume wf(Heap, exhaleMask#_1447, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 119.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 119.6 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_1447[this, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_1447[this, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1447[this, AVLTreeNode.left][perm$N]));
  exhaleMask#_1447[this, AVLTreeNode.left] := exhaleMask#_1447[this, AVLTreeNode.left][perm$R := exhaleMask#_1447[this, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_1447);
  assume wf(Heap, exhaleMask#_1447, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 120.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 120.6 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_1447[this, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_1447[this, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1447[this, AVLTreeNode.right][perm$N]));
  exhaleMask#_1447[this, AVLTreeNode.right] := exhaleMask#_1447[this, AVLTreeNode.right][perm$R := exhaleMask#_1447[this, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_1447);
  assume wf(Heap, exhaleMask#_1447, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 122.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 122.6 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1447[this, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1447[this, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1447[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1447[this, AVLTreeNode.keys] := exhaleMask#_1447[this, AVLTreeNode.keys][perm$R := exhaleMask#_1447[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_1447);
  assume wf(Heap, exhaleMask#_1447, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 123.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 123.6 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1447[this, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1447[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1447[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1447[this, AVLTreeNode.balanceFactor] := exhaleMask#_1447[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1447[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_1447);
  assume wf(Heap, exhaleMask#_1447, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 125.22 might not be positive."} Fractions(100) > 0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 125.22 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    if (!CanRead(exhaleMask#_1447, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1446[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1447);
    assume wf(Heap, exhaleMask#_1447, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 126.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 126.22 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1447);
    assume wf(Heap, exhaleMask#_1447, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 127.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 127.22 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1447);
    assume wf(Heap, exhaleMask#_1447, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 128.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 128.22 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1447[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1447);
    assume wf(Heap, exhaleMask#_1447, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 132.23 might not be positive."} Fractions(100) > 0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 132.23 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    if (!CanRead(exhaleMask#_1447, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1446[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1447);
    assume wf(Heap, exhaleMask#_1447, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 133.23 might not be positive."} Fractions(50) > 0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 133.23 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1447);
    assume wf(Heap, exhaleMask#_1447, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 134.23 might not be positive."} Fractions(50) > 0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 134.23 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1447);
    assume wf(Heap, exhaleMask#_1447, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 135.23 might not be positive."} Fractions(50) > 0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 135.23 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1447[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1447);
    assume wf(Heap, exhaleMask#_1447, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_1447;
  assume IsGoodExhaleState(exhaleHeap#_1446, Heap, Mask, SecMask);
  Heap := exhaleHeap#_1446;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  predRec#_1442 := this;
  predVer#_1443 := Heap[this, AVLTreeNode.valid];
  predFlag#_1444 := true;
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_1463 := Mask;
  havoc exhaleHeap#_1462;
  assert {:msg "  487.2: The postcondition at 493.11 might not hold. The expression at 493.11 might not evaluate to true."} bf#49 == Heap[this, AVLTreeNode.balanceFactor];
  assert {:msg "  487.2: The postcondition at 495.11 might not hold. The expression at 495.11 might not evaluate to true."} (bf#49 > 0) ==> (!(Heap[this, AVLTreeNode.left] == null));
  assert {:msg "  487.2: The postcondition at 496.11 might not hold. The expression at 496.11 might not evaluate to true."} (bf#49 < 0) ==> (!(Heap[this, AVLTreeNode.right] == null));
  assert {:msg "  487.2: The postcondition at 491.11 might not hold. The permission at 491.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  487.2: The postcondition at 491.11 might not hold. Insufficient fraction at 491.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1463[this, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1463[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1463[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1463[this, AVLTreeNode.valid] := exhaleMask#_1463[this, AVLTreeNode.valid][perm$R := exhaleMask#_1463[this, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_1443 == Heap[this, AVLTreeNode.valid]) && (predRec#_1442 == this) && true && predFlag#_1444)) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#449: int :: (0 <= lk#79#449) && (lk#79#449 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#449) < Heap[this, AVLTreeNode.key]));
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#450: int :: (0 <= rk#80#450) && (rk#80#450 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#450)));
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] > 0;
    SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(exhaleMask#_1463, SecMask, this, AVLTreeNode.valid)) {
    assume Heap[this, AVLTreeNode.valid] < exhaleHeap#_1462[this, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_1463);
  assume wf(Heap, exhaleMask#_1463, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  487.2: The postcondition at 492.11 might not hold. The permission at 492.11 might not be positive."} methodK#_1327 > 0;
  assert {:msg "  487.2: The postcondition at 492.11 might not hold. Insufficient fraction at 492.11 for AVLTreeNode.balanceFactor."} (methodK#_1327 <= exhaleMask#_1463[this, AVLTreeNode.balanceFactor][perm$R]) && ((methodK#_1327 == exhaleMask#_1463[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1463[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1463[this, AVLTreeNode.balanceFactor] := exhaleMask#_1463[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1463[this, AVLTreeNode.balanceFactor][perm$R] - methodK#_1327];
  assume IsGoodMask(exhaleMask#_1463);
  assume wf(Heap, exhaleMask#_1463, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1463;
  assume IsGoodExhaleState(exhaleHeap#_1462, Heap, Mask, SecMask);
  Heap := exhaleHeap#_1462;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  487.2: Method might lock/unlock more than allowed."} (forall lk#_1482: ref :: {Heap[lk#_1482, held]} {Heap[lk#_1482, rdheld]} (((0 < Heap[lk#_1482, held]) == (0 < old(Heap)[lk#_1482, held])) && (Heap[lk#_1482, rdheld] == old(Heap)[lk#_1482, rdheld])) || false);
  assert {:msg "  487.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.getBalanceFactorI$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#54: int where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1483: int;
  assume (0 < methodK#_1483) && ((1000 * methodK#_1483) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume methodK#_1483 > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + methodK#_1483];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  512.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  512.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  512.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  512.27: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  512.27: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  512.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  512.27: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  513.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  513.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  513.30: Receiver might be null."} true ==> (this != null);
    assert {:msg "  513.30: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodK#_1483 > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodK#_1483];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume methodK#_1483 > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + methodK#_1483];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  516.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  516.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  516.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  516.28: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  516.28: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  516.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  516.28: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  517.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  517.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  517.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  517.31: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodK#_1483 > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodK#_1483];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume methodK#_1483 > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + methodK#_1483];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  520.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  520.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  520.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  520.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  520.26: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  520.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  520.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  521.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  521.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  521.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  521.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodK#_1483 > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodK#_1483];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume methodK#_1483 > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + methodK#_1483];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  524.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  524.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  524.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  524.27: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  524.27: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  524.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  524.27: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  525.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  525.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  525.30: Receiver might be null."} true ==> (this != null);
    assert {:msg "  525.30: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodK#_1483 > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodK#_1483];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  527.18: Receiver might be null."} true ==> (this != null);
  assert {:msg "  527.18: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  527.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  527.31: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  527.31: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  527.31: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  527.45: Receiver might be null."} true ==> (this != null);
  assert {:msg "  527.45: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  527.59: Receiver might be null."} true ==> (this != null);
    assert {:msg "  527.59: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  527.59: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  527.59: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume bf#54 == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  if (bf#54 > 0) {
    assert {:msg "  528.20: Receiver might be null."} true ==> (this != null);
    assert {:msg "  528.20: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume !(Heap[this, AVLTreeNode.left] == null);
  }
  if (bf#54 < 0) {
    assert {:msg "  529.20: Receiver might be null."} true ==> (this != null);
    assert {:msg "  529.20: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume !(Heap[this, AVLTreeNode.right] == null);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.getBalanceFactorI(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#54: int where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1483: int;
  var lh#56: int where true;
  var rh#58: int where true;
  var assertHeap#_1484: HeapType;
  var assertMask#_1485: MaskType;
  var assertSecMask#_1486: MaskType;
  var assertCredits#_1487: CreditsType;
  var exhaleMask#_1489: MaskType;
  var exhaleHeap#_1488: HeapType;
  var unfoldingK#_1495: int;
  var predFlag#_1494: bool;
  var unfoldingHeap#_1490: HeapType;
  var unfoldingMask#_1491: MaskType;
  var unfoldingSecMask#_1492: MaskType;
  var unfoldingCredits#_1493: CreditsType;
  var oldVers#_1515: int;
  var newVers#_1516: int;
  var assertHeap#_1533: HeapType;
  var assertMask#_1534: MaskType;
  var assertSecMask#_1535: MaskType;
  var assertCredits#_1536: CreditsType;
  var exhaleMask#_1538: MaskType;
  var exhaleHeap#_1537: HeapType;
  var unfoldingK#_1544: int;
  var predFlag#_1543: bool;
  var unfoldingHeap#_1539: HeapType;
  var unfoldingMask#_1540: MaskType;
  var unfoldingSecMask#_1541: MaskType;
  var unfoldingCredits#_1542: CreditsType;
  var oldVers#_1564: int;
  var newVers#_1565: int;
  var assertHeap#_1582: HeapType;
  var assertMask#_1583: MaskType;
  var assertSecMask#_1584: MaskType;
  var assertCredits#_1585: CreditsType;
  var exhaleMask#_1587: MaskType;
  var exhaleHeap#_1586: HeapType;
  var assertHeap#_1588: HeapType;
  var assertMask#_1589: MaskType;
  var assertSecMask#_1590: MaskType;
  var assertCredits#_1591: CreditsType;
  var exhaleMask#_1593: MaskType;
  var exhaleHeap#_1592: HeapType;
  var exhaleMask#_1595: MaskType;
  var exhaleHeap#_1594: HeapType;
  assume (0 < methodK#_1483) && ((1000 * methodK#_1483) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume methodK#_1483 > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + methodK#_1483];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodK#_1483 > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodK#_1483];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume methodK#_1483 > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + methodK#_1483];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodK#_1483 > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodK#_1483];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // local var lh
  // assigment to lh
  assert {:msg "  531.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  531.20: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  531.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  531.38: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  531.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  531.38: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  lh#56 := ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  // local var rh
  // assigment to rh
  assert {:msg "  532.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  532.20: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  532.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  532.38: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  532.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  532.38: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  rh#58 := ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  // assigment to bf
  bf#54 := lh#56 - rh#58;
  // assert
  assertHeap#_1484 := Heap;
  assertMask#_1485 := Mask;
  assertSecMask#_1486 := SecMask;
  assertCredits#_1487 := Credits;
  assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
  // begin exhale (assert)
  exhaleMask#_1489 := assertMask#_1485;
  havoc exhaleHeap#_1488;
  assert {:msg "  534.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  534.10: Location might not be readable."} true ==> CanRead(assertMask#_1485, assertSecMask#_1486, this, AVLTreeNode.right);
  if (!(assertHeap#_1484[this, AVLTreeNode.right] == null)) {
    // unfolding
    assume (0 < unfoldingK#_1495) && ((1000 * unfoldingK#_1495) < Fractions(1));
    predFlag#_1494 := true;
    assert {:msg "  534.36: Receiver might be null."} true ==> (this != null);
    assert {:msg "  534.36: Location might not be readable."} true ==> CanRead(assertMask#_1485, assertSecMask#_1486, this, AVLTreeNode.right);
    assert {:msg "  534.36: Receiver might be null."} true ==> (assertHeap#_1484[this, AVLTreeNode.right] != null);
    unfoldingHeap#_1490 := assertHeap#_1484;
    unfoldingMask#_1491 := assertMask#_1485;
    unfoldingSecMask#_1492 := assertSecMask#_1486;
    unfoldingCredits#_1493 := assertCredits#_1487;
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    // begin exhale (unfolding)
    assert {:msg "  534.26: Unfolding might fail. The permission at 534.36 might not be positive."} Fractions(100) > 0;
    assert {:msg "  534.26: Unfolding might fail. Insufficient fraction at 534.36 for AVLTreeNode.valid."} (Fractions(100) <= unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false) {
      // begin exhale (update SecMask)
      if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#453: int :: (0 <= lk#79#453) && (lk#79#453 < Seq#Length(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#453) < unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#454: int :: (0 <= rk#80#454) && (rk#80#454 < Seq#Length(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#454)));
      }
      if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
      unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1492[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
        assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      }
      if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
        assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      }
      if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
        assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      }
      if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
        assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      }
      if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
        assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      }
      if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
        assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      }
      if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
        assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      }
      if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1492[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
        assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      }
      assume wf(unfoldingHeap#_1490, unfoldingSecMask#_1492, unfoldingSecMask#_1492);
      // end exhale
    }
    if (!CanRead(unfoldingMask#_1491, unfoldingSecMask#_1492, unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.valid)) {
      oldVers#_1515 := unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.valid];
      havoc newVers#_1516;
      unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_1516;
      assume oldVers#_1515 < unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(unfoldingMask#_1491);
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume IsGoodMask(unfoldingMask#_1491);
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    // end exhale
    // inhale (unfolding)
    assume unfoldingHeap#_1490[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume true;
    assume Fractions(100) > 0;
    unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1491);
    assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key]));
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume unfoldingHeap#_1490[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1491);
    assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume unfoldingHeap#_1490[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume (unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1491);
    assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left]));
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume unfoldingHeap#_1490[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume (unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1491);
    assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right]));
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume unfoldingHeap#_1490[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1491);
    assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume unfoldingHeap#_1490[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1491);
    assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume Fractions(100) > 0;
      unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(unfoldingMask#_1491);
      assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    }
    if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1491);
      assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    }
    if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1491);
      assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]));
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    }
    if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1491);
      assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    }
    if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume (forall lk#79#457: int :: (0 <= lk#79#457) && (lk#79#457 < Seq#Length(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#457) < unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key]));
    }
    if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume Fractions(100) > 0;
      unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(unfoldingMask#_1491);
      assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    }
    if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1491);
      assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    }
    if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1491);
      assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]));
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    }
    if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1491[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1491);
      assume IsGoodState(heapFragment(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
      assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    }
    if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume (forall rk#80#458: int :: (0 <= rk#80#458) && (rk#80#458 < Seq#Length(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#458)));
    }
    if (!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key]);
    assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.key])));
    assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1490[unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume unfoldingHeap#_1490[unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    assume IsGoodMask(unfoldingMask#_1491);
    assume wf(unfoldingHeap#_1490, unfoldingMask#_1491, unfoldingSecMask#_1492);
    // end inhale
    if (false) {
      // begin exhale (update SecMask)
      if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#459: int :: (0 <= lk#79#459) && (lk#79#459 < Seq#Length(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#459) < assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#460: int :: (0 <= rk#80#460) && (rk#80#460 < Seq#Length(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#460)));
      }
      if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key])), ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys], assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
      assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
        assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      }
      if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
        assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      }
      if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
        assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      }
      if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
        assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      }
      if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
        assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      }
      if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
        assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      }
      if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
        assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      }
      if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
        assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      }
      assume wf(assertHeap#_1484, assertSecMask#_1486, assertSecMask#_1486);
      // end exhale
    }
    assume assertHeap#_1484[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume true;
    assume Fractions(100) > 0;
    assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1485);
    assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key]));
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume assertHeap#_1484[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1485);
    assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume assertHeap#_1484[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume (assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1485);
    assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left]));
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume assertHeap#_1484[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume (assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1485);
    assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right]));
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume assertHeap#_1484[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1485);
    assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume assertHeap#_1484[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1486[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1485);
    assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume Fractions(100) > 0;
      assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(assertMask#_1485);
      assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    }
    if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1485);
      assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    }
    if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1485);
      assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]));
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    }
    if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1485);
      assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    }
    if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume (forall lk#79#463: int :: (0 <= lk#79#463) && (lk#79#463 < Seq#Length(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#463) < assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key]));
    }
    if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume Fractions(100) > 0;
      assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(assertMask#_1485);
      assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    }
    if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1485);
      assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    }
    if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1485);
      assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]));
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    }
    if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1486[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1485);
      assume IsGoodState(heapFragment(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
      assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
    }
    if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume (forall rk#80#464: int :: (0 <= rk#80#464) && (rk#80#464 < Seq#Length(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#464)));
    }
    if (!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key])), ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys], assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key]);
    assume (forall kk#81: int :: Seq#Contains(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.key])));
    assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_1484[assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    assert {:msg "  534.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  534.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1491, unfoldingSecMask#_1492, this, AVLTreeNode.right);
    assert {:msg "  534.51: Receiver might be null."} true ==> (unfoldingHeap#_1490[this, AVLTreeNode.right] != null);
    assert {:msg "  534.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1491, unfoldingSecMask#_1492, unfoldingHeap#_1490[this, AVLTreeNode.right], AVLTreeNode.height);
    assert {:msg "  534.3: Assertion might not hold. The expression at 534.26 might not evaluate to true."} assertHeap#_1484[assertHeap#_1484[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assertMask#_1485 := exhaleMask#_1489;
  assume IsGoodExhaleState(exhaleHeap#_1488, assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
  assertHeap#_1484 := exhaleHeap#_1488;
  assume IsGoodMask(assertMask#_1485);
  assume wf(assertHeap#_1484, assertMask#_1485, assertSecMask#_1486);
  // end exhale
  // assert
  assertHeap#_1533 := Heap;
  assertMask#_1534 := Mask;
  assertSecMask#_1535 := SecMask;
  assertCredits#_1536 := Credits;
  assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
  // begin exhale (assert)
  exhaleMask#_1538 := assertMask#_1534;
  havoc exhaleHeap#_1537;
  assert {:msg "  535.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  535.10: Location might not be readable."} true ==> CanRead(assertMask#_1534, assertSecMask#_1535, this, AVLTreeNode.left);
  if (!(assertHeap#_1533[this, AVLTreeNode.left] == null)) {
    // unfolding
    assume (0 < unfoldingK#_1544) && ((1000 * unfoldingK#_1544) < Fractions(1));
    predFlag#_1543 := true;
    assert {:msg "  535.36: Receiver might be null."} true ==> (this != null);
    assert {:msg "  535.36: Location might not be readable."} true ==> CanRead(assertMask#_1534, assertSecMask#_1535, this, AVLTreeNode.left);
    assert {:msg "  535.36: Receiver might be null."} true ==> (assertHeap#_1533[this, AVLTreeNode.left] != null);
    unfoldingHeap#_1539 := assertHeap#_1533;
    unfoldingMask#_1540 := assertMask#_1534;
    unfoldingSecMask#_1541 := assertSecMask#_1535;
    unfoldingCredits#_1542 := assertCredits#_1536;
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    // begin exhale (unfolding)
    assert {:msg "  535.26: Unfolding might fail. The permission at 535.36 might not be positive."} Fractions(100) > 0;
    assert {:msg "  535.26: Unfolding might fail. Insufficient fraction at 535.36 for AVLTreeNode.valid."} (Fractions(100) <= unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false) {
      // begin exhale (update SecMask)
      if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#465: int :: (0 <= lk#79#465) && (lk#79#465 < Seq#Length(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#465) < unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#466: int :: (0 <= rk#80#466) && (rk#80#466 < Seq#Length(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#466)));
      }
      if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
      unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1541[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
        assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      }
      if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
        assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      }
      if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
        assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      }
      if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
        assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      }
      if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
        assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      }
      if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
        assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      }
      if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
        assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      }
      if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1541[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
        assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      }
      assume wf(unfoldingHeap#_1539, unfoldingSecMask#_1541, unfoldingSecMask#_1541);
      // end exhale
    }
    if (!CanRead(unfoldingMask#_1540, unfoldingSecMask#_1541, unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.valid)) {
      oldVers#_1564 := unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.valid];
      havoc newVers#_1565;
      unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_1565;
      assume oldVers#_1564 < unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(unfoldingMask#_1540);
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume IsGoodMask(unfoldingMask#_1540);
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    // end exhale
    // inhale (unfolding)
    assume unfoldingHeap#_1539[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume true;
    assume Fractions(100) > 0;
    unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1540);
    assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key]));
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume unfoldingHeap#_1539[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1540);
    assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume unfoldingHeap#_1539[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume (unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1540);
    assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left]));
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume unfoldingHeap#_1539[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume (unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1540);
    assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right]));
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume unfoldingHeap#_1539[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1540);
    assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume unfoldingHeap#_1539[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1540);
    assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume Fractions(100) > 0;
      unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(unfoldingMask#_1540);
      assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    }
    if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1540);
      assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    }
    if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1540);
      assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]));
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    }
    if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1540);
      assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    }
    if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume (forall lk#79#469: int :: (0 <= lk#79#469) && (lk#79#469 < Seq#Length(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#469) < unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key]));
    }
    if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume Fractions(100) > 0;
      unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(unfoldingMask#_1540);
      assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    }
    if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1540);
      assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    }
    if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1540);
      assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]));
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    }
    if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1540[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1540);
      assume IsGoodState(heapFragment(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
      assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    }
    if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume (forall rk#80#470: int :: (0 <= rk#80#470) && (rk#80#470 < Seq#Length(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#470)));
    }
    if (!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key]);
    assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.key])));
    assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1539[unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume unfoldingHeap#_1539[unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    assume IsGoodMask(unfoldingMask#_1540);
    assume wf(unfoldingHeap#_1539, unfoldingMask#_1540, unfoldingSecMask#_1541);
    // end inhale
    if (false) {
      // begin exhale (update SecMask)
      if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#471: int :: (0 <= lk#79#471) && (lk#79#471 < Seq#Length(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#471) < assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#472: int :: (0 <= rk#80#472) && (rk#80#472 < Seq#Length(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#472)));
      }
      if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key])), ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys], assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
      assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
        assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      }
      if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
        assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      }
      if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
        assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      }
      if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
        assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      }
      if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
        assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      }
      if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
        assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      }
      if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
        assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      }
      if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
        assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      }
      assume wf(assertHeap#_1533, assertSecMask#_1535, assertSecMask#_1535);
      // end exhale
    }
    assume assertHeap#_1533[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume true;
    assume Fractions(100) > 0;
    assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1534);
    assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key]));
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume assertHeap#_1533[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1534);
    assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume assertHeap#_1533[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume (assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1534);
    assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left]));
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume assertHeap#_1533[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume (assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1534);
    assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right]));
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume assertHeap#_1533[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1534);
    assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume assertHeap#_1533[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1535[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1534);
    assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume Fractions(100) > 0;
      assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(assertMask#_1534);
      assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    }
    if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1534);
      assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    }
    if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1534);
      assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]));
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    }
    if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1534);
      assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    }
    if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume (forall lk#79#475: int :: (0 <= lk#79#475) && (lk#79#475 < Seq#Length(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#475) < assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key]));
    }
    if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume Fractions(100) > 0;
      assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(assertMask#_1534);
      assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    }
    if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1534);
      assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    }
    if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1534);
      assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]));
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    }
    if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1535[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1534);
      assume IsGoodState(heapFragment(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
      assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
    }
    if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume (forall rk#80#476: int :: (0 <= rk#80#476) && (rk#80#476 < Seq#Length(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#476)));
    }
    if (!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key])), ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys], assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key]);
    assume (forall kk#81: int :: Seq#Contains(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.key])));
    assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1533[assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    assert {:msg "  535.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  535.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1540, unfoldingSecMask#_1541, this, AVLTreeNode.left);
    assert {:msg "  535.51: Receiver might be null."} true ==> (unfoldingHeap#_1539[this, AVLTreeNode.left] != null);
    assert {:msg "  535.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1540, unfoldingSecMask#_1541, unfoldingHeap#_1539[this, AVLTreeNode.left], AVLTreeNode.height);
    assert {:msg "  535.3: Assertion might not hold. The expression at 535.26 might not evaluate to true."} assertHeap#_1533[assertHeap#_1533[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  assertMask#_1534 := exhaleMask#_1538;
  assume IsGoodExhaleState(exhaleHeap#_1537, assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
  assertHeap#_1533 := exhaleHeap#_1537;
  assume IsGoodMask(assertMask#_1534);
  assume wf(assertHeap#_1533, assertMask#_1534, assertSecMask#_1535);
  // end exhale
  // assert
  assertHeap#_1582 := Heap;
  assertMask#_1583 := Mask;
  assertSecMask#_1584 := SecMask;
  assertCredits#_1585 := Credits;
  assume wf(assertHeap#_1582, assertMask#_1583, assertSecMask#_1584);
  // begin exhale (assert)
  exhaleMask#_1587 := assertMask#_1583;
  havoc exhaleHeap#_1586;
  assert {:msg "  536.3: Assertion might not hold. The expression at 536.10 might not evaluate to true."} lh#56 >= 0;
  assertMask#_1583 := exhaleMask#_1587;
  assume IsGoodExhaleState(exhaleHeap#_1586, assertHeap#_1582, assertMask#_1583, assertSecMask#_1584);
  assertHeap#_1582 := exhaleHeap#_1586;
  assume IsGoodMask(assertMask#_1583);
  assume wf(assertHeap#_1582, assertMask#_1583, assertSecMask#_1584);
  // end exhale
  // assert
  assertHeap#_1588 := Heap;
  assertMask#_1589 := Mask;
  assertSecMask#_1590 := SecMask;
  assertCredits#_1591 := Credits;
  assume wf(assertHeap#_1588, assertMask#_1589, assertSecMask#_1590);
  // begin exhale (assert)
  exhaleMask#_1593 := assertMask#_1589;
  havoc exhaleHeap#_1592;
  assert {:msg "  537.3: Assertion might not hold. The expression at 537.10 might not evaluate to true."} rh#58 >= 0;
  assertMask#_1589 := exhaleMask#_1593;
  assume IsGoodExhaleState(exhaleHeap#_1592, assertHeap#_1588, assertMask#_1589, assertSecMask#_1590);
  assertHeap#_1588 := exhaleHeap#_1592;
  assume IsGoodMask(assertMask#_1589);
  assume wf(assertHeap#_1588, assertMask#_1589, assertSecMask#_1590);
  // end exhale
  // begin exhale (postcondition)
  exhaleMask#_1595 := Mask;
  havoc exhaleHeap#_1594;
  assert {:msg "  510.2: The postcondition at 527.11 might not hold. The expression at 527.11 might not evaluate to true."} bf#54 == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  if (bf#54 > 0) {
    assert {:msg "  510.2: The postcondition at 528.11 might not hold. The expression at 528.20 might not evaluate to true."} !(Heap[this, AVLTreeNode.left] == null);
  }
  if (bf#54 < 0) {
    assert {:msg "  510.2: The postcondition at 529.11 might not hold. The expression at 529.20 might not evaluate to true."} !(Heap[this, AVLTreeNode.right] == null);
  }
  assert {:msg "  510.2: The postcondition at 519.11 might not hold. The permission at 519.11 might not be positive."} methodK#_1483 > 0;
  assert {:msg "  510.2: The postcondition at 519.11 might not hold. Insufficient fraction at 519.11 for AVLTreeNode.left."} (methodK#_1483 <= exhaleMask#_1595[this, AVLTreeNode.left][perm$R]) && ((methodK#_1483 == exhaleMask#_1595[this, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1595[this, AVLTreeNode.left][perm$N]));
  exhaleMask#_1595[this, AVLTreeNode.left] := exhaleMask#_1595[this, AVLTreeNode.left][perm$R := exhaleMask#_1595[this, AVLTreeNode.left][perm$R] - methodK#_1483];
  assume IsGoodMask(exhaleMask#_1595);
  assume wf(Heap, exhaleMask#_1595, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  510.2: The postcondition at 520.11 might not hold. The permission at 520.26 might not be positive."} Fractions(100) > 0;
    assert {:msg "  510.2: The postcondition at 520.11 might not hold. Insufficient fraction at 520.26 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1595[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1595[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1595[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1595[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1595[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1595[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_1595, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1594[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1595);
    assume wf(Heap, exhaleMask#_1595, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  510.2: The postcondition at 521.11 might not hold. The permission at 521.26 might not be positive."} methodK#_1483 > 0;
    assert {:msg "  510.2: The postcondition at 521.11 might not hold. Insufficient fraction at 521.26 for AVLTreeNode.height."} (methodK#_1483 <= exhaleMask#_1595[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((methodK#_1483 == exhaleMask#_1595[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1595[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1595[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1595[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1595[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodK#_1483];
    assume IsGoodMask(exhaleMask#_1595);
    assume wf(Heap, exhaleMask#_1595, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  510.2: The postcondition at 523.11 might not hold. The permission at 523.11 might not be positive."} methodK#_1483 > 0;
  assert {:msg "  510.2: The postcondition at 523.11 might not hold. Insufficient fraction at 523.11 for AVLTreeNode.right."} (methodK#_1483 <= exhaleMask#_1595[this, AVLTreeNode.right][perm$R]) && ((methodK#_1483 == exhaleMask#_1595[this, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1595[this, AVLTreeNode.right][perm$N]));
  exhaleMask#_1595[this, AVLTreeNode.right] := exhaleMask#_1595[this, AVLTreeNode.right][perm$R := exhaleMask#_1595[this, AVLTreeNode.right][perm$R] - methodK#_1483];
  assume IsGoodMask(exhaleMask#_1595);
  assume wf(Heap, exhaleMask#_1595, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  510.2: The postcondition at 524.11 might not hold. The permission at 524.27 might not be positive."} Fractions(100) > 0;
    assert {:msg "  510.2: The postcondition at 524.11 might not hold. Insufficient fraction at 524.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1595[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1595[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1595[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1595[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1595[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1595[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_1595, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1594[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1595);
    assume wf(Heap, exhaleMask#_1595, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  510.2: The postcondition at 525.11 might not hold. The permission at 525.27 might not be positive."} methodK#_1483 > 0;
    assert {:msg "  510.2: The postcondition at 525.11 might not hold. Insufficient fraction at 525.27 for AVLTreeNode.height."} (methodK#_1483 <= exhaleMask#_1595[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((methodK#_1483 == exhaleMask#_1595[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1595[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1595[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1595[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1595[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodK#_1483];
    assume IsGoodMask(exhaleMask#_1595);
    assume wf(Heap, exhaleMask#_1595, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_1595;
  assume IsGoodExhaleState(exhaleHeap#_1594, Heap, Mask, SecMask);
  Heap := exhaleHeap#_1594;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  510.2: Method might lock/unlock more than allowed."} (forall lk#_1602: ref :: {Heap[lk#_1602, held]} {Heap[lk#_1602, rdheld]} (((0 < Heap[lk#_1602, held]) == (0 < old(Heap)[lk#_1602, held])) && (Heap[lk#_1602, rdheld] == old(Heap)[lk#_1602, rdheld])) || false);
  assert {:msg "  510.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.close$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1603: int;
  var k#92#478: int where true;
  var k#93#480: int where true;
  assume (0 < methodK#_1603) && ((1000 * methodK#_1603) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  552.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  552.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  552.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  552.27: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  552.27: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  552.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  552.27: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  553.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  553.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  553.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  553.31: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  554.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  554.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  554.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  554.31: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  555.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  555.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  555.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  555.31: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  556.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  556.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  556.12: Receiver might be null."} true && (0 <= k#92#478) ==> (this != null);
    assert {:msg "  556.12: Location might not be readable."} true && (0 <= k#92#478) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  556.12: Receiver might be null."} true && (0 <= k#92#478) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  556.12: Location might not be readable."} true && (0 <= k#92#478) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  556.12: Receiver might be null."} true && (0 <= k#92#478) && (k#92#478 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  556.12: Location might not be readable."} true && (0 <= k#92#478) && (k#92#478 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  556.12: Receiver might be null."} true && (0 <= k#92#478) && (k#92#478 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  556.12: Location might not be readable."} true && (0 <= k#92#478) && (k#92#478 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  556.52: Sequence index might be negative."} true && (0 <= k#92#478) && (k#92#478 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#92#478);
    assert {:msg "  556.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#92#478) && (k#92#478 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#92#478 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  556.56: Receiver might be null."} true && (0 <= k#92#478) && (k#92#478 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  556.56: Location might not be readable."} true && (0 <= k#92#478) && (k#92#478 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    assume (forall k#92#477: int :: (0 <= k#92#477) && (k#92#477 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#92#477) < Heap[this, AVLTreeNode.key]));
  }
  assert {:msg "  558.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  558.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  558.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  558.28: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  558.28: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  558.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  558.28: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  559.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  559.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  559.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  559.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  560.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  560.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  560.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  560.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  561.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  561.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  561.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  561.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  562.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  562.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  562.12: Receiver might be null."} true && (0 <= k#93#480) ==> (this != null);
    assert {:msg "  562.12: Location might not be readable."} true && (0 <= k#93#480) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  562.12: Receiver might be null."} true && (0 <= k#93#480) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  562.12: Location might not be readable."} true && (0 <= k#93#480) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  562.54: Receiver might be null."} true && (0 <= k#93#480) && (k#93#480 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  562.54: Location might not be readable."} true && (0 <= k#93#480) && (k#93#480 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    assert {:msg "  562.12: Receiver might be null."} true && (0 <= k#93#480) && (k#93#480 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  562.12: Location might not be readable."} true && (0 <= k#93#480) && (k#93#480 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  562.12: Receiver might be null."} true && (0 <= k#93#480) && (k#93#480 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  562.12: Location might not be readable."} true && (0 <= k#93#480) && (k#93#480 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  562.60: Sequence index might be negative."} true && (0 <= k#93#480) && (k#93#480 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#93#480);
    assert {:msg "  562.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#93#480) && (k#93#480 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#93#480 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall k#93#479: int :: (0 <= k#93#479) && (k#93#479 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#93#479)));
  }
  assert {:msg "  564.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  564.14: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  564.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  564.31: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  564.31: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  564.31: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  564.47: Receiver might be null."} true ==> (this != null);
  assert {:msg "  564.47: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  564.65: Receiver might be null."} true ==> (this != null);
    assert {:msg "  564.65: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  564.65: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  564.65: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  565.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  565.14: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  565.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  565.31: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  565.31: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  565.31: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  565.47: Receiver might be null."} true ==> (this != null);
  assert {:msg "  565.47: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  565.65: Receiver might be null."} true ==> (this != null);
    assert {:msg "  565.65: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  565.65: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  565.65: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  567.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  572.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  572.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.keys);
  assert {:msg "  573.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  573.10: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  573.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  573.39: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
    assert {:msg "  573.39: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  573.39: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  573.60: Receiver might be null."} true ==> (this != null);
  assert {:msg "  573.60: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.key);
  assert {:msg "  573.75: Receiver might be null."} true ==> (this != null);
  assert {:msg "  573.75: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  573.105: Receiver might be null."} true ==> (this != null);
    assert {:msg "  573.105: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
    assert {:msg "  573.105: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  573.105: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  575.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  575.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.height);
  assert {:msg "  576.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  576.12: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  576.34: Receiver might be null."} true ==> (this != null);
    assert {:msg "  576.34: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
    assert {:msg "  576.34: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  576.34: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  576.55: Receiver might be null."} true ==> (this != null);
  assert {:msg "  576.55: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  576.78: Receiver might be null."} true ==> (this != null);
    assert {:msg "  576.78: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
    assert {:msg "  576.78: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  576.78: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  if (ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) {
    assert {:msg "  578.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  578.12: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
    if (old(Heap)[this, AVLTreeNode.left] == null) {
    } else {
      assert {:msg "  578.34: Receiver might be null."} true ==> (this != null);
      assert {:msg "  578.34: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
      assert {:msg "  578.34: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
      assert {:msg "  578.34: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
    }
  } else {
    assert {:msg "  580.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  580.12: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
    if (old(Heap)[this, AVLTreeNode.right] == null) {
    } else {
      assert {:msg "  580.35: Receiver might be null."} true ==> (this != null);
      assert {:msg "  580.35: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
      assert {:msg "  580.35: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
      assert {:msg "  580.35: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
    }
  }
  assume Heap[this, AVLTreeNode.height] == ite(ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]), ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  582.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  582.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.balanceFactor);
  assert {:msg "  583.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  583.10: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  583.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  583.32: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
    assert {:msg "  583.32: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  583.32: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  583.53: Receiver might be null."} true ==> (this != null);
  assert {:msg "  583.53: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  583.76: Receiver might be null."} true ==> (this != null);
    assert {:msg "  583.76: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
    assert {:msg "  583.76: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  583.76: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.close(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1603: int;
  var lh#60: int where true;
  var rh#62: int where true;
  var assertHeap#_1604: HeapType;
  var assertMask#_1605: MaskType;
  var assertSecMask#_1606: MaskType;
  var assertCredits#_1607: CreditsType;
  var exhaleMask#_1609: MaskType;
  var exhaleHeap#_1608: HeapType;
  var unfoldingK#_1615: int;
  var predFlag#_1614: bool;
  var unfoldingHeap#_1610: HeapType;
  var unfoldingMask#_1611: MaskType;
  var unfoldingSecMask#_1612: MaskType;
  var unfoldingCredits#_1613: CreditsType;
  var oldVers#_1635: int;
  var newVers#_1636: int;
  var assertHeap#_1653: HeapType;
  var assertMask#_1654: MaskType;
  var assertSecMask#_1655: MaskType;
  var assertCredits#_1656: CreditsType;
  var exhaleMask#_1658: MaskType;
  var exhaleHeap#_1657: HeapType;
  var unfoldingK#_1664: int;
  var predFlag#_1663: bool;
  var unfoldingHeap#_1659: HeapType;
  var unfoldingMask#_1660: MaskType;
  var unfoldingSecMask#_1661: MaskType;
  var unfoldingCredits#_1662: CreditsType;
  var oldVers#_1684: int;
  var newVers#_1685: int;
  var assertHeap#_1702: HeapType;
  var assertMask#_1703: MaskType;
  var assertSecMask#_1704: MaskType;
  var assertCredits#_1705: CreditsType;
  var exhaleMask#_1707: MaskType;
  var exhaleHeap#_1706: HeapType;
  var foldK#_1711: int;
  var exhaleMask#_1713: MaskType;
  var exhaleHeap#_1712: HeapType;
  var predRec#_1708: ref;
  var predVer#_1709: int;
  var predFlag#_1710: bool;
  var exhaleMask#_1729: MaskType;
  var exhaleHeap#_1728: HeapType;
  assume (0 < methodK#_1603) && ((1000 * methodK#_1603) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall k#92#481: int :: (0 <= k#92#481) && (k#92#481 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#92#481) < Heap[this, AVLTreeNode.key]));
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall k#93#482: int :: (0 <= k#93#482) && (k#93#482 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#93#482)));
  }
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // local var lh
  // assigment to lh
  assert {:msg "  585.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  585.20: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  585.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  585.38: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  585.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  585.38: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  lh#60 := ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  // local var rh
  // assigment to rh
  assert {:msg "  586.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  586.20: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  586.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  586.38: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  586.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  586.38: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  rh#62 := ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  // assert
  assertHeap#_1604 := Heap;
  assertMask#_1605 := Mask;
  assertSecMask#_1606 := SecMask;
  assertCredits#_1607 := Credits;
  assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
  // begin exhale (assert)
  exhaleMask#_1609 := assertMask#_1605;
  havoc exhaleHeap#_1608;
  assert {:msg "  588.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  588.10: Location might not be readable."} true ==> CanRead(assertMask#_1605, assertSecMask#_1606, this, AVLTreeNode.left);
  if (!(assertHeap#_1604[this, AVLTreeNode.left] == null)) {
    // unfolding
    assume (0 < unfoldingK#_1615) && ((1000 * unfoldingK#_1615) < Fractions(1));
    predFlag#_1614 := true;
    assert {:msg "  588.36: Receiver might be null."} true ==> (this != null);
    assert {:msg "  588.36: Location might not be readable."} true ==> CanRead(assertMask#_1605, assertSecMask#_1606, this, AVLTreeNode.left);
    assert {:msg "  588.36: Receiver might be null."} true ==> (assertHeap#_1604[this, AVLTreeNode.left] != null);
    unfoldingHeap#_1610 := assertHeap#_1604;
    unfoldingMask#_1611 := assertMask#_1605;
    unfoldingSecMask#_1612 := assertSecMask#_1606;
    unfoldingCredits#_1613 := assertCredits#_1607;
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    // begin exhale (unfolding)
    assert {:msg "  588.26: Unfolding might fail. The permission at 588.36 might not be positive."} Fractions(100) > 0;
    assert {:msg "  588.26: Unfolding might fail. Insufficient fraction at 588.36 for AVLTreeNode.valid."} (Fractions(100) <= unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false) {
      // begin exhale (update SecMask)
      if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#483: int :: (0 <= lk#79#483) && (lk#79#483 < Seq#Length(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#483) < unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#484: int :: (0 <= rk#80#484) && (rk#80#484 < Seq#Length(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#484)));
      }
      if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
      unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1612[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
        assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      }
      if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
        assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      }
      if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
        assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      }
      if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
        assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      }
      if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
        assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      }
      if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
        assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      }
      if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
        assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      }
      if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1612[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
        assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      }
      assume wf(unfoldingHeap#_1610, unfoldingSecMask#_1612, unfoldingSecMask#_1612);
      // end exhale
    }
    if (!CanRead(unfoldingMask#_1611, unfoldingSecMask#_1612, unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.valid)) {
      oldVers#_1635 := unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.valid];
      havoc newVers#_1636;
      unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_1636;
      assume oldVers#_1635 < unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(unfoldingMask#_1611);
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume IsGoodMask(unfoldingMask#_1611);
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    // end exhale
    // inhale (unfolding)
    assume unfoldingHeap#_1610[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume true;
    assume Fractions(100) > 0;
    unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1611);
    assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key]));
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume unfoldingHeap#_1610[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1611);
    assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume unfoldingHeap#_1610[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume (unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1611);
    assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left]));
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume unfoldingHeap#_1610[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume (unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1611);
    assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right]));
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume unfoldingHeap#_1610[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1611);
    assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume unfoldingHeap#_1610[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1611);
    assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume Fractions(100) > 0;
      unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(unfoldingMask#_1611);
      assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    }
    if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1611);
      assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    }
    if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1611);
      assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]));
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    }
    if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1611);
      assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    }
    if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume (forall lk#79#487: int :: (0 <= lk#79#487) && (lk#79#487 < Seq#Length(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#487) < unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key]));
    }
    if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume Fractions(100) > 0;
      unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(unfoldingMask#_1611);
      assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    }
    if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1611);
      assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    }
    if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1611);
      assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]));
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    }
    if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1611[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1611);
      assume IsGoodState(heapFragment(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
      assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    }
    if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume (forall rk#80#488: int :: (0 <= rk#80#488) && (rk#80#488 < Seq#Length(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#488)));
    }
    if (!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key]);
    assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.key])));
    assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1610[unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume unfoldingHeap#_1610[unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    assume IsGoodMask(unfoldingMask#_1611);
    assume wf(unfoldingHeap#_1610, unfoldingMask#_1611, unfoldingSecMask#_1612);
    // end inhale
    if (false) {
      // begin exhale (update SecMask)
      if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#489: int :: (0 <= lk#79#489) && (lk#79#489 < Seq#Length(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#489) < assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#490: int :: (0 <= rk#80#490) && (rk#80#490 < Seq#Length(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#490)));
      }
      if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key])), ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys], assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
      assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
        assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      }
      if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
        assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      }
      if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
        assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      }
      if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
        assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      }
      if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
        assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      }
      if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
        assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      }
      if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
        assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      }
      if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
        assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      }
      assume wf(assertHeap#_1604, assertSecMask#_1606, assertSecMask#_1606);
      // end exhale
    }
    assume assertHeap#_1604[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume true;
    assume Fractions(100) > 0;
    assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1605);
    assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key]));
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume assertHeap#_1604[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1605);
    assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume assertHeap#_1604[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume (assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1605);
    assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left]));
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume assertHeap#_1604[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume (assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1605);
    assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right]));
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume assertHeap#_1604[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1605);
    assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume assertHeap#_1604[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1606[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1605);
    assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume Fractions(100) > 0;
      assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(assertMask#_1605);
      assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    }
    if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1605);
      assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    }
    if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1605);
      assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]));
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    }
    if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1605);
      assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    }
    if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume (forall lk#79#493: int :: (0 <= lk#79#493) && (lk#79#493 < Seq#Length(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#493) < assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key]));
    }
    if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume Fractions(100) > 0;
      assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(assertMask#_1605);
      assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    }
    if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1605);
      assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    }
    if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1605);
      assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]));
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    }
    if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1606[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1605);
      assume IsGoodState(heapFragment(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
      assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
    }
    if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume (forall rk#80#494: int :: (0 <= rk#80#494) && (rk#80#494 < Seq#Length(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#494)));
    }
    if (!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key])), ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys], assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key]);
    assume (forall kk#81: int :: Seq#Contains(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.key])));
    assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1604[assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    assert {:msg "  588.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  588.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1611, unfoldingSecMask#_1612, this, AVLTreeNode.left);
    assert {:msg "  588.51: Receiver might be null."} true ==> (unfoldingHeap#_1610[this, AVLTreeNode.left] != null);
    assert {:msg "  588.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1611, unfoldingSecMask#_1612, unfoldingHeap#_1610[this, AVLTreeNode.left], AVLTreeNode.height);
    assert {:msg "  588.3: Assertion might not hold. The expression at 588.26 might not evaluate to true."} assertHeap#_1604[assertHeap#_1604[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  assertMask#_1605 := exhaleMask#_1609;
  assume IsGoodExhaleState(exhaleHeap#_1608, assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
  assertHeap#_1604 := exhaleHeap#_1608;
  assume IsGoodMask(assertMask#_1605);
  assume wf(assertHeap#_1604, assertMask#_1605, assertSecMask#_1606);
  // end exhale
  // assert
  assertHeap#_1653 := Heap;
  assertMask#_1654 := Mask;
  assertSecMask#_1655 := SecMask;
  assertCredits#_1656 := Credits;
  assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
  // begin exhale (assert)
  exhaleMask#_1658 := assertMask#_1654;
  havoc exhaleHeap#_1657;
  assert {:msg "  589.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  589.10: Location might not be readable."} true ==> CanRead(assertMask#_1654, assertSecMask#_1655, this, AVLTreeNode.right);
  if (!(assertHeap#_1653[this, AVLTreeNode.right] == null)) {
    // unfolding
    assume (0 < unfoldingK#_1664) && ((1000 * unfoldingK#_1664) < Fractions(1));
    predFlag#_1663 := true;
    assert {:msg "  589.36: Receiver might be null."} true ==> (this != null);
    assert {:msg "  589.36: Location might not be readable."} true ==> CanRead(assertMask#_1654, assertSecMask#_1655, this, AVLTreeNode.right);
    assert {:msg "  589.36: Receiver might be null."} true ==> (assertHeap#_1653[this, AVLTreeNode.right] != null);
    unfoldingHeap#_1659 := assertHeap#_1653;
    unfoldingMask#_1660 := assertMask#_1654;
    unfoldingSecMask#_1661 := assertSecMask#_1655;
    unfoldingCredits#_1662 := assertCredits#_1656;
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    // begin exhale (unfolding)
    assert {:msg "  589.26: Unfolding might fail. The permission at 589.36 might not be positive."} Fractions(100) > 0;
    assert {:msg "  589.26: Unfolding might fail. Insufficient fraction at 589.36 for AVLTreeNode.valid."} (Fractions(100) <= unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false) {
      // begin exhale (update SecMask)
      if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#495: int :: (0 <= lk#79#495) && (lk#79#495 < Seq#Length(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#495) < unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#496: int :: (0 <= rk#80#496) && (rk#80#496 < Seq#Length(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#496)));
      }
      if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
      unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1661[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
        assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      }
      if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
        assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      }
      if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
        assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      }
      if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
        assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      }
      if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
        assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      }
      if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
        assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      }
      if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
        assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      }
      if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1661[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
        assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      }
      assume wf(unfoldingHeap#_1659, unfoldingSecMask#_1661, unfoldingSecMask#_1661);
      // end exhale
    }
    if (!CanRead(unfoldingMask#_1660, unfoldingSecMask#_1661, unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.valid)) {
      oldVers#_1684 := unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.valid];
      havoc newVers#_1685;
      unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_1685;
      assume oldVers#_1684 < unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(unfoldingMask#_1660);
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume IsGoodMask(unfoldingMask#_1660);
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    // end exhale
    // inhale (unfolding)
    assume unfoldingHeap#_1659[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume true;
    assume Fractions(100) > 0;
    unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1660);
    assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key]));
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume unfoldingHeap#_1659[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1660);
    assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume unfoldingHeap#_1659[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume (unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1660);
    assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left]));
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume unfoldingHeap#_1659[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume (unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1660);
    assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right]));
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume unfoldingHeap#_1659[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1660);
    assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume unfoldingHeap#_1659[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1660);
    assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume Fractions(100) > 0;
      unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(unfoldingMask#_1660);
      assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    }
    if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1660);
      assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    }
    if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1660);
      assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]));
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    }
    if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1660);
      assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    }
    if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume (forall lk#79#499: int :: (0 <= lk#79#499) && (lk#79#499 < Seq#Length(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#499) < unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key]));
    }
    if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume Fractions(100) > 0;
      unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(unfoldingMask#_1660);
      assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    }
    if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1660);
      assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    }
    if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1660);
      assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]));
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    }
    if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1660[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1660);
      assume IsGoodState(heapFragment(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
      assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    }
    if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume (forall rk#80#500: int :: (0 <= rk#80#500) && (rk#80#500 < Seq#Length(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#500)));
    }
    if (!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key]);
    assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.key])));
    assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1659[unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume unfoldingHeap#_1659[unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    assume IsGoodMask(unfoldingMask#_1660);
    assume wf(unfoldingHeap#_1659, unfoldingMask#_1660, unfoldingSecMask#_1661);
    // end inhale
    if (false) {
      // begin exhale (update SecMask)
      if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#501: int :: (0 <= lk#79#501) && (lk#79#501 < Seq#Length(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#501) < assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#502: int :: (0 <= rk#80#502) && (rk#80#502 < Seq#Length(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#502)));
      }
      if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key])), ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys], assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
      assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
        assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      }
      if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
        assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      }
      if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
        assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      }
      if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
        assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      }
      if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
        assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      }
      if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
        assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      }
      if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
        assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      }
      if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
        assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      }
      assume wf(assertHeap#_1653, assertSecMask#_1655, assertSecMask#_1655);
      // end exhale
    }
    assume assertHeap#_1653[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume true;
    assume Fractions(100) > 0;
    assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1654);
    assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key]));
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume assertHeap#_1653[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1654);
    assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume assertHeap#_1653[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume (assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1654);
    assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left]));
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume assertHeap#_1653[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume (assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1654);
    assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right]));
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume assertHeap#_1653[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1654);
    assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume assertHeap#_1653[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1655[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1654);
    assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume Fractions(100) > 0;
      assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(assertMask#_1654);
      assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    }
    if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1654);
      assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    }
    if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1654);
      assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]));
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    }
    if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1654);
      assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    }
    if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume (forall lk#79#505: int :: (0 <= lk#79#505) && (lk#79#505 < Seq#Length(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#505) < assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key]));
    }
    if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume Fractions(100) > 0;
      assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(assertMask#_1654);
      assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    }
    if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1654);
      assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    }
    if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1654);
      assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]));
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    }
    if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1655[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1654);
      assume IsGoodState(heapFragment(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
      assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
    }
    if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume (forall rk#80#506: int :: (0 <= rk#80#506) && (rk#80#506 < Seq#Length(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#506)));
    }
    if (!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key])), ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys], assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key]);
    assume (forall kk#81: int :: Seq#Contains(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.key])));
    assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_1653[assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    assert {:msg "  589.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  589.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1660, unfoldingSecMask#_1661, this, AVLTreeNode.right);
    assert {:msg "  589.51: Receiver might be null."} true ==> (unfoldingHeap#_1659[this, AVLTreeNode.right] != null);
    assert {:msg "  589.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1660, unfoldingSecMask#_1661, unfoldingHeap#_1659[this, AVLTreeNode.right], AVLTreeNode.height);
    assert {:msg "  589.3: Assertion might not hold. The expression at 589.26 might not evaluate to true."} assertHeap#_1653[assertHeap#_1653[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assertMask#_1654 := exhaleMask#_1658;
  assume IsGoodExhaleState(exhaleHeap#_1657, assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
  assertHeap#_1653 := exhaleHeap#_1657;
  assume IsGoodMask(assertMask#_1654);
  assume wf(assertHeap#_1653, assertMask#_1654, assertSecMask#_1655);
  // end exhale
  // update field height
  assert {:msg "  590.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.height);
  assert {:msg "  590.18: Receiver might be null."} true ==> (this != null);
  assert {:msg "  590.18: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  590.35: Receiver might be null."} true ==> (this != null);
    assert {:msg "  590.35: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  590.35: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  590.35: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  590.51: Receiver might be null."} true ==> (this != null);
  assert {:msg "  590.51: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  590.69: Receiver might be null."} true ==> (this != null);
    assert {:msg "  590.69: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  590.69: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  590.69: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  if (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) {
    assert {:msg "  590.89: Receiver might be null."} true ==> (this != null);
    assert {:msg "  590.89: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    if (Heap[this, AVLTreeNode.left] == null) {
    } else {
      assert {:msg "  590.106: Receiver might be null."} true ==> (this != null);
      assert {:msg "  590.106: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
      assert {:msg "  590.106: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
      assert {:msg "  590.106: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
    }
  } else {
    assert {:msg "  590.126: Receiver might be null."} true ==> (this != null);
    assert {:msg "  590.126: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    if (Heap[this, AVLTreeNode.right] == null) {
    } else {
      assert {:msg "  590.144: Receiver might be null."} true ==> (this != null);
      assert {:msg "  590.144: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
      assert {:msg "  590.144: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
      assert {:msg "  590.144: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
    }
  }
  Heap[this, AVLTreeNode.height] := ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume wf(Heap, Mask, SecMask);
  // update field balanceFactor
  assert {:msg "  592.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.balanceFactor);
  assert {:msg "  592.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  592.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  592.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  592.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  592.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  592.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  592.55: Receiver might be null."} true ==> (this != null);
  assert {:msg "  592.55: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  592.73: Receiver might be null."} true ==> (this != null);
    assert {:msg "  592.73: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  592.73: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  592.73: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  Heap[this, AVLTreeNode.balanceFactor] := ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  assume wf(Heap, Mask, SecMask);
  // update field keys
  assert {:msg "  593.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.keys);
  assert {:msg "  593.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  593.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  593.46: Receiver might be null."} true ==> (this != null);
    assert {:msg "  593.46: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  593.46: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  593.46: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  593.62: Receiver might be null."} true ==> (this != null);
  assert {:msg "  593.62: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  assert {:msg "  593.72: Receiver might be null."} true ==> (this != null);
  assert {:msg "  593.72: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  593.97: Receiver might be null."} true ==> (this != null);
    assert {:msg "  593.97: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  593.97: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  593.97: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  Heap[this, AVLTreeNode.keys] := Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  // assert
  assertHeap#_1702 := Heap;
  assertMask#_1703 := Mask;
  assertSecMask#_1704 := SecMask;
  assertCredits#_1705 := Credits;
  assume wf(assertHeap#_1702, assertMask#_1703, assertSecMask#_1704);
  // begin exhale (assert)
  exhaleMask#_1707 := assertMask#_1703;
  havoc exhaleHeap#_1706;
  assert {:msg "  594.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  594.11: Location might not be readable."} true ==> CanRead(assertMask#_1703, assertSecMask#_1704, this, AVLTreeNode.key);
  assert {:msg "  594.10: Sequence index might be negative."} true ==> (0 <= 0);
  assert {:msg "  594.10: Sequence index might be larger than or equal to the length of the sequence."} true ==> (0 < Seq#Length(Seq#Singleton(assertHeap#_1702[this, AVLTreeNode.key])));
  assert {:msg "  594.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  594.22: Location might not be readable."} true ==> CanRead(assertMask#_1703, assertSecMask#_1704, this, AVLTreeNode.key);
  assert {:msg "  594.3: Assertion might not hold. The expression at 594.10 might not evaluate to true."} Seq#Index(Seq#Singleton(assertHeap#_1702[this, AVLTreeNode.key]), 0) == assertHeap#_1702[this, AVLTreeNode.key];
  assertMask#_1703 := exhaleMask#_1707;
  assume IsGoodExhaleState(exhaleHeap#_1706, assertHeap#_1702, assertMask#_1703, assertSecMask#_1704);
  assertHeap#_1702 := exhaleHeap#_1706;
  assume IsGoodMask(assertMask#_1703);
  assume wf(assertHeap#_1702, assertMask#_1703, assertSecMask#_1704);
  // end exhale
  // fold
  assume #AVLTreeNode.valid#trigger(this);
  assume (0 < foldK#_1711) && ((1000 * foldK#_1711) < Fractions(1)) && ((1000 * foldK#_1711) < methodK#_1603);
  assert {:msg "  595.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_1713 := Mask;
  havoc exhaleHeap#_1712;
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 129.22 might not evaluate to true."} (forall lk#79#507: int :: (0 <= lk#79#507) && (lk#79#507 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#507) < Heap[this, AVLTreeNode.key]));
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 130.22 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 136.24 might not evaluate to true."} (forall rk#80#508: int :: (0 <= rk#80#508) && (rk#80#508 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#508)));
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 137.23 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 139.6 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 140.6 might not evaluate to true."} Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 141.7 might not evaluate to true."} (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 146.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 147.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 148.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 149.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 150.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] > 0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 117.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 117.6 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_1713[this, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_1713[this, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1713[this, AVLTreeNode.key][perm$N]));
  exhaleMask#_1713[this, AVLTreeNode.key] := exhaleMask#_1713[this, AVLTreeNode.key][perm$R := exhaleMask#_1713[this, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_1713);
  assume wf(Heap, exhaleMask#_1713, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 118.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 118.6 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1713[this, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1713[this, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1713[this, AVLTreeNode.height][perm$N]));
  exhaleMask#_1713[this, AVLTreeNode.height] := exhaleMask#_1713[this, AVLTreeNode.height][perm$R := exhaleMask#_1713[this, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_1713);
  assume wf(Heap, exhaleMask#_1713, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 119.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 119.6 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_1713[this, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_1713[this, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1713[this, AVLTreeNode.left][perm$N]));
  exhaleMask#_1713[this, AVLTreeNode.left] := exhaleMask#_1713[this, AVLTreeNode.left][perm$R := exhaleMask#_1713[this, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_1713);
  assume wf(Heap, exhaleMask#_1713, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 120.6 might not be positive."} Fractions(100) > 0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 120.6 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_1713[this, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_1713[this, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1713[this, AVLTreeNode.right][perm$N]));
  exhaleMask#_1713[this, AVLTreeNode.right] := exhaleMask#_1713[this, AVLTreeNode.right][perm$R := exhaleMask#_1713[this, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume Fractions(100) > 0;
  SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(exhaleMask#_1713);
  assume wf(Heap, exhaleMask#_1713, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 122.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 122.6 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1713[this, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1713[this, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1713[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1713[this, AVLTreeNode.keys] := exhaleMask#_1713[this, AVLTreeNode.keys][perm$R := exhaleMask#_1713[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_1713);
  assume wf(Heap, exhaleMask#_1713, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 123.6 might not be positive."} Fractions(50) > 0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 123.6 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1713[this, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1713[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1713[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1713[this, AVLTreeNode.balanceFactor] := exhaleMask#_1713[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1713[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume Fractions(50) > 0;
  SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(exhaleMask#_1713);
  assume wf(Heap, exhaleMask#_1713, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 125.22 might not be positive."} Fractions(100) > 0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 125.22 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    if (!CanRead(exhaleMask#_1713, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1712[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1713);
    assume wf(Heap, exhaleMask#_1713, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 126.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 126.22 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1713);
    assume wf(Heap, exhaleMask#_1713, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 127.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 127.22 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1713);
    assume wf(Heap, exhaleMask#_1713, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 128.22 might not be positive."} Fractions(50) > 0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 128.22 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1713[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1713);
    assume wf(Heap, exhaleMask#_1713, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 132.23 might not be positive."} Fractions(100) > 0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 132.23 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    assume Fractions(100) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    if (!CanRead(exhaleMask#_1713, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1712[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1713);
    assume wf(Heap, exhaleMask#_1713, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 133.23 might not be positive."} Fractions(50) > 0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 133.23 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1713);
    assume wf(Heap, exhaleMask#_1713, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 134.23 might not be positive."} Fractions(50) > 0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 134.23 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1713);
    assume wf(Heap, exhaleMask#_1713, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 135.23 might not be positive."} Fractions(50) > 0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 135.23 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1713[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume Fractions(50) > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(exhaleMask#_1713);
    assume wf(Heap, exhaleMask#_1713, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_1713;
  assume IsGoodExhaleState(exhaleHeap#_1712, Heap, Mask, SecMask);
  Heap := exhaleHeap#_1712;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  predRec#_1708 := this;
  predVer#_1709 := Heap[this, AVLTreeNode.valid];
  predFlag#_1710 := true;
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_1729 := Mask;
  havoc exhaleHeap#_1728;
  assert {:msg "  543.2: The postcondition at 572.11 might not hold. The expression at 572.11 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  543.2: The postcondition at 575.11 might not hold. The expression at 575.11 might not evaluate to true."} Heap[this, AVLTreeNode.height] == ite(ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]), ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  543.2: The postcondition at 582.11 might not hold. The expression at 582.11 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == (ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  543.2: The postcondition at 567.11 might not hold. The permission at 567.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  543.2: The postcondition at 567.11 might not hold. Insufficient fraction at 567.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1729[this, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1729[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1729[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1729[this, AVLTreeNode.valid] := exhaleMask#_1729[this, AVLTreeNode.valid][perm$R := exhaleMask#_1729[this, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_1709 == Heap[this, AVLTreeNode.valid]) && (predRec#_1708 == this) && true && predFlag#_1710)) {
    // begin exhale (update SecMask)
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#511: int :: (0 <= lk#79#511) && (lk#79#511 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#511) < Heap[this, AVLTreeNode.key]));
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#512: int :: (0 <= rk#80#512) && (rk#80#512 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#512)));
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this, AVLTreeNode.height] > 0;
    SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := SecMask[this, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this, AVLTreeNode.key] := SecMask[this, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := SecMask[this, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this, AVLTreeNode.height] := SecMask[this, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := SecMask[this, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this, AVLTreeNode.left] := SecMask[this, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := SecMask[this, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this, AVLTreeNode.right] := SecMask[this, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := SecMask[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this, AVLTreeNode.keys] := SecMask[this, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := SecMask[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this, AVLTreeNode.balanceFactor] := SecMask[this, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.left] == null)) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this, AVLTreeNode.right] == null)) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(exhaleMask#_1729, SecMask, this, AVLTreeNode.valid)) {
    assume Heap[this, AVLTreeNode.valid] < exhaleHeap#_1728[this, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_1729);
  assume wf(Heap, exhaleMask#_1729, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  543.2: The postcondition at 568.11 might not hold. The permission at 568.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  543.2: The postcondition at 568.11 might not hold. Insufficient fraction at 568.11 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1729[this, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1729[this, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1729[this, AVLTreeNode.height][perm$N]));
  exhaleMask#_1729[this, AVLTreeNode.height] := exhaleMask#_1729[this, AVLTreeNode.height][perm$R := exhaleMask#_1729[this, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_1729);
  assume wf(Heap, exhaleMask#_1729, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  543.2: The postcondition at 569.11 might not hold. The permission at 569.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  543.2: The postcondition at 569.11 might not hold. Insufficient fraction at 569.11 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1729[this, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1729[this, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1729[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1729[this, AVLTreeNode.keys] := exhaleMask#_1729[this, AVLTreeNode.keys][perm$R := exhaleMask#_1729[this, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_1729);
  assume wf(Heap, exhaleMask#_1729, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  543.2: The postcondition at 570.11 might not hold. The permission at 570.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  543.2: The postcondition at 570.11 might not hold. Insufficient fraction at 570.11 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1729[this, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1729[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1729[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1729[this, AVLTreeNode.balanceFactor] := exhaleMask#_1729[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1729[this, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_1729);
  assume wf(Heap, exhaleMask#_1729, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1729;
  assume IsGoodExhaleState(exhaleHeap#_1728, Heap, Mask, SecMask);
  Heap := exhaleHeap#_1728;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  543.2: Method might lock/unlock more than allowed."} (forall lk#_1750: ref :: {Heap[lk#_1750, held]} {Heap[lk#_1750, rdheld]} (((0 < Heap[lk#_1750, held]) == (0 < old(Heap)[lk#_1750, held])) && (Heap[lk#_1750, rdheld] == old(Heap)[lk#_1750, rdheld])) || false);
  assert {:msg "  543.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceLeft$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#63: ref where (r#63 == null) || (dtype(r#63) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1751: int;
  var k#94#516: int where true;
  var k#95#518: int where true;
  assume (0 < methodK#_1751) && ((1000 * methodK#_1751) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  608.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  608.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assert {:msg "  609.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  609.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  609.12: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
  assert {:msg "  609.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  609.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  610.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  610.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  611.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  611.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  612.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  612.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  613.12: Receiver might be null."} true && (0 <= k#94#516) ==> (this != null);
  assert {:msg "  613.12: Location might not be readable."} true && (0 <= k#94#516) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  613.12: Receiver might be null."} true && (0 <= k#94#516) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  613.12: Location might not be readable."} true && (0 <= k#94#516) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  613.12: Receiver might be null."} true && (0 <= k#94#516) && (k#94#516 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  613.12: Location might not be readable."} true && (0 <= k#94#516) && (k#94#516 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  613.12: Receiver might be null."} true && (0 <= k#94#516) && (k#94#516 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  613.12: Location might not be readable."} true && (0 <= k#94#516) && (k#94#516 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  613.37: Sequence index might be negative."} true && (0 <= k#94#516) && (k#94#516 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#94#516);
  assert {:msg "  613.37: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#94#516) && (k#94#516 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#94#516 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assert {:msg "  613.41: Receiver might be null."} true && (0 <= k#94#516) && (k#94#516 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  613.41: Location might not be readable."} true && (0 <= k#94#516) && (k#94#516 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  assume (forall k#94#515: int :: (0 <= k#94#515) && (k#94#515 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#94#515) < Heap[this, AVLTreeNode.key]));
  assert {:msg "  615.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  615.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  615.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  615.28: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  615.28: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  615.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  615.28: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  616.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  616.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  616.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  616.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  617.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  617.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  617.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  617.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  618.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  618.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  618.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  618.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  619.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  619.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  619.12: Receiver might be null."} true && (0 <= k#95#518) ==> (this != null);
    assert {:msg "  619.12: Location might not be readable."} true && (0 <= k#95#518) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  619.12: Receiver might be null."} true && (0 <= k#95#518) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  619.12: Location might not be readable."} true && (0 <= k#95#518) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  619.54: Receiver might be null."} true && (0 <= k#95#518) && (k#95#518 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  619.54: Location might not be readable."} true && (0 <= k#95#518) && (k#95#518 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    assert {:msg "  619.12: Receiver might be null."} true && (0 <= k#95#518) && (k#95#518 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  619.12: Location might not be readable."} true && (0 <= k#95#518) && (k#95#518 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  619.12: Receiver might be null."} true && (0 <= k#95#518) && (k#95#518 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  619.12: Location might not be readable."} true && (0 <= k#95#518) && (k#95#518 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  619.60: Sequence index might be negative."} true && (0 <= k#95#518) && (k#95#518 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#95#518);
    assert {:msg "  619.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#95#518) && (k#95#518 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#95#518 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall k#95#517: int :: (0 <= k#95#517) && (k#95#517 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#95#517)));
  }
  assert {:msg "  621.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  621.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  621.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  621.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  621.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  621.25: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  621.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  621.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  621.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  621.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#63 == null);
  assert {:msg "  624.11: Receiver might be null."} r#63 != null;
  assume r#63 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[r#63, AVLTreeNode.valid] := Mask[r#63, AVLTreeNode.valid][perm$R := Mask[r#63, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#63, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#63 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#63, AVLTreeNode.height] := Mask[r#63, AVLTreeNode.height][perm$R := Mask[r#63, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#63, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#63 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#63, AVLTreeNode.keys] := Mask[r#63, AVLTreeNode.keys][perm$R := Mask[r#63, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#63, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#63 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#63, AVLTreeNode.balanceFactor] := Mask[r#63, AVLTreeNode.balanceFactor][perm$R := Mask[r#63, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#63, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  629.11: Receiver might be null."} true ==> (r#63 != null);
  assert {:msg "  629.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#63, AVLTreeNode.height);
  assert {:msg "  629.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  629.27: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  assert {:msg "  629.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  629.27: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  629.43: Receiver might be null."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (r#63 != null);
  assert {:msg "  629.43: Location might not be readable."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(Mask, SecMask, r#63, AVLTreeNode.height);
  assert {:msg "  629.59: Receiver might be null."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  629.59: Location might not be readable."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  assert {:msg "  629.59: Receiver might be null."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  629.59: Location might not be readable."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assume (Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#63, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height] + 1));
  assert {:msg "  630.11: Receiver might be null."} true ==> (r#63 != null);
  assert {:msg "  630.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#63, AVLTreeNode.keys);
  assert {:msg "  630.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  630.25: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  assert {:msg "  630.25: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  630.25: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  630.44: Receiver might be null."} true ==> (this != null);
  assert {:msg "  630.44: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.key);
  assert {:msg "  630.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  630.59: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  630.89: Receiver might be null."} true ==> (this != null);
    assert {:msg "  630.89: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
    assert {:msg "  630.89: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  630.89: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[r#63, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.rebalanceLeft(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#63: ref where (r#63 == null) || (dtype(r#63) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1751: int;
  var lbf#65: int where true;
  var methodCallK#_1756: int;
  var this#521: ref where (this#521 == null) || (dtype(this#521) == AVLTreeNode#t);
  var bf#522: int where true;
  var callHeap#_1752: HeapType;
  var callMask#_1753: MaskType;
  var callSecMask#_1754: MaskType;
  var callCredits#_1755: CreditsType;
  var exhaleMask#_1758: MaskType;
  var exhaleHeap#_1757: HeapType;
  var isHeld#_1761: int;
  var isRdHeld#_1762: bool;
  var predRec#_1763: ref;
  var predFlag#_1765: bool;
  var predVer#_1764: int;
  var predRec#_1782: ref;
  var predFlag#_1784: bool;
  var predVer#_1783: int;
  var cond#_1801: bool;
  var assertHeap#_1802: HeapType;
  var assertMask#_1803: MaskType;
  var assertSecMask#_1804: MaskType;
  var assertCredits#_1805: CreditsType;
  var exhaleMask#_1807: MaskType;
  var exhaleHeap#_1806: HeapType;
  var unfoldingK#_1813: int;
  var predFlag#_1812: bool;
  var unfoldingHeap#_1808: HeapType;
  var unfoldingMask#_1809: MaskType;
  var unfoldingSecMask#_1810: MaskType;
  var unfoldingCredits#_1811: CreditsType;
  var oldVers#_1833: int;
  var newVers#_1834: int;
  var methodCallK#_1855: int;
  var this#547: ref where (this#547 == null) || (dtype(this#547) == AVLTreeNode#t);
  var r#548: ref where (r#548 == null) || (dtype(r#548) == AVLTreeNode#t);
  var callHeap#_1851: HeapType;
  var callMask#_1852: MaskType;
  var callSecMask#_1853: MaskType;
  var callCredits#_1854: CreditsType;
  var exhaleMask#_1857: MaskType;
  var exhaleHeap#_1856: HeapType;
  var isHeld#_1968: int;
  var isRdHeld#_1969: bool;
  var methodCallK#_1974: int;
  var this#577: ref where (this#577 == null) || (dtype(this#577) == AVLTreeNode#t);
  var r#578: ref where (r#578 == null) || (dtype(r#578) == AVLTreeNode#t);
  var callHeap#_1970: HeapType;
  var callMask#_1971: MaskType;
  var callSecMask#_1972: MaskType;
  var callCredits#_1973: CreditsType;
  var exhaleMask#_1976: MaskType;
  var exhaleHeap#_1975: HeapType;
  var isHeld#_2087: int;
  var isRdHeld#_2088: bool;
  var exhaleMask#_2090: MaskType;
  var exhaleHeap#_2089: HeapType;
  assume (0 < methodK#_1751) && ((1000 * methodK#_1751) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume (forall k#94#519: int :: (0 <= k#94#519) && (k#94#519 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#94#519) < Heap[this, AVLTreeNode.key]));
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall k#95#520: int :: (0 <= k#95#520) && (k#95#520 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#95#520)));
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // local var lbf
  assume (0 < methodCallK#_1756) && ((1000 * methodCallK#_1756) < Fractions(1)) && ((1000 * methodCallK#_1756) < methodK#_1751);
  // call getBalanceFactor
  callHeap#_1752 := Heap;
  callMask#_1753 := Mask;
  callSecMask#_1754 := SecMask;
  callCredits#_1755 := Credits;
  assume wf(callHeap#_1752, callMask#_1753, callSecMask#_1754);
  assert {:msg "  633.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  633.15: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  633.3: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
  this#521 := Heap[this, AVLTreeNode.left];
  // begin exhale (precondition)
  exhaleMask#_1758 := Mask;
  havoc exhaleHeap#_1757;
  assert {:msg "  633.3: The precondition at 489.12 might not hold. The permission at 489.12 might not be positive."} methodCallK#_1756 > 0;
  assert {:msg "  633.3: The precondition at 489.12 might not hold. Insufficient fraction at 489.12 for AVLTreeNode.balanceFactor."} exhaleMask#_1758[this#521, AVLTreeNode.balanceFactor][perm$R] > 0;
  assume methodCallK#_1756 < exhaleMask#_1758[this#521, AVLTreeNode.balanceFactor][perm$R];
  exhaleMask#_1758[this#521, AVLTreeNode.balanceFactor] := exhaleMask#_1758[this#521, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1758[this#521, AVLTreeNode.balanceFactor][perm$R] - methodCallK#_1756];
  assume IsGoodMask(exhaleMask#_1758);
  assume wf(Heap, exhaleMask#_1758, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  633.3: The precondition at 488.12 might not hold. The permission at 488.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  633.3: The precondition at 488.12 might not hold. Insufficient fraction at 488.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1758[this#521, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1758[this#521, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1758[this#521, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1758[this#521, AVLTreeNode.valid] := exhaleMask#_1758[this#521, AVLTreeNode.valid][perm$R := exhaleMask#_1758[this#521, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (!CanRead(exhaleMask#_1758, SecMask, this#521, AVLTreeNode.valid)) {
    assume Heap[this#521, AVLTreeNode.valid] < exhaleHeap#_1757[this#521, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_1758);
  assume wf(Heap, exhaleMask#_1758, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1758;
  assume IsGoodExhaleState(exhaleHeap#_1757, Heap, Mask, SecMask);
  Heap := exhaleHeap#_1757;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  havoc bf#522;
  // inhale (postcondition)
  assume this#521 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#521, AVLTreeNode.valid] := Mask[this#521, AVLTreeNode.valid][perm$R := Mask[this#521, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#521, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#521 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodCallK#_1756 > 0;
  Mask[this#521, AVLTreeNode.balanceFactor] := Mask[this#521, AVLTreeNode.balanceFactor][perm$R := Mask[this#521, AVLTreeNode.balanceFactor][perm$R] + methodCallK#_1756];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#521, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume bf#522 == Heap[this#521, AVLTreeNode.balanceFactor];
  predRec#_1763 := this#521;
  predFlag#_1765 := true;
  assume #AVLTreeNode.valid#trigger(this#521);
  predVer#_1764 := Heap[this#521, AVLTreeNode.valid];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[this#521, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#523: int :: (0 <= lk#79#523) && (lk#79#523 < Seq#Length(Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys], lk#79#523) < Heap[this#521, AVLTreeNode.key]));
    }
    if (!(Heap[this#521, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this#521, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#524: int :: (0 <= rk#80#524) && (rk#80#524 < Seq#Length(Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#521, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys], rk#80#524)));
    }
    if (!(Heap[this#521, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this#521, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this#521, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this#521, AVLTreeNode.key])), ite(Heap[this#521, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this#521, AVLTreeNode.keys], Heap[this#521, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this#521, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this#521, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this#521, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this#521, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this#521, AVLTreeNode.height] == ite(ite(Heap[this#521, AVLTreeNode.left] == null, 0, Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this#521, AVLTreeNode.right] == null, 0, Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this#521, AVLTreeNode.left] == null, 0, Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this#521, AVLTreeNode.right] == null, 0, Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this#521, AVLTreeNode.balanceFactor] == (ite(Heap[this#521, AVLTreeNode.left] == null, 0, Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#521, AVLTreeNode.right] == null, 0, Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this#521, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this#521, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this#521, AVLTreeNode.height] > 0;
    SecMask[this#521, AVLTreeNode.key] := SecMask[this#521, AVLTreeNode.key][perm$R := SecMask[this#521, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this#521, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this#521, AVLTreeNode.key] := SecMask[this#521, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#521, AVLTreeNode.height] := SecMask[this#521, AVLTreeNode.height][perm$R := SecMask[this#521, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this#521, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this#521, AVLTreeNode.height] := SecMask[this#521, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#521, AVLTreeNode.left] := SecMask[this#521, AVLTreeNode.left][perm$R := SecMask[this#521, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this#521, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this#521, AVLTreeNode.left] := SecMask[this#521, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#521, AVLTreeNode.right] := SecMask[this#521, AVLTreeNode.right][perm$R := SecMask[this#521, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this#521, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this#521, AVLTreeNode.right] := SecMask[this#521, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#521, AVLTreeNode.keys] := SecMask[this#521, AVLTreeNode.keys][perm$R := SecMask[this#521, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this#521, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this#521, AVLTreeNode.keys] := SecMask[this#521, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#521, AVLTreeNode.balanceFactor] := SecMask[this#521, AVLTreeNode.balanceFactor][perm$R := SecMask[this#521, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this#521, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this#521, AVLTreeNode.balanceFactor] := SecMask[this#521, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#521, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  assume predRec#_1763 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  SecMask[predRec#_1763, AVLTreeNode.key] := SecMask[predRec#_1763, AVLTreeNode.key][perm$R := SecMask[predRec#_1763, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_1763, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1763 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_1763, AVLTreeNode.height] := SecMask[predRec#_1763, AVLTreeNode.height][perm$R := SecMask[predRec#_1763, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_1763, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1763 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1763, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_1763, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[predRec#_1763, AVLTreeNode.left] := SecMask[predRec#_1763, AVLTreeNode.left][perm$R := SecMask[predRec#_1763, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_1763, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1763 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1763, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_1763, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[predRec#_1763, AVLTreeNode.right] := SecMask[predRec#_1763, AVLTreeNode.right][perm$R := SecMask[predRec#_1763, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_1763, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1763 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_1763, AVLTreeNode.keys] := SecMask[predRec#_1763, AVLTreeNode.keys][perm$R := SecMask[predRec#_1763, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_1763, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1763 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_1763, AVLTreeNode.balanceFactor] := SecMask[predRec#_1763, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_1763, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_1763, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_1763, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1763, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1763, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1763, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1763, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1763, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1763, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1763, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1763, AVLTreeNode.left] == null)) {
    assume (forall lk#79#527: int :: (0 <= lk#79#527) && (lk#79#527 < Seq#Length(Heap[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.keys], lk#79#527) < Heap[predRec#_1763, AVLTreeNode.key]));
  }
  if (!(Heap[predRec#_1763, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_1763, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1763, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1763, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1763, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1763, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1763, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1763, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1763, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1763, AVLTreeNode.right] == null)) {
    assume (forall rk#80#528: int :: (0 <= rk#80#528) && (rk#80#528 < Seq#Length(Heap[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_1763, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.keys], rk#80#528)));
  }
  if (!(Heap[predRec#_1763, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_1763, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_1763, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_1763, AVLTreeNode.key])), ite(Heap[predRec#_1763, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_1763, AVLTreeNode.keys], Heap[predRec#_1763, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[predRec#_1763, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_1763, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_1763, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_1763, AVLTreeNode.key])));
  assume Heap[predRec#_1763, AVLTreeNode.height] == ite(ite(Heap[predRec#_1763, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_1763, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_1763, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_1763, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_1763, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_1763, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1763, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_1763, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1763, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_1763, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_1763, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_1763, AVLTreeNode.height] > 0;
  assume (bf#522 > 0) ==> (!(Heap[this#521, AVLTreeNode.left] == null));
  predRec#_1782 := this#521;
  predFlag#_1784 := true;
  assume #AVLTreeNode.valid#trigger(this#521);
  predVer#_1783 := Heap[this#521, AVLTreeNode.valid];
  if (false || ((predVer#_1764 == Heap[this#521, AVLTreeNode.valid]) && (predRec#_1763 == this#521) && true && predFlag#_1765)) {
    // begin exhale (update SecMask)
    if (!(Heap[this#521, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#529: int :: (0 <= lk#79#529) && (lk#79#529 < Seq#Length(Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys], lk#79#529) < Heap[this#521, AVLTreeNode.key]));
    }
    if (!(Heap[this#521, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this#521, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#530: int :: (0 <= rk#80#530) && (rk#80#530 < Seq#Length(Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#521, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys], rk#80#530)));
    }
    if (!(Heap[this#521, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this#521, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this#521, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this#521, AVLTreeNode.key])), ite(Heap[this#521, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this#521, AVLTreeNode.keys], Heap[this#521, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this#521, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this#521, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this#521, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this#521, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this#521, AVLTreeNode.height] == ite(ite(Heap[this#521, AVLTreeNode.left] == null, 0, Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this#521, AVLTreeNode.right] == null, 0, Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this#521, AVLTreeNode.left] == null, 0, Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this#521, AVLTreeNode.right] == null, 0, Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this#521, AVLTreeNode.balanceFactor] == (ite(Heap[this#521, AVLTreeNode.left] == null, 0, Heap[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#521, AVLTreeNode.right] == null, 0, Heap[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this#521, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this#521, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this#521, AVLTreeNode.height] > 0;
    SecMask[this#521, AVLTreeNode.key] := SecMask[this#521, AVLTreeNode.key][perm$R := SecMask[this#521, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this#521, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this#521, AVLTreeNode.key] := SecMask[this#521, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#521, AVLTreeNode.height] := SecMask[this#521, AVLTreeNode.height][perm$R := SecMask[this#521, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this#521, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this#521, AVLTreeNode.height] := SecMask[this#521, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#521, AVLTreeNode.left] := SecMask[this#521, AVLTreeNode.left][perm$R := SecMask[this#521, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this#521, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this#521, AVLTreeNode.left] := SecMask[this#521, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#521, AVLTreeNode.right] := SecMask[this#521, AVLTreeNode.right][perm$R := SecMask[this#521, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this#521, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this#521, AVLTreeNode.right] := SecMask[this#521, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#521, AVLTreeNode.keys] := SecMask[this#521, AVLTreeNode.keys][perm$R := SecMask[this#521, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this#521, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this#521, AVLTreeNode.keys] := SecMask[this#521, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#521, AVLTreeNode.balanceFactor] := SecMask[this#521, AVLTreeNode.balanceFactor][perm$R := SecMask[this#521, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this#521, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this#521, AVLTreeNode.balanceFactor] := SecMask[this#521, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#521, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#521, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#521, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#521, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  assume predRec#_1782 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  SecMask[predRec#_1782, AVLTreeNode.key] := SecMask[predRec#_1782, AVLTreeNode.key][perm$R := SecMask[predRec#_1782, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_1782, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1782 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_1782, AVLTreeNode.height] := SecMask[predRec#_1782, AVLTreeNode.height][perm$R := SecMask[predRec#_1782, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_1782, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1782 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1782, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_1782, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[predRec#_1782, AVLTreeNode.left] := SecMask[predRec#_1782, AVLTreeNode.left][perm$R := SecMask[predRec#_1782, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_1782, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1782 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1782, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_1782, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[predRec#_1782, AVLTreeNode.right] := SecMask[predRec#_1782, AVLTreeNode.right][perm$R := SecMask[predRec#_1782, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_1782, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1782 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_1782, AVLTreeNode.keys] := SecMask[predRec#_1782, AVLTreeNode.keys][perm$R := SecMask[predRec#_1782, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_1782, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1782 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_1782, AVLTreeNode.balanceFactor] := SecMask[predRec#_1782, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_1782, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_1782, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_1782, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1782, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1782, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1782, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1782, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1782, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1782, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1782, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1782, AVLTreeNode.left] == null)) {
    assume (forall lk#79#533: int :: (0 <= lk#79#533) && (lk#79#533 < Seq#Length(Heap[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.keys], lk#79#533) < Heap[predRec#_1782, AVLTreeNode.key]));
  }
  if (!(Heap[predRec#_1782, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_1782, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1782, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1782, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1782, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1782, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1782, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1782, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1782, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1782, AVLTreeNode.right] == null)) {
    assume (forall rk#80#534: int :: (0 <= rk#80#534) && (rk#80#534 < Seq#Length(Heap[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_1782, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.keys], rk#80#534)));
  }
  if (!(Heap[predRec#_1782, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_1782, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_1782, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_1782, AVLTreeNode.key])), ite(Heap[predRec#_1782, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_1782, AVLTreeNode.keys], Heap[predRec#_1782, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[predRec#_1782, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_1782, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_1782, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_1782, AVLTreeNode.key])));
  assume Heap[predRec#_1782, AVLTreeNode.height] == ite(ite(Heap[predRec#_1782, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_1782, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_1782, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_1782, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_1782, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_1782, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1782, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_1782, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1782, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_1782, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_1782, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_1782, AVLTreeNode.height] > 0;
  assume (bf#522 < 0) ==> (!(Heap[this#521, AVLTreeNode.right] == null));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  lbf#65 := bf#522;
  // if
  cond#_1801 := lbf#65 < 0;
  if (cond#_1801) {
    // assert
    assertHeap#_1802 := Heap;
    assertMask#_1803 := Mask;
    assertSecMask#_1804 := SecMask;
    assertCredits#_1805 := Credits;
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    // begin exhale (assert)
    exhaleMask#_1807 := assertMask#_1803;
    havoc exhaleHeap#_1806;
    // unfolding
    assume (0 < unfoldingK#_1813) && ((1000 * unfoldingK#_1813) < Fractions(1));
    predFlag#_1812 := true;
    assert {:msg "  635.21: Receiver might be null."} true ==> (this != null);
    assert {:msg "  635.21: Location might not be readable."} true ==> CanRead(assertMask#_1803, assertSecMask#_1804, this, AVLTreeNode.left);
    assert {:msg "  635.21: Receiver might be null."} true ==> (assertHeap#_1802[this, AVLTreeNode.left] != null);
    unfoldingHeap#_1808 := assertHeap#_1802;
    unfoldingMask#_1809 := assertMask#_1803;
    unfoldingSecMask#_1810 := assertSecMask#_1804;
    unfoldingCredits#_1811 := assertCredits#_1805;
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    // begin exhale (unfolding)
    assert {:msg "  635.11: Unfolding might fail. The permission at 635.21 might not be positive."} Fractions(100) > 0;
    assert {:msg "  635.11: Unfolding might fail. Insufficient fraction at 635.21 for AVLTreeNode.valid."} (Fractions(100) <= unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if ((false || ((predVer#_1783 == unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1782 == unfoldingHeap#_1808[this, AVLTreeNode.left]) && true && predFlag#_1784)) || ((predVer#_1764 == unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == unfoldingHeap#_1808[this, AVLTreeNode.left]) && true && predFlag#_1765)) {
      if ((predVer#_1764 == unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == unfoldingHeap#_1808[this, AVLTreeNode.left]) && true && predFlag#_1765) {
      } else {
      }
      // begin exhale (update SecMask)
      if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#535: int :: (0 <= lk#79#535) && (lk#79#535 < Seq#Length(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#535) < unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#536: int :: (0 <= rk#80#536) && (rk#80#536 < Seq#Length(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#536)));
      }
      if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
      unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1810[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
        assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      }
      if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
        assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      }
      if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
        assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      }
      if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
        assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      }
      if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
        assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      }
      if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
        assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      }
      if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
        assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      }
      if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_1810[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
        assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      }
      assume wf(unfoldingHeap#_1808, unfoldingSecMask#_1810, unfoldingSecMask#_1810);
      // end exhale
    }
    if (!CanRead(unfoldingMask#_1809, unfoldingSecMask#_1810, unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid)) {
      oldVers#_1833 := unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid];
      havoc newVers#_1834;
      unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_1834;
      assume oldVers#_1833 < unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(unfoldingMask#_1809);
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume IsGoodMask(unfoldingMask#_1809);
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    // end exhale
    // inhale (unfolding)
    assume unfoldingHeap#_1808[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume true;
    assume Fractions(100) > 0;
    unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1809);
    assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key]));
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume unfoldingHeap#_1808[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1809);
    assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume unfoldingHeap#_1808[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume (unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1809);
    assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left]));
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume unfoldingHeap#_1808[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume (unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_1809);
    assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right]));
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume unfoldingHeap#_1808[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1809);
    assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume unfoldingHeap#_1808[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_1809);
    assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume Fractions(100) > 0;
      unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(unfoldingMask#_1809);
      assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    }
    if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1809);
      assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    }
    if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1809);
      assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]));
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    }
    if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1809);
      assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    }
    if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume (forall lk#79#539: int :: (0 <= lk#79#539) && (lk#79#539 < Seq#Length(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#539) < unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key]));
    }
    if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume Fractions(100) > 0;
      unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(unfoldingMask#_1809);
      assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    }
    if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1809);
      assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    }
    if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1809);
      assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]));
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    }
    if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1809[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_1809);
      assume IsGoodState(heapFragment(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
      assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    }
    if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume (forall rk#80#540: int :: (0 <= rk#80#540) && (rk#80#540 < Seq#Length(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#540)));
    }
    if (!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key]);
    assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.key])));
    assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1808[unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume unfoldingHeap#_1808[unfoldingHeap#_1808[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    assume IsGoodMask(unfoldingMask#_1809);
    assume wf(unfoldingHeap#_1808, unfoldingMask#_1809, unfoldingSecMask#_1810);
    // end inhale
    if ((false || ((predVer#_1783 == assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1782 == assertHeap#_1802[this, AVLTreeNode.left]) && true && predFlag#_1784)) || ((predVer#_1764 == assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == assertHeap#_1802[this, AVLTreeNode.left]) && true && predFlag#_1765)) {
      if ((predVer#_1764 == assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == assertHeap#_1802[this, AVLTreeNode.left]) && true && predFlag#_1765) {
      } else {
      }
      // begin exhale (update SecMask)
      if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#541: int :: (0 <= lk#79#541) && (lk#79#541 < Seq#Length(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#541) < assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#542: int :: (0 <= rk#80#542) && (rk#80#542 < Seq#Length(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#542)));
      }
      if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key])), ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys], assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
      assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
        assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      }
      if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
        assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      }
      if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
        assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      }
      if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
        assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      }
      if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
        assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      }
      if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
        assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      }
      if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
        assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      }
      if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
        assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      }
      assume wf(assertHeap#_1802, assertSecMask#_1804, assertSecMask#_1804);
      // end exhale
    }
    assume assertHeap#_1802[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume true;
    assume Fractions(100) > 0;
    assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1803);
    assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key]));
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume assertHeap#_1802[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1803);
    assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume assertHeap#_1802[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume (assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1803);
    assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left]));
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume assertHeap#_1802[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume (assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_1803);
    assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right]));
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume assertHeap#_1802[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1803);
    assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume assertHeap#_1802[this, AVLTreeNode.left] != null;
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1804[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_1803);
    assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume Fractions(100) > 0;
      assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(assertMask#_1803);
      assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    }
    if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1803);
      assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    }
    if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1803);
      assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]));
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    }
    if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1803);
      assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    }
    if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume (forall lk#79#545: int :: (0 <= lk#79#545) && (lk#79#545 < Seq#Length(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#545) < assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key]));
    }
    if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume Fractions(100) > 0;
      assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(assertMask#_1803);
      assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    }
    if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1803);
      assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    }
    if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1803);
      assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]));
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    }
    if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_1804[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_1803);
      assume IsGoodState(heapFragment(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
      assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    }
    if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume (forall rk#80#546: int :: (0 <= rk#80#546) && (rk#80#546 < Seq#Length(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#546)));
    }
    if (!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key])), ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys], assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key]);
    assume (forall kk#81: int :: Seq#Contains(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.key])));
    assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, assertHeap#_1802[assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume assertHeap#_1802[assertHeap#_1802[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    assert {:msg "  635.4: Assertion might not hold. The expression at 635.11 might not evaluate to true."} lbf#65 == (0 - 1);
    assertMask#_1803 := exhaleMask#_1807;
    assume IsGoodExhaleState(exhaleHeap#_1806, assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    assertHeap#_1802 := exhaleHeap#_1806;
    assume IsGoodMask(assertMask#_1803);
    assume wf(assertHeap#_1802, assertMask#_1803, assertSecMask#_1804);
    // end exhale
    assume (0 < methodCallK#_1855) && ((1000 * methodCallK#_1855) < Fractions(1)) && ((1000 * methodCallK#_1855) < methodK#_1751);
    // call rebalanceRL
    callHeap#_1851 := Heap;
    callMask#_1852 := Mask;
    callSecMask#_1853 := SecMask;
    callCredits#_1854 := Credits;
    assume wf(callHeap#_1851, callMask#_1852, callSecMask#_1853);
    assert {:msg "  636.4: The target of the method call might be null."} this != null;
    this#547 := this;
    // begin exhale (precondition)
    exhaleMask#_1857 := Mask;
    havoc exhaleHeap#_1856;
    assert {:msg "  636.4: The precondition at 652.12 might not hold. The expression at 652.12 might not evaluate to true."} !(Heap[this#547, AVLTreeNode.left] == null);
    assert {:msg "  636.4: The precondition at 657.12 might not hold. The expression at 657.12 might not evaluate to true."} (forall k#96#549: int :: (0 <= k#96#549) && (k#96#549 < Seq#Length(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys], k#96#549) < Heap[this#547, AVLTreeNode.key]));
    if (!(Heap[this#547, AVLTreeNode.right] == null)) {
      assert {:msg "  636.4: The precondition at 663.12 might not hold. The expression at 663.28 might not evaluate to true."} (forall k#97#550: int :: (0 <= k#97#550) && (k#97#550 < Seq#Length(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#547, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys], k#97#550)));
    }
    assert {:msg "  636.4: The precondition at 665.12 might not hold. The expression at 665.12 might not evaluate to true."} !(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] == null);
    assert {:msg "  636.4: The precondition at 667.12 might not hold. The expression at 667.12 might not evaluate to true."} (Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#547, AVLTreeNode.right] == null, 0, Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height])) == 2;
    assert {:msg "  636.4: The precondition at 668.12 might not hold. The expression at 668.12 might not evaluate to true."} Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (0 - 1);
    assert {:msg "  636.4: The precondition at 644.12 might not hold. The permission at 644.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  636.4: The precondition at 644.12 might not hold. Insufficient fraction at 644.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_1857[this#547, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_1857[this#547, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1857[this#547, AVLTreeNode.key][perm$N]));
    exhaleMask#_1857[this#547, AVLTreeNode.key] := exhaleMask#_1857[this#547, AVLTreeNode.key][perm$R := exhaleMask#_1857[this#547, AVLTreeNode.key][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1857);
    assume wf(Heap, exhaleMask#_1857, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 645.12 might not hold. The permission at 645.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  636.4: The precondition at 645.12 might not hold. Insufficient fraction at 645.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_1857[this#547, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_1857[this#547, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1857[this#547, AVLTreeNode.height][perm$N]));
    exhaleMask#_1857[this#547, AVLTreeNode.height] := exhaleMask#_1857[this#547, AVLTreeNode.height][perm$R := exhaleMask#_1857[this#547, AVLTreeNode.height][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1857);
    assume wf(Heap, exhaleMask#_1857, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 646.12 might not hold. The permission at 646.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  636.4: The precondition at 646.12 might not hold. Insufficient fraction at 646.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_1857[this#547, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_1857[this#547, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1857[this#547, AVLTreeNode.left][perm$N]));
    exhaleMask#_1857[this#547, AVLTreeNode.left] := exhaleMask#_1857[this#547, AVLTreeNode.left][perm$R := exhaleMask#_1857[this#547, AVLTreeNode.left][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1857);
    assume wf(Heap, exhaleMask#_1857, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 647.12 might not hold. The permission at 647.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  636.4: The precondition at 647.12 might not hold. Insufficient fraction at 647.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_1857[this#547, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_1857[this#547, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1857[this#547, AVLTreeNode.right][perm$N]));
    exhaleMask#_1857[this#547, AVLTreeNode.right] := exhaleMask#_1857[this#547, AVLTreeNode.right][perm$R := exhaleMask#_1857[this#547, AVLTreeNode.right][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1857);
    assume wf(Heap, exhaleMask#_1857, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 649.12 might not hold. The permission at 649.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  636.4: The precondition at 649.12 might not hold. Insufficient fraction at 649.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_1857[this#547, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_1857[this#547, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1857[this#547, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1857[this#547, AVLTreeNode.keys] := exhaleMask#_1857[this#547, AVLTreeNode.keys][perm$R := exhaleMask#_1857[this#547, AVLTreeNode.keys][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1857);
    assume wf(Heap, exhaleMask#_1857, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 650.12 might not hold. The permission at 650.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  636.4: The precondition at 650.12 might not hold. Insufficient fraction at 650.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_1857[this#547, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_1857[this#547, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1857[this#547, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1857[this#547, AVLTreeNode.balanceFactor] := exhaleMask#_1857[this#547, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1857[this#547, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1857);
    assume wf(Heap, exhaleMask#_1857, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 653.12 might not hold. The permission at 653.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  636.4: The precondition at 653.12 might not hold. Insufficient fraction at 653.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if ((false || ((predVer#_1783 == Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1782 == Heap[this#547, AVLTreeNode.left]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[this#547, AVLTreeNode.left]) && true && predFlag#_1765)) {
      if ((predVer#_1764 == Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[this#547, AVLTreeNode.left]) && true && predFlag#_1765) {
      } else {
      }
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#551: int :: (0 <= lk#79#551) && (lk#79#551 < Seq#Length(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#551) < Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#552: int :: (0 <= rk#80#552) && (rk#80#552 < Seq#Length(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#552)));
      }
      if (!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height] > 0;
      SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] != Heap[this#547, AVLTreeNode.left];
        if ((false || ((predVer#_1783 == Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1782 == Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left]) && true && predFlag#_1765)) {
          if ((predVer#_1764 == Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left]) && true && predFlag#_1765) {
          } else {
          }
          // begin exhale (update SecMask)
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
            assume (forall lk#79#555: int :: (0 <= lk#79#555) && (lk#79#555 < Seq#Length(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#555) < Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key]));
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
            assume (forall rk#80#556: int :: (0 <= rk#80#556) && (rk#80#556 < Seq#Length(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#556)));
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
          }
          //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
          assume Seq#Equal(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
          //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
          assume Seq#Contains(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key]);
          //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
          assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key])));
          //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
          //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
          //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
          //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
          //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          assume wf(Heap, SecMask, SecMask);
          // end exhale
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] != Heap[this#547, AVLTreeNode.left];
        if ((false || ((predVer#_1783 == Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1782 == Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right]) && true && predFlag#_1765)) {
          if ((predVer#_1764 == Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right]) && true && predFlag#_1765) {
          } else {
          }
          // begin exhale (update SecMask)
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
            assume (forall lk#79#559: int :: (0 <= lk#79#559) && (lk#79#559 < Seq#Length(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#559) < Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key]));
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
            assume (forall rk#80#560: int :: (0 <= rk#80#560) && (rk#80#560 < Seq#Length(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#560)));
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
          }
          //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
          assume Seq#Equal(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
          //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
          assume Seq#Contains(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key]);
          //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
          assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key])));
          //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
          //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
          //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
          //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
          //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          assume wf(Heap, SecMask, SecMask);
          // end exhale
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_1857, SecMask, Heap[this#547, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#547, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1856[Heap[this#547, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1857);
    assume wf(Heap, exhaleMask#_1857, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 654.12 might not hold. The permission at 654.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  636.4: The precondition at 654.12 might not hold. Insufficient fraction at 654.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1857);
    assume wf(Heap, exhaleMask#_1857, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 655.12 might not hold. The permission at 655.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  636.4: The precondition at 655.12 might not hold. Insufficient fraction at 655.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1857);
    assume wf(Heap, exhaleMask#_1857, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 656.12 might not hold. The permission at 656.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  636.4: The precondition at 656.12 might not hold. Insufficient fraction at 656.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1857[Heap[this#547, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1857);
    assume wf(Heap, exhaleMask#_1857, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#547, AVLTreeNode.right] == null)) {
      assert {:msg "  636.4: The precondition at 659.12 might not hold. The permission at 659.28 might not be positive."} Fractions(100) > 0;
      assert {:msg "  636.4: The precondition at 659.12 might not hold. Insufficient fraction at 659.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if ((false || ((predVer#_1783 == Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1782 == Heap[this#547, AVLTreeNode.right]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[this#547, AVLTreeNode.right]) && true && predFlag#_1765)) {
        if ((predVer#_1764 == Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[this#547, AVLTreeNode.right]) && true && predFlag#_1765) {
        } else {
        }
        // begin exhale (update SecMask)
        if (!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
          assume (forall lk#79#564: int :: (0 <= lk#79#564) && (lk#79#564 < Seq#Length(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#564) < Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.key]));
        }
        if (!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
          assume Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
          assume (forall rk#80#565: int :: (0 <= rk#80#565) && (rk#80#565 < Seq#Length(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#565)));
        }
        if (!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
          assume Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
        assume Seq#Equal(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
        //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
        assume Seq#Contains(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.key]);
        //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
        assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.key])));
        //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
        assume Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
        assume Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
        //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
        assume Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
        //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
        assume Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
        //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
        assume Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height] > 0;
        SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
        if (SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
          SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
        if (SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
          SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
        if (SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
          SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
          }
          assume Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] != Heap[this#547, AVLTreeNode.right];
          if ((false || ((predVer#_1783 == Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1782 == Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left]) && true && predFlag#_1765)) {
            if ((predVer#_1764 == Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left]) && true && predFlag#_1765) {
            } else {
            }
            // begin exhale (update SecMask)
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
              assume (forall lk#79#568: int :: (0 <= lk#79#568) && (lk#79#568 < Seq#Length(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#568) < Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key]));
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
              assume (forall rk#80#569: int :: (0 <= rk#80#569) && (rk#80#569 < Seq#Length(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#569)));
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
            }
            //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
            assume Seq#Equal(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
            //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
            assume Seq#Contains(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key]);
            //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
            assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key])));
            //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
            //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
            //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
            //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
            //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
              SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
              SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
              SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            assume wf(Heap, SecMask, SecMask);
            // end exhale
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
          }
          assume Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] != Heap[this#547, AVLTreeNode.right];
          if ((false || ((predVer#_1783 == Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1782 == Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right]) && true && predFlag#_1765)) {
            if ((predVer#_1764 == Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right]) && true && predFlag#_1765) {
            } else {
            }
            // begin exhale (update SecMask)
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
              assume (forall lk#79#572: int :: (0 <= lk#79#572) && (lk#79#572 < Seq#Length(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#572) < Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key]));
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
              assume (forall rk#80#573: int :: (0 <= rk#80#573) && (rk#80#573 < Seq#Length(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#573)));
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
            }
            //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
            assume Seq#Equal(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
            //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
            assume Seq#Contains(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key]);
            //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
            assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key])));
            //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
            //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
            //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
            //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
            //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
              SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
              SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
              SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            assume wf(Heap, SecMask, SecMask);
            // end exhale
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume wf(Heap, SecMask, SecMask);
        // end exhale
      }
      if (!CanRead(exhaleMask#_1857, SecMask, Heap[this#547, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#547, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1856[Heap[this#547, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_1857);
      assume wf(Heap, exhaleMask#_1857, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#547, AVLTreeNode.right] == null)) {
      assert {:msg "  636.4: The precondition at 660.12 might not hold. The permission at 660.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  636.4: The precondition at 660.12 might not hold. Insufficient fraction at 660.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1857);
      assume wf(Heap, exhaleMask#_1857, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#547, AVLTreeNode.right] == null)) {
      assert {:msg "  636.4: The precondition at 661.12 might not hold. The permission at 661.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  636.4: The precondition at 661.12 might not hold. Insufficient fraction at 661.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1857);
      assume wf(Heap, exhaleMask#_1857, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#547, AVLTreeNode.right] == null)) {
      assert {:msg "  636.4: The precondition at 662.12 might not hold. The permission at 662.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  636.4: The precondition at 662.12 might not hold. Insufficient fraction at 662.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1857[Heap[this#547, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1857);
      assume wf(Heap, exhaleMask#_1857, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_1857;
    assume IsGoodExhaleState(exhaleHeap#_1856, Heap, Mask, SecMask);
    Heap := exhaleHeap#_1856;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#548;
    // inhale (postcondition)
    assume !(r#548 == null);
    assume r#548 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[r#548, AVLTreeNode.valid] := Mask[r#548, AVLTreeNode.valid][perm$R := Mask[r#548, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#548, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#548 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#548, AVLTreeNode.height] := Mask[r#548, AVLTreeNode.height][perm$R := Mask[r#548, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#548, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#548 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#548, AVLTreeNode.keys] := Mask[r#548, AVLTreeNode.keys][perm$R := Mask[r#548, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#548, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#548 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#548, AVLTreeNode.balanceFactor] := Mask[r#548, AVLTreeNode.balanceFactor][perm$R := Mask[r#548, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#548, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Heap[r#548, AVLTreeNode.height] == callHeap#_1851[callHeap#_1851[this#547, AVLTreeNode.left], AVLTreeNode.height];
    assume Seq#Equal(Heap[r#548, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_1851[callHeap#_1851[this#547, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_1851[this#547, AVLTreeNode.key])), ite(callHeap#_1851[this#547, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1851[callHeap#_1851[this#547, AVLTreeNode.right], AVLTreeNode.keys])));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    r#63 := r#548;
  } else {
    assume (0 < methodCallK#_1974) && ((1000 * methodCallK#_1974) < Fractions(1)) && ((1000 * methodCallK#_1974) < methodK#_1751);
    // call rebalanceRR
    callHeap#_1970 := Heap;
    callMask#_1971 := Mask;
    callSecMask#_1972 := SecMask;
    callCredits#_1973 := Credits;
    assume wf(callHeap#_1970, callMask#_1971, callSecMask#_1972);
    assert {:msg "  638.4: The target of the method call might be null."} this != null;
    this#577 := this;
    // begin exhale (precondition)
    exhaleMask#_1976 := Mask;
    havoc exhaleHeap#_1975;
    assert {:msg "  638.4: The precondition at 710.12 might not hold. The expression at 710.12 might not evaluate to true."} !(Heap[this#577, AVLTreeNode.left] == null);
    assert {:msg "  638.4: The precondition at 715.12 might not hold. The expression at 715.12 might not evaluate to true."} (forall k#102#579: int :: (0 <= k#102#579) && (k#102#579 < Seq#Length(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys], k#102#579) < Heap[this#577, AVLTreeNode.key]));
    if (!(Heap[this#577, AVLTreeNode.right] == null)) {
      assert {:msg "  638.4: The precondition at 721.12 might not hold. The expression at 721.28 might not evaluate to true."} (forall k#103#580: int :: (0 <= k#103#580) && (k#103#580 < Seq#Length(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#577, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys], k#103#580)));
    }
    assert {:msg "  638.4: The precondition at 723.12 might not hold. The expression at 723.12 might not evaluate to true."} (Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#577, AVLTreeNode.right] == null, 0, Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height])) == 2;
    assert {:msg "  638.4: The precondition at 724.12 might not hold. The expression at 724.12 might not evaluate to true."} Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= 0;
    assert {:msg "  638.4: The precondition at 702.12 might not hold. The permission at 702.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  638.4: The precondition at 702.12 might not hold. Insufficient fraction at 702.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_1976[this#577, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_1976[this#577, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1976[this#577, AVLTreeNode.key][perm$N]));
    exhaleMask#_1976[this#577, AVLTreeNode.key] := exhaleMask#_1976[this#577, AVLTreeNode.key][perm$R := exhaleMask#_1976[this#577, AVLTreeNode.key][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1976);
    assume wf(Heap, exhaleMask#_1976, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 703.12 might not hold. The permission at 703.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  638.4: The precondition at 703.12 might not hold. Insufficient fraction at 703.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_1976[this#577, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_1976[this#577, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1976[this#577, AVLTreeNode.height][perm$N]));
    exhaleMask#_1976[this#577, AVLTreeNode.height] := exhaleMask#_1976[this#577, AVLTreeNode.height][perm$R := exhaleMask#_1976[this#577, AVLTreeNode.height][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1976);
    assume wf(Heap, exhaleMask#_1976, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 704.12 might not hold. The permission at 704.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  638.4: The precondition at 704.12 might not hold. Insufficient fraction at 704.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_1976[this#577, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_1976[this#577, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1976[this#577, AVLTreeNode.left][perm$N]));
    exhaleMask#_1976[this#577, AVLTreeNode.left] := exhaleMask#_1976[this#577, AVLTreeNode.left][perm$R := exhaleMask#_1976[this#577, AVLTreeNode.left][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1976);
    assume wf(Heap, exhaleMask#_1976, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 705.12 might not hold. The permission at 705.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  638.4: The precondition at 705.12 might not hold. Insufficient fraction at 705.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_1976[this#577, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_1976[this#577, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1976[this#577, AVLTreeNode.right][perm$N]));
    exhaleMask#_1976[this#577, AVLTreeNode.right] := exhaleMask#_1976[this#577, AVLTreeNode.right][perm$R := exhaleMask#_1976[this#577, AVLTreeNode.right][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1976);
    assume wf(Heap, exhaleMask#_1976, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 707.12 might not hold. The permission at 707.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  638.4: The precondition at 707.12 might not hold. Insufficient fraction at 707.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_1976[this#577, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_1976[this#577, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1976[this#577, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1976[this#577, AVLTreeNode.keys] := exhaleMask#_1976[this#577, AVLTreeNode.keys][perm$R := exhaleMask#_1976[this#577, AVLTreeNode.keys][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1976);
    assume wf(Heap, exhaleMask#_1976, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 708.12 might not hold. The permission at 708.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  638.4: The precondition at 708.12 might not hold. Insufficient fraction at 708.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_1976[this#577, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_1976[this#577, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1976[this#577, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1976[this#577, AVLTreeNode.balanceFactor] := exhaleMask#_1976[this#577, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1976[this#577, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_1976);
    assume wf(Heap, exhaleMask#_1976, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 711.12 might not hold. The permission at 711.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  638.4: The precondition at 711.12 might not hold. Insufficient fraction at 711.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if ((false || ((predVer#_1783 == Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1782 == Heap[this#577, AVLTreeNode.left]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[this#577, AVLTreeNode.left]) && true && predFlag#_1765)) {
      if ((predVer#_1764 == Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[this#577, AVLTreeNode.left]) && true && predFlag#_1765) {
      } else {
      }
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#581: int :: (0 <= lk#79#581) && (lk#79#581 < Seq#Length(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#581) < Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#582: int :: (0 <= rk#80#582) && (rk#80#582 < Seq#Length(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#582)));
      }
      if (!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height] > 0;
      SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] != Heap[this#577, AVLTreeNode.left];
        if ((false || ((predVer#_1783 == Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1782 == Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left]) && true && predFlag#_1765)) {
          if ((predVer#_1764 == Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left]) && true && predFlag#_1765) {
          } else {
          }
          // begin exhale (update SecMask)
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
            assume (forall lk#79#585: int :: (0 <= lk#79#585) && (lk#79#585 < Seq#Length(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#585) < Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key]));
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
            assume (forall rk#80#586: int :: (0 <= rk#80#586) && (rk#80#586 < Seq#Length(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#586)));
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
          }
          //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
          assume Seq#Equal(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
          //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
          assume Seq#Contains(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key]);
          //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
          assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key])));
          //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
          //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
          //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
          //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
          //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          assume wf(Heap, SecMask, SecMask);
          // end exhale
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] != Heap[this#577, AVLTreeNode.left];
        if ((false || ((predVer#_1783 == Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1782 == Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right]) && true && predFlag#_1765)) {
          if ((predVer#_1764 == Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right]) && true && predFlag#_1765) {
          } else {
          }
          // begin exhale (update SecMask)
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
            assume (forall lk#79#589: int :: (0 <= lk#79#589) && (lk#79#589 < Seq#Length(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#589) < Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key]));
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
            assume (forall rk#80#590: int :: (0 <= rk#80#590) && (rk#80#590 < Seq#Length(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#590)));
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
          }
          //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
          assume Seq#Equal(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
          //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
          assume Seq#Contains(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key]);
          //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
          assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key])));
          //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
          //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
          //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
          //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
          //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          assume wf(Heap, SecMask, SecMask);
          // end exhale
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_1976, SecMask, Heap[this#577, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#577, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1975[Heap[this#577, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_1976);
    assume wf(Heap, exhaleMask#_1976, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 712.12 might not hold. The permission at 712.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  638.4: The precondition at 712.12 might not hold. Insufficient fraction at 712.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1976);
    assume wf(Heap, exhaleMask#_1976, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 713.12 might not hold. The permission at 713.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  638.4: The precondition at 713.12 might not hold. Insufficient fraction at 713.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1976);
    assume wf(Heap, exhaleMask#_1976, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 714.12 might not hold. The permission at 714.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  638.4: The precondition at 714.12 might not hold. Insufficient fraction at 714.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1976[Heap[this#577, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_1976);
    assume wf(Heap, exhaleMask#_1976, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#577, AVLTreeNode.right] == null)) {
      assert {:msg "  638.4: The precondition at 717.12 might not hold. The permission at 717.28 might not be positive."} Fractions(100) > 0;
      assert {:msg "  638.4: The precondition at 717.12 might not hold. Insufficient fraction at 717.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if ((false || ((predVer#_1783 == Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1782 == Heap[this#577, AVLTreeNode.right]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[this#577, AVLTreeNode.right]) && true && predFlag#_1765)) {
        if ((predVer#_1764 == Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[this#577, AVLTreeNode.right]) && true && predFlag#_1765) {
        } else {
        }
        // begin exhale (update SecMask)
        if (!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
          assume (forall lk#79#594: int :: (0 <= lk#79#594) && (lk#79#594 < Seq#Length(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#594) < Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.key]));
        }
        if (!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
          assume Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
          assume (forall rk#80#595: int :: (0 <= rk#80#595) && (rk#80#595 < Seq#Length(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#595)));
        }
        if (!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
          assume Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
        assume Seq#Equal(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
        //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
        assume Seq#Contains(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.key]);
        //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
        assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.key])));
        //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
        assume Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
        assume Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
        //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
        assume Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
        //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
        assume Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
        //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
        assume Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height] > 0;
        SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
        if (SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
          SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
        if (SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
          SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
        if (SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
          SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
          }
          assume Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] != Heap[this#577, AVLTreeNode.right];
          if ((false || ((predVer#_1783 == Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1782 == Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left]) && true && predFlag#_1765)) {
            if ((predVer#_1764 == Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left]) && true && predFlag#_1765) {
            } else {
            }
            // begin exhale (update SecMask)
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
              assume (forall lk#79#598: int :: (0 <= lk#79#598) && (lk#79#598 < Seq#Length(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#598) < Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key]));
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
              assume (forall rk#80#599: int :: (0 <= rk#80#599) && (rk#80#599 < Seq#Length(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#599)));
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
            }
            //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
            assume Seq#Equal(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
            //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
            assume Seq#Contains(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key]);
            //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
            assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key])));
            //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
            //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
            //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
            //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
            //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
              SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
              SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
              SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            assume wf(Heap, SecMask, SecMask);
            // end exhale
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
          }
          assume Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] != Heap[this#577, AVLTreeNode.right];
          if ((false || ((predVer#_1783 == Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1782 == Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right]) && true && predFlag#_1765)) {
            if ((predVer#_1764 == Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right]) && true && predFlag#_1765) {
            } else {
            }
            // begin exhale (update SecMask)
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
              assume (forall lk#79#602: int :: (0 <= lk#79#602) && (lk#79#602 < Seq#Length(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#602) < Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key]));
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
              assume (forall rk#80#603: int :: (0 <= rk#80#603) && (rk#80#603 < Seq#Length(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#603)));
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
            }
            //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
            assume Seq#Equal(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
            //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
            assume Seq#Contains(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key]);
            //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
            assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key])));
            //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
            //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
            //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
            //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
            //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
              SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
              SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
              SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            assume wf(Heap, SecMask, SecMask);
            // end exhale
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume wf(Heap, SecMask, SecMask);
        // end exhale
      }
      if (!CanRead(exhaleMask#_1976, SecMask, Heap[this#577, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#577, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1975[Heap[this#577, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_1976);
      assume wf(Heap, exhaleMask#_1976, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#577, AVLTreeNode.right] == null)) {
      assert {:msg "  638.4: The precondition at 718.12 might not hold. The permission at 718.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  638.4: The precondition at 718.12 might not hold. Insufficient fraction at 718.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1976);
      assume wf(Heap, exhaleMask#_1976, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#577, AVLTreeNode.right] == null)) {
      assert {:msg "  638.4: The precondition at 719.12 might not hold. The permission at 719.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  638.4: The precondition at 719.12 might not hold. Insufficient fraction at 719.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1976);
      assume wf(Heap, exhaleMask#_1976, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#577, AVLTreeNode.right] == null)) {
      assert {:msg "  638.4: The precondition at 720.12 might not hold. The permission at 720.28 might not be positive."} Fractions(50) > 0;
      assert {:msg "  638.4: The precondition at 720.12 might not hold. Insufficient fraction at 720.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1976[Heap[this#577, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_1976);
      assume wf(Heap, exhaleMask#_1976, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_1976;
    assume IsGoodExhaleState(exhaleHeap#_1975, Heap, Mask, SecMask);
    Heap := exhaleHeap#_1975;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#578;
    // inhale (postcondition)
    assume !(r#578 == null);
    assume r#578 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[r#578, AVLTreeNode.valid] := Mask[r#578, AVLTreeNode.valid][perm$R := Mask[r#578, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#578, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#578 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#578, AVLTreeNode.height] := Mask[r#578, AVLTreeNode.height][perm$R := Mask[r#578, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#578, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#578 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#578, AVLTreeNode.keys] := Mask[r#578, AVLTreeNode.keys][perm$R := Mask[r#578, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#578, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#578 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#578, AVLTreeNode.balanceFactor] := Mask[r#578, AVLTreeNode.balanceFactor][perm$R := Mask[r#578, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#578, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume (Heap[r#578, AVLTreeNode.height] == callHeap#_1970[callHeap#_1970[this#577, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#578, AVLTreeNode.height] == (callHeap#_1970[callHeap#_1970[this#577, AVLTreeNode.left], AVLTreeNode.height] + 1));
    assume Seq#Equal(Heap[r#578, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_1970[callHeap#_1970[this#577, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_1970[this#577, AVLTreeNode.key])), ite(callHeap#_1970[this#577, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1970[callHeap#_1970[this#577, AVLTreeNode.right], AVLTreeNode.keys])));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    r#63 := r#578;
  }
  // begin exhale (postcondition)
  exhaleMask#_2090 := Mask;
  havoc exhaleHeap#_2089;
  assert {:msg "  599.2: The postcondition at 623.11 might not hold. The expression at 623.11 might not evaluate to true."} !(r#63 == null);
  assert {:msg "  599.2: The postcondition at 629.11 might not hold. The expression at 629.11 might not evaluate to true."} (Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#63, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height] + 1));
  assert {:msg "  599.2: The postcondition at 630.11 might not hold. The expression at 630.11 might not evaluate to true."} Seq#Equal(Heap[r#63, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  599.2: The postcondition at 624.11 might not hold. The permission at 624.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  599.2: The postcondition at 624.11 might not hold. Insufficient fraction at 624.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2090[r#63, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2090[r#63, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2090[r#63, AVLTreeNode.valid][perm$N]));
  exhaleMask#_2090[r#63, AVLTreeNode.valid] := exhaleMask#_2090[r#63, AVLTreeNode.valid][perm$R := exhaleMask#_2090[r#63, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if ((false || ((predVer#_1783 == Heap[r#63, AVLTreeNode.valid]) && (predRec#_1782 == r#63) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[r#63, AVLTreeNode.valid]) && (predRec#_1763 == r#63) && true && predFlag#_1765)) {
    if ((predVer#_1764 == Heap[r#63, AVLTreeNode.valid]) && (predRec#_1763 == r#63) && true && predFlag#_1765) {
    } else {
    }
    // begin exhale (update SecMask)
    if (!(Heap[r#63, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#607: int :: (0 <= lk#79#607) && (lk#79#607 < Seq#Length(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys], lk#79#607) < Heap[r#63, AVLTreeNode.key]));
    }
    if (!(Heap[r#63, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[r#63, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#608: int :: (0 <= rk#80#608) && (rk#80#608 < Seq#Length(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#63, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys], rk#80#608)));
    }
    if (!(Heap[r#63, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[r#63, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#63, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#63, AVLTreeNode.key])), ite(Heap[r#63, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[r#63, AVLTreeNode.keys], Heap[r#63, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[r#63, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#63, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#63, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#63, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[r#63, AVLTreeNode.height] == ite(ite(Heap[r#63, AVLTreeNode.left] == null, 0, Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#63, AVLTreeNode.right] == null, 0, Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#63, AVLTreeNode.left] == null, 0, Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#63, AVLTreeNode.right] == null, 0, Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[r#63, AVLTreeNode.balanceFactor] == (ite(Heap[r#63, AVLTreeNode.left] == null, 0, Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#63, AVLTreeNode.right] == null, 0, Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[r#63, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[r#63, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[r#63, AVLTreeNode.height] > 0;
    SecMask[r#63, AVLTreeNode.key] := SecMask[r#63, AVLTreeNode.key][perm$R := SecMask[r#63, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[r#63, AVLTreeNode.key][perm$R] < 0) {
      SecMask[r#63, AVLTreeNode.key] := SecMask[r#63, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#63, AVLTreeNode.height] := SecMask[r#63, AVLTreeNode.height][perm$R := SecMask[r#63, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[r#63, AVLTreeNode.height][perm$R] < 0) {
      SecMask[r#63, AVLTreeNode.height] := SecMask[r#63, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#63, AVLTreeNode.left] := SecMask[r#63, AVLTreeNode.left][perm$R := SecMask[r#63, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[r#63, AVLTreeNode.left][perm$R] < 0) {
      SecMask[r#63, AVLTreeNode.left] := SecMask[r#63, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#63, AVLTreeNode.right] := SecMask[r#63, AVLTreeNode.right][perm$R := SecMask[r#63, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[r#63, AVLTreeNode.right][perm$R] < 0) {
      SecMask[r#63, AVLTreeNode.right] := SecMask[r#63, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#63, AVLTreeNode.keys] := SecMask[r#63, AVLTreeNode.keys][perm$R := SecMask[r#63, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[r#63, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[r#63, AVLTreeNode.keys] := SecMask[r#63, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#63, AVLTreeNode.balanceFactor] := SecMask[r#63, AVLTreeNode.balanceFactor][perm$R := SecMask[r#63, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[r#63, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[r#63, AVLTreeNode.balanceFactor] := SecMask[r#63, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[r#63, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume Heap[r#63, AVLTreeNode.left] != r#63;
      if ((false || ((predVer#_1783 == Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1782 == Heap[r#63, AVLTreeNode.left]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[r#63, AVLTreeNode.left]) && true && predFlag#_1765)) {
        if ((predVer#_1764 == Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_1763 == Heap[r#63, AVLTreeNode.left]) && true && predFlag#_1765) {
        } else {
        }
        // begin exhale (update SecMask)
        if (!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
          assume (forall lk#79#611: int :: (0 <= lk#79#611) && (lk#79#611 < Seq#Length(Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#611) < Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.key]));
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
          assume Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
          assume (forall rk#80#612: int :: (0 <= rk#80#612) && (rk#80#612 < Seq#Length(Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#612)));
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
          assume Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
        assume Seq#Equal(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
        //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
        assume Seq#Contains(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.key]);
        //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
        assume (forall kk#81: int :: Seq#Contains(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.key])));
        //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
        assume Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
        assume Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
        //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
        assume Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
        //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
        assume Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
        //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
        assume Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height] > 0;
        SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
        if (SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
          SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
        if (SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
          SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
        if (SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
          SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#63, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume wf(Heap, SecMask, SecMask);
        // end exhale
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#63, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#63, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#63, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#63, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#63, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume Heap[r#63, AVLTreeNode.right] != r#63;
      if ((false || ((predVer#_1783 == Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1782 == Heap[r#63, AVLTreeNode.right]) && true && predFlag#_1784)) || ((predVer#_1764 == Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[r#63, AVLTreeNode.right]) && true && predFlag#_1765)) {
        if ((predVer#_1764 == Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_1763 == Heap[r#63, AVLTreeNode.right]) && true && predFlag#_1765) {
        } else {
        }
        // begin exhale (update SecMask)
        if (!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
          assume (forall lk#79#615: int :: (0 <= lk#79#615) && (lk#79#615 < Seq#Length(Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#615) < Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.key]));
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
          assume Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
          assume (forall rk#80#616: int :: (0 <= rk#80#616) && (rk#80#616 < Seq#Length(Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#616)));
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
          assume Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
        assume Seq#Equal(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
        //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
        assume Seq#Contains(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.key]);
        //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
        assume (forall kk#81: int :: Seq#Contains(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.key])));
        //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
        assume Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
        assume Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
        //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
        assume Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
        //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
        assume Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
        //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
        assume Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height] > 0;
        SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
        if (SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
          SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
        if (SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
          SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
        if (SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
          SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#63, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume wf(Heap, SecMask, SecMask);
        // end exhale
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#63, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#63, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#63, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#63, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(exhaleMask#_2090, SecMask, r#63, AVLTreeNode.valid)) {
    assume Heap[r#63, AVLTreeNode.valid] < exhaleHeap#_2089[r#63, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_2090);
  assume wf(Heap, exhaleMask#_2090, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  599.2: The postcondition at 625.11 might not hold. The permission at 625.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  599.2: The postcondition at 625.11 might not hold. Insufficient fraction at 625.11 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2090[r#63, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2090[r#63, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2090[r#63, AVLTreeNode.height][perm$N]));
  exhaleMask#_2090[r#63, AVLTreeNode.height] := exhaleMask#_2090[r#63, AVLTreeNode.height][perm$R := exhaleMask#_2090[r#63, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_2090);
  assume wf(Heap, exhaleMask#_2090, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  599.2: The postcondition at 626.11 might not hold. The permission at 626.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  599.2: The postcondition at 626.11 might not hold. Insufficient fraction at 626.11 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2090[r#63, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2090[r#63, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2090[r#63, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2090[r#63, AVLTreeNode.keys] := exhaleMask#_2090[r#63, AVLTreeNode.keys][perm$R := exhaleMask#_2090[r#63, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_2090);
  assume wf(Heap, exhaleMask#_2090, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  599.2: The postcondition at 627.11 might not hold. The permission at 627.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  599.2: The postcondition at 627.11 might not hold. Insufficient fraction at 627.11 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2090[r#63, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2090[r#63, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2090[r#63, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2090[r#63, AVLTreeNode.balanceFactor] := exhaleMask#_2090[r#63, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2090[r#63, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_2090);
  assume wf(Heap, exhaleMask#_2090, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_2090;
  assume IsGoodExhaleState(exhaleHeap#_2089, Heap, Mask, SecMask);
  Heap := exhaleHeap#_2089;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  599.2: Method might lock/unlock more than allowed."} (forall lk#_2143: ref :: {Heap[lk#_2143, held]} {Heap[lk#_2143, rdheld]} (((0 < Heap[lk#_2143, held]) == (0 < old(Heap)[lk#_2143, held])) && (Heap[lk#_2143, rdheld] == old(Heap)[lk#_2143, rdheld])) || false);
  assert {:msg "  599.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceRL$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#66: ref where (r#66 == null) || (dtype(r#66) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2144: int;
  var k#96#620: int where true;
  var k#97#622: int where true;
  var predRec#_2145: ref;
  var predFlag#_2147: bool;
  var predVer#_2146: int;
  var unfoldingK#_2153: int;
  var predFlag#_2152: bool;
  var unfoldingHeap#_2148: HeapType;
  var unfoldingMask#_2149: MaskType;
  var unfoldingSecMask#_2150: MaskType;
  var unfoldingCredits#_2151: CreditsType;
  var oldVers#_2173: int;
  var newVers#_2174: int;
  assume (0 < methodK#_2144) && ((1000 * methodK#_2144) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  652.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  652.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assert {:msg "  653.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  653.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  653.12: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
  assert {:msg "  653.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  653.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  654.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  654.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  655.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  655.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  656.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  656.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  657.12: Receiver might be null."} true && (0 <= k#96#620) ==> (this != null);
  assert {:msg "  657.12: Location might not be readable."} true && (0 <= k#96#620) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  657.12: Receiver might be null."} true && (0 <= k#96#620) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  657.12: Location might not be readable."} true && (0 <= k#96#620) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  657.12: Receiver might be null."} true && (0 <= k#96#620) && (k#96#620 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  657.12: Location might not be readable."} true && (0 <= k#96#620) && (k#96#620 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  657.12: Receiver might be null."} true && (0 <= k#96#620) && (k#96#620 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  657.12: Location might not be readable."} true && (0 <= k#96#620) && (k#96#620 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  657.37: Sequence index might be negative."} true && (0 <= k#96#620) && (k#96#620 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#96#620);
  assert {:msg "  657.37: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#96#620) && (k#96#620 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#96#620 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assert {:msg "  657.41: Receiver might be null."} true && (0 <= k#96#620) && (k#96#620 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  657.41: Location might not be readable."} true && (0 <= k#96#620) && (k#96#620 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  assume (forall k#96#619: int :: (0 <= k#96#619) && (k#96#619 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#96#619) < Heap[this, AVLTreeNode.key]));
  assert {:msg "  659.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  659.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  659.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  659.28: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  659.28: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  659.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  659.28: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  660.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  660.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  660.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  660.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  661.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  661.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  661.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  661.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  662.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  662.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  662.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  662.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  663.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  663.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  663.12: Receiver might be null."} true && (0 <= k#97#622) ==> (this != null);
    assert {:msg "  663.12: Location might not be readable."} true && (0 <= k#97#622) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  663.12: Receiver might be null."} true && (0 <= k#97#622) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  663.12: Location might not be readable."} true && (0 <= k#97#622) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  663.54: Receiver might be null."} true && (0 <= k#97#622) && (k#97#622 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  663.54: Location might not be readable."} true && (0 <= k#97#622) && (k#97#622 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    assert {:msg "  663.12: Receiver might be null."} true && (0 <= k#97#622) && (k#97#622 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  663.12: Location might not be readable."} true && (0 <= k#97#622) && (k#97#622 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  663.12: Receiver might be null."} true && (0 <= k#97#622) && (k#97#622 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  663.12: Location might not be readable."} true && (0 <= k#97#622) && (k#97#622 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  663.60: Sequence index might be negative."} true && (0 <= k#97#622) && (k#97#622 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#97#622);
    assert {:msg "  663.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#97#622) && (k#97#622 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#97#622 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall k#97#621: int :: (0 <= k#97#621) && (k#97#621 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#97#621)));
  }
  predRec#_2145 := Heap[this, AVLTreeNode.left];
  predFlag#_2147 := true;
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.left]);
  predVer#_2146 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  // unfolding
  assume (0 < unfoldingK#_2153) && ((1000 * unfoldingK#_2153) < Fractions(1));
  predFlag#_2152 := true;
  assert {:msg "  665.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  665.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  665.22: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  unfoldingHeap#_2148 := Heap;
  unfoldingMask#_2149 := Mask;
  unfoldingSecMask#_2150 := SecMask;
  unfoldingCredits#_2151 := Credits;
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  // begin exhale (unfolding)
  assert {:msg "  665.12: Unfolding might fail. The permission at 665.22 might not be positive."} Fractions(100) > 0;
  assert {:msg "  665.12: Unfolding might fail. Insufficient fraction at 665.22 for AVLTreeNode.valid."} (Fractions(100) <= unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
  unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#623: int :: (0 <= lk#79#623) && (lk#79#623 < Seq#Length(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#623) < unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key]));
    }
    if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#624: int :: (0 <= rk#80#624) && (rk#80#624 < Seq#Length(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#624)));
    }
    if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
    if (unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
    }
    assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    if (unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
    }
    assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
    if (unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
    }
    assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
    if (unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
    }
    assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2150[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
      assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    }
    if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
      assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    }
    if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
      assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    }
    if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
      assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    }
    if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
      assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    }
    if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
      assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    }
    if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
      assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    }
    if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2150[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
      assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    }
    assume wf(unfoldingHeap#_2148, unfoldingSecMask#_2150, unfoldingSecMask#_2150);
    // end exhale
  }
  if (!CanRead(unfoldingMask#_2149, unfoldingSecMask#_2150, unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.valid)) {
    oldVers#_2173 := unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.valid];
    havoc newVers#_2174;
    unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_2174;
    assume oldVers#_2173 < unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.valid];
  }
  assume IsGoodMask(unfoldingMask#_2149);
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume IsGoodMask(unfoldingMask#_2149);
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  // end exhale
  // inhale (unfolding)
  assume unfoldingHeap#_2148[this, AVLTreeNode.left] != null;
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume true;
  assume Fractions(100) > 0;
  unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(unfoldingMask#_2149);
  assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key]));
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume unfoldingHeap#_2148[this, AVLTreeNode.left] != null;
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume true;
  assume Fractions(50) > 0;
  unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(unfoldingMask#_2149);
  assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height]));
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume unfoldingHeap#_2148[this, AVLTreeNode.left] != null;
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume (unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(unfoldingMask#_2149);
  assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left]));
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume unfoldingHeap#_2148[this, AVLTreeNode.left] != null;
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume (unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(unfoldingMask#_2149);
  assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right]));
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume unfoldingHeap#_2148[this, AVLTreeNode.left] != null;
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume true;
  assume Fractions(50) > 0;
  unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(unfoldingMask#_2149);
  assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume unfoldingHeap#_2148[this, AVLTreeNode.left] != null;
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume true;
  assume Fractions(50) > 0;
  unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(unfoldingMask#_2149);
  assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume Fractions(100) > 0;
    unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_2149);
    assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  }
  if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2149);
    assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  }
  if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2149);
    assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  }
  if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2149);
    assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  }
  if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume (forall lk#79#627: int :: (0 <= lk#79#627) && (lk#79#627 < Seq#Length(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#627) < unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key]));
  }
  if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume Fractions(100) > 0;
    unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_2149);
    assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  }
  if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2149);
    assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  }
  if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2149);
    assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  }
  if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2149[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2149);
    assume IsGoodState(heapFragment(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
    assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  }
  if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume (forall rk#80#628: int :: (0 <= rk#80#628) && (rk#80#628 < Seq#Length(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#628)));
  }
  if (!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.key])));
  assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_2148[unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
  assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
  assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume unfoldingHeap#_2148[unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  assume IsGoodMask(unfoldingMask#_2149);
  assume wf(unfoldingHeap#_2148, unfoldingMask#_2149, unfoldingSecMask#_2150);
  // end inhale
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#629: int :: (0 <= lk#79#629) && (lk#79#629 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#629) < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]));
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#630: int :: (0 <= rk#80#630) && (rk#80#630 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#630)));
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume (forall lk#79#633: int :: (0 <= lk#79#633) && (lk#79#633 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#633) < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]));
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume (forall rk#80#634: int :: (0 <= rk#80#634) && (rk#80#634 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#634)));
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])));
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  assert {:msg "  665.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  665.36: Location might not be readable."} true ==> CanRead(unfoldingMask#_2149, unfoldingSecMask#_2150, this, AVLTreeNode.left);
  assert {:msg "  665.36: Receiver might be null."} true ==> (unfoldingHeap#_2148[this, AVLTreeNode.left] != null);
  assert {:msg "  665.36: Location might not be readable."} true ==> CanRead(unfoldingMask#_2149, unfoldingSecMask#_2150, unfoldingHeap#_2148[this, AVLTreeNode.left], AVLTreeNode.right);
  assume !(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null);
  assert {:msg "  667.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  667.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  667.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  667.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  667.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  667.25: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  667.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  667.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  667.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  667.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assert {:msg "  668.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  668.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  668.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  668.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (0 - 1);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#66 == null);
  assert {:msg "  671.11: Receiver might be null."} r#66 != null;
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[r#66, AVLTreeNode.valid] := Mask[r#66, AVLTreeNode.valid][perm$R := Mask[r#66, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#66, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#66, AVLTreeNode.height] := Mask[r#66, AVLTreeNode.height][perm$R := Mask[r#66, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#66, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#66, AVLTreeNode.keys] := Mask[r#66, AVLTreeNode.keys][perm$R := Mask[r#66, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#66, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#66, AVLTreeNode.balanceFactor] := Mask[r#66, AVLTreeNode.balanceFactor][perm$R := Mask[r#66, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#66, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  676.11: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  676.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#66, AVLTreeNode.height);
  assert {:msg "  676.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  676.27: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  assert {:msg "  676.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  676.27: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assume Heap[r#66, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height];
  assert {:msg "  677.11: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  677.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#66, AVLTreeNode.keys);
  assert {:msg "  677.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  677.25: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  assert {:msg "  677.25: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  677.25: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  677.44: Receiver might be null."} true ==> (this != null);
  assert {:msg "  677.44: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.key);
  assert {:msg "  677.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  677.59: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  677.89: Receiver might be null."} true ==> (this != null);
    assert {:msg "  677.89: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
    assert {:msg "  677.89: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  677.89: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[r#66, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.rebalanceRL(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#66: ref where (r#66 == null) || (dtype(r#66) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2144: int;
  var predRec#_2191: ref;
  var predFlag#_2193: bool;
  var predVer#_2192: int;
  var assertHeap#_2210: HeapType;
  var assertMask#_2211: MaskType;
  var assertSecMask#_2212: MaskType;
  var assertCredits#_2213: CreditsType;
  var exhaleMask#_2215: MaskType;
  var exhaleHeap#_2214: HeapType;
  var k#98#644: int where true;
  var unfoldK#_2216: int;
  var oldVers#_2236: int;
  var newVers#_2237: int;
  var assertHeap#_2238: HeapType;
  var assertMask#_2239: MaskType;
  var assertSecMask#_2240: MaskType;
  var assertCredits#_2241: CreditsType;
  var exhaleMask#_2243: MaskType;
  var exhaleHeap#_2242: HeapType;
  var k#99#653: int where true;
  var unfoldK#_2244: int;
  var oldVers#_2264: int;
  var newVers#_2265: int;
  var assertHeap#_2266: HeapType;
  var assertMask#_2267: MaskType;
  var assertSecMask#_2268: MaskType;
  var assertCredits#_2269: CreditsType;
  var exhaleMask#_2271: MaskType;
  var exhaleHeap#_2270: HeapType;
  var k#100#662: int where true;
  var methodCallK#_2276: int;
  var this#664: ref where (this#664 == null) || (dtype(this#664) == AVLTreeNode#t);
  var callHeap#_2272: HeapType;
  var callMask#_2273: MaskType;
  var callSecMask#_2274: MaskType;
  var callCredits#_2275: CreditsType;
  var exhaleMask#_2278: MaskType;
  var exhaleHeap#_2277: HeapType;
  var isHeld#_2325: int;
  var isRdHeld#_2326: bool;
  var assertHeap#_2327: HeapType;
  var assertMask#_2328: MaskType;
  var assertSecMask#_2329: MaskType;
  var assertCredits#_2330: CreditsType;
  var exhaleMask#_2332: MaskType;
  var exhaleHeap#_2331: HeapType;
  var k#101#678: int where true;
  var methodCallK#_2337: int;
  var this#680: ref where (this#680 == null) || (dtype(this#680) == AVLTreeNode#t);
  var callHeap#_2333: HeapType;
  var callMask#_2334: MaskType;
  var callSecMask#_2335: MaskType;
  var callCredits#_2336: CreditsType;
  var exhaleMask#_2339: MaskType;
  var exhaleHeap#_2338: HeapType;
  var isHeld#_2386: int;
  var isRdHeld#_2387: bool;
  var methodCallK#_2392: int;
  var this#693: ref where (this#693 == null) || (dtype(this#693) == AVLTreeNode#t);
  var callHeap#_2388: HeapType;
  var callMask#_2389: MaskType;
  var callSecMask#_2390: MaskType;
  var callCredits#_2391: CreditsType;
  var exhaleMask#_2394: MaskType;
  var exhaleHeap#_2393: HeapType;
  var isHeld#_2441: int;
  var isRdHeld#_2442: bool;
  var exhaleMask#_2444: MaskType;
  var exhaleHeap#_2443: HeapType;
  assume (0 < methodK#_2144) && ((1000 * methodK#_2144) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume (forall k#96#635: int :: (0 <= k#96#635) && (k#96#635 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#96#635) < Heap[this, AVLTreeNode.key]));
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall k#97#636: int :: (0 <= k#97#636) && (k#97#636 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#97#636)));
  }
  predRec#_2191 := Heap[this, AVLTreeNode.left];
  predFlag#_2193 := true;
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.left]);
  predVer#_2192 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#637: int :: (0 <= lk#79#637) && (lk#79#637 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#637) < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]));
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#638: int :: (0 <= rk#80#638) && (rk#80#638 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#638)));
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  assume predRec#_2191 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  SecMask[predRec#_2191, AVLTreeNode.key] := SecMask[predRec#_2191, AVLTreeNode.key][perm$R := SecMask[predRec#_2191, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2191, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2191 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_2191, AVLTreeNode.height] := SecMask[predRec#_2191, AVLTreeNode.height][perm$R := SecMask[predRec#_2191, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2191, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2191 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2191, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_2191, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[predRec#_2191, AVLTreeNode.left] := SecMask[predRec#_2191, AVLTreeNode.left][perm$R := SecMask[predRec#_2191, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2191, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2191 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2191, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_2191, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[predRec#_2191, AVLTreeNode.right] := SecMask[predRec#_2191, AVLTreeNode.right][perm$R := SecMask[predRec#_2191, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2191, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2191 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_2191, AVLTreeNode.keys] := SecMask[predRec#_2191, AVLTreeNode.keys][perm$R := SecMask[predRec#_2191, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2191, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2191 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_2191, AVLTreeNode.balanceFactor] := SecMask[predRec#_2191, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_2191, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2191, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_2191, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2191, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2191, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2191, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2191, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2191, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2191, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2191, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2191, AVLTreeNode.left] == null)) {
    assume (forall lk#79#641: int :: (0 <= lk#79#641) && (lk#79#641 < Seq#Length(Heap[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.keys], lk#79#641) < Heap[predRec#_2191, AVLTreeNode.key]));
  }
  if (!(Heap[predRec#_2191, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_2191, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2191, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2191, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2191, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2191, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2191, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2191, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2191, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2191, AVLTreeNode.right] == null)) {
    assume (forall rk#80#642: int :: (0 <= rk#80#642) && (rk#80#642 < Seq#Length(Heap[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_2191, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.keys], rk#80#642)));
  }
  if (!(Heap[predRec#_2191, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_2191, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_2191, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_2191, AVLTreeNode.key])), ite(Heap[predRec#_2191, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_2191, AVLTreeNode.keys], Heap[predRec#_2191, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[predRec#_2191, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_2191, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_2191, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_2191, AVLTreeNode.key])));
  assume Heap[predRec#_2191, AVLTreeNode.height] == ite(ite(Heap[predRec#_2191, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_2191, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_2191, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_2191, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_2191, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_2191, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2191, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_2191, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2191, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_2191, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_2191, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_2191, AVLTreeNode.height] > 0;
  assume !(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (0 - 1);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // assert
  assertHeap#_2210 := Heap;
  assertMask#_2211 := Mask;
  assertSecMask#_2212 := SecMask;
  assertCredits#_2213 := Credits;
  assume wf(assertHeap#_2210, assertMask#_2211, assertSecMask#_2212);
  // begin exhale (assert)
  exhaleMask#_2215 := assertMask#_2211;
  havoc exhaleHeap#_2214;
  assert {:msg "  679.10: Receiver might be null."} true && (0 <= k#98#644) ==> (this != null);
  assert {:msg "  679.10: Location might not be readable."} true && (0 <= k#98#644) ==> CanRead(assertMask#_2211, assertSecMask#_2212, this, AVLTreeNode.left);
  assert {:msg "  679.10: Receiver might be null."} true && (0 <= k#98#644) ==> (assertHeap#_2210[this, AVLTreeNode.left] != null);
  assert {:msg "  679.10: Location might not be readable."} true && (0 <= k#98#644) ==> CanRead(assertMask#_2211, assertSecMask#_2212, assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  679.10: Receiver might be null."} true && (0 <= k#98#644) && (k#98#644 < Seq#Length(assertHeap#_2210[assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  679.10: Location might not be readable."} true && (0 <= k#98#644) && (k#98#644 < Seq#Length(assertHeap#_2210[assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_2211, assertSecMask#_2212, this, AVLTreeNode.left);
  assert {:msg "  679.10: Receiver might be null."} true && (0 <= k#98#644) && (k#98#644 < Seq#Length(assertHeap#_2210[assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (assertHeap#_2210[this, AVLTreeNode.left] != null);
  assert {:msg "  679.10: Location might not be readable."} true && (0 <= k#98#644) && (k#98#644 < Seq#Length(assertHeap#_2210[assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_2211, assertSecMask#_2212, assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  679.35: Sequence index might be negative."} true && (0 <= k#98#644) && (k#98#644 < Seq#Length(assertHeap#_2210[assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#98#644);
  assert {:msg "  679.35: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#98#644) && (k#98#644 < Seq#Length(assertHeap#_2210[assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#98#644 < Seq#Length(assertHeap#_2210[assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assert {:msg "  679.39: Receiver might be null."} true && (0 <= k#98#644) && (k#98#644 < Seq#Length(assertHeap#_2210[assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  679.39: Location might not be readable."} true && (0 <= k#98#644) && (k#98#644 < Seq#Length(assertHeap#_2210[assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_2211, assertSecMask#_2212, this, AVLTreeNode.key);
  assert {:msg "  679.3: Assertion might not hold. The expression at 679.10 might not evaluate to true."} (forall k#98#643: int :: (0 <= k#98#643) && (k#98#643 < Seq#Length(assertHeap#_2210[assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_2210[assertHeap#_2210[this, AVLTreeNode.left], AVLTreeNode.keys], k#98#643) < assertHeap#_2210[this, AVLTreeNode.key]));
  assertMask#_2211 := exhaleMask#_2215;
  assume IsGoodExhaleState(exhaleHeap#_2214, assertHeap#_2210, assertMask#_2211, assertSecMask#_2212);
  assertHeap#_2210 := exhaleHeap#_2214;
  assume IsGoodMask(assertMask#_2211);
  assume wf(assertHeap#_2210, assertMask#_2211, assertSecMask#_2212);
  // end exhale
  // unfold
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.left]);
  assume (0 < unfoldK#_2216) && (unfoldK#_2216 < Fractions(1)) && ((1000 * unfoldK#_2216) < methodK#_2144);
  assert {:msg "  680.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  680.10: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  680.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.left] != null;
  // begin exhale (unfold)
  assert {:msg "  680.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  680.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_2192 == Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2191 == Heap[this, AVLTreeNode.left]) && true && predFlag#_2193)) {
    // begin exhale (update SecMask)
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#646: int :: (0 <= lk#79#646) && (lk#79#646 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#646) < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]));
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#647: int :: (0 <= rk#80#647) && (rk#80#647 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#647)));
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.valid)) {
    oldVers#_2236 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    havoc newVers#_2237;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_2237;
    assume oldVers#_2236 < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume (forall lk#79#650: int :: (0 <= lk#79#650) && (lk#79#650 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#650) < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]));
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume (forall rk#80#651: int :: (0 <= rk#80#651) && (rk#80#651 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#651)));
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])));
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // assigment to r
  assert {:msg "  681.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  681.8: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  681.8: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  681.8: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.right);
  r#66 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right];
  // assert
  assertHeap#_2238 := Heap;
  assertMask#_2239 := Mask;
  assertSecMask#_2240 := SecMask;
  assertCredits#_2241 := Credits;
  assume wf(assertHeap#_2238, assertMask#_2239, assertSecMask#_2240);
  // begin exhale (assert)
  exhaleMask#_2243 := assertMask#_2239;
  havoc exhaleHeap#_2242;
  assert {:msg "  682.10: Receiver might be null."} true && (0 <= k#99#653) ==> (r#66 != null);
  assert {:msg "  682.10: Location might not be readable."} true && (0 <= k#99#653) ==> CanRead(assertMask#_2239, assertSecMask#_2240, r#66, AVLTreeNode.keys);
  assert {:msg "  682.10: Receiver might be null."} true && (0 <= k#99#653) && (k#99#653 < Seq#Length(assertHeap#_2238[r#66, AVLTreeNode.keys])) ==> (r#66 != null);
  assert {:msg "  682.10: Location might not be readable."} true && (0 <= k#99#653) && (k#99#653 < Seq#Length(assertHeap#_2238[r#66, AVLTreeNode.keys])) ==> CanRead(assertMask#_2239, assertSecMask#_2240, r#66, AVLTreeNode.keys);
  assert {:msg "  682.32: Sequence index might be negative."} true && (0 <= k#99#653) && (k#99#653 < Seq#Length(assertHeap#_2238[r#66, AVLTreeNode.keys])) ==> (0 <= k#99#653);
  assert {:msg "  682.32: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#99#653) && (k#99#653 < Seq#Length(assertHeap#_2238[r#66, AVLTreeNode.keys])) ==> (k#99#653 < Seq#Length(assertHeap#_2238[r#66, AVLTreeNode.keys]));
  assert {:msg "  682.36: Receiver might be null."} true && (0 <= k#99#653) && (k#99#653 < Seq#Length(assertHeap#_2238[r#66, AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  682.36: Location might not be readable."} true && (0 <= k#99#653) && (k#99#653 < Seq#Length(assertHeap#_2238[r#66, AVLTreeNode.keys])) ==> CanRead(assertMask#_2239, assertSecMask#_2240, this, AVLTreeNode.key);
  assert {:msg "  682.3: Assertion might not hold. The expression at 682.10 might not evaluate to true."} (forall k#99#652: int :: (0 <= k#99#652) && (k#99#652 < Seq#Length(assertHeap#_2238[r#66, AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_2238[r#66, AVLTreeNode.keys], k#99#652) < assertHeap#_2238[this, AVLTreeNode.key]));
  assertMask#_2239 := exhaleMask#_2243;
  assume IsGoodExhaleState(exhaleHeap#_2242, assertHeap#_2238, assertMask#_2239, assertSecMask#_2240);
  assertHeap#_2238 := exhaleHeap#_2242;
  assume IsGoodMask(assertMask#_2239);
  assume wf(assertHeap#_2238, assertMask#_2239, assertSecMask#_2240);
  // end exhale
  // unfold
  assume #AVLTreeNode.valid#trigger(r#66);
  assume (0 < unfoldK#_2244) && (unfoldK#_2244 < Fractions(1)) && ((1000 * unfoldK#_2244) < methodK#_2144);
  assert {:msg "  683.3: The target of the fold statement might be null."} r#66 != null;
  // begin exhale (unfold)
  assert {:msg "  683.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  683.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[r#66, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[r#66, AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[r#66, AVLTreeNode.valid][perm$N]));
  Mask[r#66, AVLTreeNode.valid] := Mask[r#66, AVLTreeNode.valid][perm$R := Mask[r#66, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_2192 == Heap[r#66, AVLTreeNode.valid]) && (predRec#_2191 == r#66) && true && predFlag#_2193)) {
    // begin exhale (update SecMask)
    if (!(Heap[r#66, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#655: int :: (0 <= lk#79#655) && (lk#79#655 < Seq#Length(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys], lk#79#655) < Heap[r#66, AVLTreeNode.key]));
    }
    if (!(Heap[r#66, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[r#66, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#656: int :: (0 <= rk#80#656) && (rk#80#656 < Seq#Length(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#66, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys], rk#80#656)));
    }
    if (!(Heap[r#66, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[r#66, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#66, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#66, AVLTreeNode.key])), ite(Heap[r#66, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[r#66, AVLTreeNode.keys], Heap[r#66, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[r#66, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#66, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#66, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#66, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[r#66, AVLTreeNode.height] == ite(ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[r#66, AVLTreeNode.balanceFactor] == (ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[r#66, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[r#66, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[r#66, AVLTreeNode.height] > 0;
    SecMask[r#66, AVLTreeNode.key] := SecMask[r#66, AVLTreeNode.key][perm$R := SecMask[r#66, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[r#66, AVLTreeNode.key][perm$R] < 0) {
      SecMask[r#66, AVLTreeNode.key] := SecMask[r#66, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#66, AVLTreeNode.height] := SecMask[r#66, AVLTreeNode.height][perm$R := SecMask[r#66, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[r#66, AVLTreeNode.height][perm$R] < 0) {
      SecMask[r#66, AVLTreeNode.height] := SecMask[r#66, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#66, AVLTreeNode.left] := SecMask[r#66, AVLTreeNode.left][perm$R := SecMask[r#66, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[r#66, AVLTreeNode.left][perm$R] < 0) {
      SecMask[r#66, AVLTreeNode.left] := SecMask[r#66, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#66, AVLTreeNode.right] := SecMask[r#66, AVLTreeNode.right][perm$R := SecMask[r#66, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[r#66, AVLTreeNode.right][perm$R] < 0) {
      SecMask[r#66, AVLTreeNode.right] := SecMask[r#66, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#66, AVLTreeNode.keys] := SecMask[r#66, AVLTreeNode.keys][perm$R := SecMask[r#66, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[r#66, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[r#66, AVLTreeNode.keys] := SecMask[r#66, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#66, AVLTreeNode.balanceFactor] := SecMask[r#66, AVLTreeNode.balanceFactor][perm$R := SecMask[r#66, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[r#66, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[r#66, AVLTreeNode.balanceFactor] := SecMask[r#66, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[r#66, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, r#66, AVLTreeNode.valid)) {
    oldVers#_2264 := Heap[r#66, AVLTreeNode.valid];
    havoc newVers#_2265;
    Heap[r#66, AVLTreeNode.valid] := newVers#_2265;
    assume oldVers#_2264 < Heap[r#66, AVLTreeNode.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[r#66, AVLTreeNode.key] := Mask[r#66, AVLTreeNode.key][perm$R := Mask[r#66, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#66, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#66, AVLTreeNode.height] := Mask[r#66, AVLTreeNode.height][perm$R := Mask[r#66, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#66, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[r#66, AVLTreeNode.left] == null) || (dtype(Heap[r#66, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[r#66, AVLTreeNode.left] := Mask[r#66, AVLTreeNode.left][perm$R := Mask[r#66, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#66, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[r#66, AVLTreeNode.right] == null) || (dtype(Heap[r#66, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[r#66, AVLTreeNode.right] := Mask[r#66, AVLTreeNode.right][perm$R := Mask[r#66, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#66, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#66, AVLTreeNode.keys] := Mask[r#66, AVLTreeNode.keys][perm$R := Mask[r#66, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#66, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#66, AVLTreeNode.balanceFactor] := Mask[r#66, AVLTreeNode.balanceFactor][perm$R := Mask[r#66, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#66, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[r#66, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[r#66, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[r#66, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[r#66, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume (forall lk#79#659: int :: (0 <= lk#79#659) && (lk#79#659 < Seq#Length(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys], lk#79#659) < Heap[r#66, AVLTreeNode.key]));
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[r#66, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[r#66, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[r#66, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[r#66, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume (forall rk#80#660: int :: (0 <= rk#80#660) && (rk#80#660 < Seq#Length(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#66, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys], rk#80#660)));
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[r#66, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#66, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#66, AVLTreeNode.key])), ite(Heap[r#66, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[r#66, AVLTreeNode.keys], Heap[r#66, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[r#66, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#66, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#66, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#66, AVLTreeNode.key])));
  assume Heap[r#66, AVLTreeNode.height] == ite(ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[r#66, AVLTreeNode.balanceFactor] == (ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[r#66, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[r#66, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[r#66, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // assert
  assertHeap#_2266 := Heap;
  assertMask#_2267 := Mask;
  assertSecMask#_2268 := SecMask;
  assertCredits#_2269 := Credits;
  assume wf(assertHeap#_2266, assertMask#_2267, assertSecMask#_2268);
  // begin exhale (assert)
  exhaleMask#_2271 := assertMask#_2267;
  havoc exhaleHeap#_2270;
  assert {:msg "  685.10: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  685.10: Location might not be readable."} true ==> CanRead(assertMask#_2267, assertSecMask#_2268, r#66, AVLTreeNode.right);
  if (!(assertHeap#_2266[r#66, AVLTreeNode.right] == null)) {
    assert {:msg "  685.10: Receiver might be null."} true && (0 <= k#100#662) ==> (r#66 != null);
    assert {:msg "  685.10: Location might not be readable."} true && (0 <= k#100#662) ==> CanRead(assertMask#_2267, assertSecMask#_2268, r#66, AVLTreeNode.right);
    assert {:msg "  685.10: Receiver might be null."} true && (0 <= k#100#662) ==> (assertHeap#_2266[r#66, AVLTreeNode.right] != null);
    assert {:msg "  685.10: Location might not be readable."} true && (0 <= k#100#662) ==> CanRead(assertMask#_2267, assertSecMask#_2268, assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  685.10: Receiver might be null."} true && (0 <= k#100#662) && (k#100#662 < Seq#Length(assertHeap#_2266[assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (r#66 != null);
    assert {:msg "  685.10: Location might not be readable."} true && (0 <= k#100#662) && (k#100#662 < Seq#Length(assertHeap#_2266[assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_2267, assertSecMask#_2268, r#66, AVLTreeNode.right);
    assert {:msg "  685.10: Receiver might be null."} true && (0 <= k#100#662) && (k#100#662 < Seq#Length(assertHeap#_2266[assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_2266[r#66, AVLTreeNode.right] != null);
    assert {:msg "  685.10: Location might not be readable."} true && (0 <= k#100#662) && (k#100#662 < Seq#Length(assertHeap#_2266[assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_2267, assertSecMask#_2268, assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  685.56: Sequence index might be negative."} true && (0 <= k#100#662) && (k#100#662 < Seq#Length(assertHeap#_2266[assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#100#662);
    assert {:msg "  685.56: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#100#662) && (k#100#662 < Seq#Length(assertHeap#_2266[assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#100#662 < Seq#Length(assertHeap#_2266[assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys]));
    assert {:msg "  685.60: Receiver might be null."} true && (0 <= k#100#662) && (k#100#662 < Seq#Length(assertHeap#_2266[assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  685.60: Location might not be readable."} true && (0 <= k#100#662) && (k#100#662 < Seq#Length(assertHeap#_2266[assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_2267, assertSecMask#_2268, this, AVLTreeNode.key);
    assert {:msg "  685.3: Assertion might not hold. The expression at 685.28 might not evaluate to true."} (forall k#100#661: int :: (0 <= k#100#661) && (k#100#661 < Seq#Length(assertHeap#_2266[assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_2266[assertHeap#_2266[r#66, AVLTreeNode.right], AVLTreeNode.keys], k#100#661) < assertHeap#_2266[this, AVLTreeNode.key]));
  }
  assertMask#_2267 := exhaleMask#_2271;
  assume IsGoodExhaleState(exhaleHeap#_2270, assertHeap#_2266, assertMask#_2267, assertSecMask#_2268);
  assertHeap#_2266 := exhaleHeap#_2270;
  assume IsGoodMask(assertMask#_2267);
  assume wf(assertHeap#_2266, assertMask#_2267, assertSecMask#_2268);
  // end exhale
  // update field right
  assert {:msg "  687.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  687.3: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  687.3: Location might not be writable"} CanWrite(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.right);
  assert {:msg "  687.17: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  687.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#66, AVLTreeNode.left);
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := Heap[r#66, AVLTreeNode.left];
  assume wf(Heap, Mask, SecMask);
  assume (0 < methodCallK#_2276) && ((1000 * methodCallK#_2276) < Fractions(1)) && ((1000 * methodCallK#_2276) < methodK#_2144);
  // call close
  callHeap#_2272 := Heap;
  callMask#_2273 := Mask;
  callSecMask#_2274 := SecMask;
  callCredits#_2275 := Credits;
  assume wf(callHeap#_2272, callMask#_2273, callSecMask#_2274);
  assert {:msg "  688.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  688.8: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  688.3: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
  this#664 := Heap[this, AVLTreeNode.left];
  // begin exhale (precondition)
  exhaleMask#_2278 := Mask;
  havoc exhaleHeap#_2277;
  if (!(Heap[this#664, AVLTreeNode.left] == null)) {
    assert {:msg "  688.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#665: int :: (0 <= k#92#665) && (k#92#665 < Seq#Length(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys], k#92#665) < Heap[this#664, AVLTreeNode.key]));
  }
  if (!(Heap[this#664, AVLTreeNode.right] == null)) {
    assert {:msg "  688.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#666: int :: (0 <= k#93#666) && (k#93#666 < Seq#Length(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#664, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys], k#93#666)));
  }
  assert {:msg "  688.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#664, AVLTreeNode.left] == null, 0, Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#664, AVLTreeNode.right] == null, 0, Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  688.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#664, AVLTreeNode.left] == null, 0, Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#664, AVLTreeNode.right] == null, 0, Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  688.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  688.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_2278[this#664, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_2278[this#664, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_2278[this#664, AVLTreeNode.key][perm$N]));
  exhaleMask#_2278[this#664, AVLTreeNode.key] := exhaleMask#_2278[this#664, AVLTreeNode.key][perm$R := exhaleMask#_2278[this#664, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2278);
  assume wf(Heap, exhaleMask#_2278, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  688.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  688.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_2278[this#664, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_2278[this#664, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2278[this#664, AVLTreeNode.height][perm$N]));
  exhaleMask#_2278[this#664, AVLTreeNode.height] := exhaleMask#_2278[this#664, AVLTreeNode.height][perm$R := exhaleMask#_2278[this#664, AVLTreeNode.height][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2278);
  assume wf(Heap, exhaleMask#_2278, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  688.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  688.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_2278[this#664, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_2278[this#664, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_2278[this#664, AVLTreeNode.left][perm$N]));
  exhaleMask#_2278[this#664, AVLTreeNode.left] := exhaleMask#_2278[this#664, AVLTreeNode.left][perm$R := exhaleMask#_2278[this#664, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2278);
  assume wf(Heap, exhaleMask#_2278, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  688.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  688.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_2278[this#664, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_2278[this#664, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_2278[this#664, AVLTreeNode.right][perm$N]));
  exhaleMask#_2278[this#664, AVLTreeNode.right] := exhaleMask#_2278[this#664, AVLTreeNode.right][perm$R := exhaleMask#_2278[this#664, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2278);
  assume wf(Heap, exhaleMask#_2278, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  688.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  688.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_2278[this#664, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_2278[this#664, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2278[this#664, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2278[this#664, AVLTreeNode.keys] := exhaleMask#_2278[this#664, AVLTreeNode.keys][perm$R := exhaleMask#_2278[this#664, AVLTreeNode.keys][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2278);
  assume wf(Heap, exhaleMask#_2278, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  688.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  688.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_2278[this#664, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_2278[this#664, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2278[this#664, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2278[this#664, AVLTreeNode.balanceFactor] := exhaleMask#_2278[this#664, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2278[this#664, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2278);
  assume wf(Heap, exhaleMask#_2278, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#664, AVLTreeNode.left] == null)) {
    assert {:msg "  688.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
    assert {:msg "  688.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false || ((predVer#_2192 == Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2191 == Heap[this#664, AVLTreeNode.left]) && true && predFlag#_2193)) {
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#667: int :: (0 <= lk#79#667) && (lk#79#667 < Seq#Length(Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#667) < Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#668: int :: (0 <= rk#80#668) && (rk#80#668 < Seq#Length(Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#668)));
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height] > 0;
      SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_2278, SecMask, Heap[this#664, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#664, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2277[Heap[this#664, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_2278);
    assume wf(Heap, exhaleMask#_2278, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#664, AVLTreeNode.left] == null)) {
    assert {:msg "  688.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  688.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2278);
    assume wf(Heap, exhaleMask#_2278, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#664, AVLTreeNode.left] == null)) {
    assert {:msg "  688.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  688.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2278);
    assume wf(Heap, exhaleMask#_2278, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#664, AVLTreeNode.left] == null)) {
    assert {:msg "  688.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  688.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2278[Heap[this#664, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2278);
    assume wf(Heap, exhaleMask#_2278, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#664, AVLTreeNode.right] == null)) {
    assert {:msg "  688.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
    assert {:msg "  688.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false || ((predVer#_2192 == Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2191 == Heap[this#664, AVLTreeNode.right]) && true && predFlag#_2193)) {
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#672: int :: (0 <= lk#79#672) && (lk#79#672 < Seq#Length(Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#672) < Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#673: int :: (0 <= rk#80#673) && (rk#80#673 < Seq#Length(Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#673)));
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height] > 0;
      SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_2278, SecMask, Heap[this#664, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#664, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2277[Heap[this#664, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_2278);
    assume wf(Heap, exhaleMask#_2278, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#664, AVLTreeNode.right] == null)) {
    assert {:msg "  688.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  688.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2278);
    assume wf(Heap, exhaleMask#_2278, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#664, AVLTreeNode.right] == null)) {
    assert {:msg "  688.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  688.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2278);
    assume wf(Heap, exhaleMask#_2278, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#664, AVLTreeNode.right] == null)) {
    assert {:msg "  688.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  688.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2278[Heap[this#664, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2278);
    assume wf(Heap, exhaleMask#_2278, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_2278;
  assume IsGoodExhaleState(exhaleHeap#_2277, Heap, Mask, SecMask);
  Heap := exhaleHeap#_2277;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#664 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#664, AVLTreeNode.valid] := Mask[this#664, AVLTreeNode.valid][perm$R := Mask[this#664, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#664, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#664 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#664, AVLTreeNode.height] := Mask[this#664, AVLTreeNode.height][perm$R := Mask[this#664, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#664, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#664 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#664, AVLTreeNode.keys] := Mask[this#664, AVLTreeNode.keys][perm$R := Mask[this#664, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#664, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#664 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#664, AVLTreeNode.balanceFactor] := Mask[this#664, AVLTreeNode.balanceFactor][perm$R := Mask[this#664, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#664, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#664, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2272[this#664, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2272[callHeap#_2272[this#664, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2272[this#664, AVLTreeNode.key])), ite(callHeap#_2272[this#664, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_2272[callHeap#_2272[this#664, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#664, AVLTreeNode.height] == ite(ite(callHeap#_2272[this#664, AVLTreeNode.left] == null, 0, callHeap#_2272[callHeap#_2272[this#664, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_2272[this#664, AVLTreeNode.right] == null, 0, callHeap#_2272[callHeap#_2272[this#664, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_2272[this#664, AVLTreeNode.left] == null, 0, callHeap#_2272[callHeap#_2272[this#664, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_2272[this#664, AVLTreeNode.right] == null, 0, callHeap#_2272[callHeap#_2272[this#664, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#664, AVLTreeNode.balanceFactor] == (ite(callHeap#_2272[this#664, AVLTreeNode.left] == null, 0, callHeap#_2272[callHeap#_2272[this#664, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_2272[this#664, AVLTreeNode.right] == null, 0, callHeap#_2272[callHeap#_2272[this#664, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // update field left
  assert {:msg "  689.3: Location might not be writable"} CanWrite(Mask, r#66, AVLTreeNode.left);
  assert {:msg "  689.17: Receiver might be null."} true ==> (this != null);
  assert {:msg "  689.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  Heap[r#66, AVLTreeNode.left] := Heap[this, AVLTreeNode.left];
  assume wf(Heap, Mask, SecMask);
  // update field left
  assert {:msg "  690.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
  assert {:msg "  690.17: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  690.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#66, AVLTreeNode.right);
  Heap[this, AVLTreeNode.left] := Heap[r#66, AVLTreeNode.right];
  assume wf(Heap, Mask, SecMask);
  // assert
  assertHeap#_2327 := Heap;
  assertMask#_2328 := Mask;
  assertSecMask#_2329 := SecMask;
  assertCredits#_2330 := Credits;
  assume wf(assertHeap#_2327, assertMask#_2328, assertSecMask#_2329);
  // begin exhale (assert)
  exhaleMask#_2332 := assertMask#_2328;
  havoc exhaleHeap#_2331;
  assert {:msg "  692.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  692.10: Location might not be readable."} true ==> CanRead(assertMask#_2328, assertSecMask#_2329, this, AVLTreeNode.left);
  if (!(assertHeap#_2327[this, AVLTreeNode.left] == null)) {
    assert {:msg "  692.10: Receiver might be null."} true && (0 <= k#101#678) ==> (this != null);
    assert {:msg "  692.10: Location might not be readable."} true && (0 <= k#101#678) ==> CanRead(assertMask#_2328, assertSecMask#_2329, this, AVLTreeNode.left);
    assert {:msg "  692.10: Receiver might be null."} true && (0 <= k#101#678) ==> (assertHeap#_2327[this, AVLTreeNode.left] != null);
    assert {:msg "  692.10: Location might not be readable."} true && (0 <= k#101#678) ==> CanRead(assertMask#_2328, assertSecMask#_2329, assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  692.10: Receiver might be null."} true && (0 <= k#101#678) && (k#101#678 < Seq#Length(assertHeap#_2327[assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  692.10: Location might not be readable."} true && (0 <= k#101#678) && (k#101#678 < Seq#Length(assertHeap#_2327[assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_2328, assertSecMask#_2329, this, AVLTreeNode.left);
    assert {:msg "  692.10: Receiver might be null."} true && (0 <= k#101#678) && (k#101#678 < Seq#Length(assertHeap#_2327[assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (assertHeap#_2327[this, AVLTreeNode.left] != null);
    assert {:msg "  692.10: Location might not be readable."} true && (0 <= k#101#678) && (k#101#678 < Seq#Length(assertHeap#_2327[assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_2328, assertSecMask#_2329, assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  692.50: Sequence index might be negative."} true && (0 <= k#101#678) && (k#101#678 < Seq#Length(assertHeap#_2327[assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#101#678);
    assert {:msg "  692.50: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#101#678) && (k#101#678 < Seq#Length(assertHeap#_2327[assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#101#678 < Seq#Length(assertHeap#_2327[assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  692.54: Receiver might be null."} true && (0 <= k#101#678) && (k#101#678 < Seq#Length(assertHeap#_2327[assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  692.54: Location might not be readable."} true && (0 <= k#101#678) && (k#101#678 < Seq#Length(assertHeap#_2327[assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_2328, assertSecMask#_2329, this, AVLTreeNode.key);
    assert {:msg "  692.3: Assertion might not hold. The expression at 692.25 might not evaluate to true."} (forall k#101#677: int :: (0 <= k#101#677) && (k#101#677 < Seq#Length(assertHeap#_2327[assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_2327[assertHeap#_2327[this, AVLTreeNode.left], AVLTreeNode.keys], k#101#677) < assertHeap#_2327[this, AVLTreeNode.key]));
  }
  assertMask#_2328 := exhaleMask#_2332;
  assume IsGoodExhaleState(exhaleHeap#_2331, assertHeap#_2327, assertMask#_2328, assertSecMask#_2329);
  assertHeap#_2327 := exhaleHeap#_2331;
  assume IsGoodMask(assertMask#_2328);
  assume wf(assertHeap#_2327, assertMask#_2328, assertSecMask#_2329);
  // end exhale
  assume (0 < methodCallK#_2337) && ((1000 * methodCallK#_2337) < Fractions(1)) && ((1000 * methodCallK#_2337) < methodK#_2144);
  // call close
  callHeap#_2333 := Heap;
  callMask#_2334 := Mask;
  callSecMask#_2335 := SecMask;
  callCredits#_2336 := Credits;
  assume wf(callHeap#_2333, callMask#_2334, callSecMask#_2335);
  assert {:msg "  693.3: The target of the method call might be null."} this != null;
  this#680 := this;
  // begin exhale (precondition)
  exhaleMask#_2339 := Mask;
  havoc exhaleHeap#_2338;
  if (!(Heap[this#680, AVLTreeNode.left] == null)) {
    assert {:msg "  693.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#681: int :: (0 <= k#92#681) && (k#92#681 < Seq#Length(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys], k#92#681) < Heap[this#680, AVLTreeNode.key]));
  }
  if (!(Heap[this#680, AVLTreeNode.right] == null)) {
    assert {:msg "  693.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#682: int :: (0 <= k#93#682) && (k#93#682 < Seq#Length(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#680, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys], k#93#682)));
  }
  assert {:msg "  693.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#680, AVLTreeNode.left] == null, 0, Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#680, AVLTreeNode.right] == null, 0, Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  693.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#680, AVLTreeNode.left] == null, 0, Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#680, AVLTreeNode.right] == null, 0, Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  693.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  693.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_2339[this#680, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_2339[this#680, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_2339[this#680, AVLTreeNode.key][perm$N]));
  exhaleMask#_2339[this#680, AVLTreeNode.key] := exhaleMask#_2339[this#680, AVLTreeNode.key][perm$R := exhaleMask#_2339[this#680, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2339);
  assume wf(Heap, exhaleMask#_2339, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  693.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  693.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_2339[this#680, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_2339[this#680, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2339[this#680, AVLTreeNode.height][perm$N]));
  exhaleMask#_2339[this#680, AVLTreeNode.height] := exhaleMask#_2339[this#680, AVLTreeNode.height][perm$R := exhaleMask#_2339[this#680, AVLTreeNode.height][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2339);
  assume wf(Heap, exhaleMask#_2339, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  693.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  693.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_2339[this#680, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_2339[this#680, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_2339[this#680, AVLTreeNode.left][perm$N]));
  exhaleMask#_2339[this#680, AVLTreeNode.left] := exhaleMask#_2339[this#680, AVLTreeNode.left][perm$R := exhaleMask#_2339[this#680, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2339);
  assume wf(Heap, exhaleMask#_2339, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  693.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  693.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_2339[this#680, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_2339[this#680, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_2339[this#680, AVLTreeNode.right][perm$N]));
  exhaleMask#_2339[this#680, AVLTreeNode.right] := exhaleMask#_2339[this#680, AVLTreeNode.right][perm$R := exhaleMask#_2339[this#680, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2339);
  assume wf(Heap, exhaleMask#_2339, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  693.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  693.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_2339[this#680, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_2339[this#680, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2339[this#680, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2339[this#680, AVLTreeNode.keys] := exhaleMask#_2339[this#680, AVLTreeNode.keys][perm$R := exhaleMask#_2339[this#680, AVLTreeNode.keys][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2339);
  assume wf(Heap, exhaleMask#_2339, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  693.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  693.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_2339[this#680, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_2339[this#680, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2339[this#680, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2339[this#680, AVLTreeNode.balanceFactor] := exhaleMask#_2339[this#680, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2339[this#680, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2339);
  assume wf(Heap, exhaleMask#_2339, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#680, AVLTreeNode.left] == null)) {
    assert {:msg "  693.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
    assert {:msg "  693.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false || ((predVer#_2192 == Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2191 == Heap[this#680, AVLTreeNode.left]) && true && predFlag#_2193)) {
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#683: int :: (0 <= lk#79#683) && (lk#79#683 < Seq#Length(Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#683) < Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#684: int :: (0 <= rk#80#684) && (rk#80#684 < Seq#Length(Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#684)));
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height] > 0;
      SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_2339, SecMask, Heap[this#680, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#680, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2338[Heap[this#680, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_2339);
    assume wf(Heap, exhaleMask#_2339, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#680, AVLTreeNode.left] == null)) {
    assert {:msg "  693.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  693.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2339);
    assume wf(Heap, exhaleMask#_2339, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#680, AVLTreeNode.left] == null)) {
    assert {:msg "  693.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  693.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2339);
    assume wf(Heap, exhaleMask#_2339, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#680, AVLTreeNode.left] == null)) {
    assert {:msg "  693.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  693.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2339[Heap[this#680, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2339);
    assume wf(Heap, exhaleMask#_2339, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#680, AVLTreeNode.right] == null)) {
    assert {:msg "  693.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
    assert {:msg "  693.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false || ((predVer#_2192 == Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2191 == Heap[this#680, AVLTreeNode.right]) && true && predFlag#_2193)) {
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#688: int :: (0 <= lk#79#688) && (lk#79#688 < Seq#Length(Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#688) < Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#689: int :: (0 <= rk#80#689) && (rk#80#689 < Seq#Length(Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#689)));
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height] > 0;
      SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_2339, SecMask, Heap[this#680, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#680, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2338[Heap[this#680, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_2339);
    assume wf(Heap, exhaleMask#_2339, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#680, AVLTreeNode.right] == null)) {
    assert {:msg "  693.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  693.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2339);
    assume wf(Heap, exhaleMask#_2339, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#680, AVLTreeNode.right] == null)) {
    assert {:msg "  693.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  693.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2339);
    assume wf(Heap, exhaleMask#_2339, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#680, AVLTreeNode.right] == null)) {
    assert {:msg "  693.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  693.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2339[Heap[this#680, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2339);
    assume wf(Heap, exhaleMask#_2339, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_2339;
  assume IsGoodExhaleState(exhaleHeap#_2338, Heap, Mask, SecMask);
  Heap := exhaleHeap#_2338;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#680 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#680, AVLTreeNode.valid] := Mask[this#680, AVLTreeNode.valid][perm$R := Mask[this#680, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#680, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#680 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#680, AVLTreeNode.height] := Mask[this#680, AVLTreeNode.height][perm$R := Mask[this#680, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#680, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#680 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#680, AVLTreeNode.keys] := Mask[this#680, AVLTreeNode.keys][perm$R := Mask[this#680, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#680, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#680 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#680, AVLTreeNode.balanceFactor] := Mask[this#680, AVLTreeNode.balanceFactor][perm$R := Mask[this#680, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#680, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#680, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2333[this#680, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2333[callHeap#_2333[this#680, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2333[this#680, AVLTreeNode.key])), ite(callHeap#_2333[this#680, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_2333[callHeap#_2333[this#680, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#680, AVLTreeNode.height] == ite(ite(callHeap#_2333[this#680, AVLTreeNode.left] == null, 0, callHeap#_2333[callHeap#_2333[this#680, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_2333[this#680, AVLTreeNode.right] == null, 0, callHeap#_2333[callHeap#_2333[this#680, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_2333[this#680, AVLTreeNode.left] == null, 0, callHeap#_2333[callHeap#_2333[this#680, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_2333[this#680, AVLTreeNode.right] == null, 0, callHeap#_2333[callHeap#_2333[this#680, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#680, AVLTreeNode.balanceFactor] == (ite(callHeap#_2333[this#680, AVLTreeNode.left] == null, 0, callHeap#_2333[callHeap#_2333[this#680, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_2333[this#680, AVLTreeNode.right] == null, 0, callHeap#_2333[callHeap#_2333[this#680, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // update field right
  assert {:msg "  694.3: Location might not be writable"} CanWrite(Mask, r#66, AVLTreeNode.right);
  Heap[r#66, AVLTreeNode.right] := this;
  assume wf(Heap, Mask, SecMask);
  assume (0 < methodCallK#_2392) && ((1000 * methodCallK#_2392) < Fractions(1)) && ((1000 * methodCallK#_2392) < methodK#_2144);
  // call close
  callHeap#_2388 := Heap;
  callMask#_2389 := Mask;
  callSecMask#_2390 := SecMask;
  callCredits#_2391 := Credits;
  assume wf(callHeap#_2388, callMask#_2389, callSecMask#_2390);
  assert {:msg "  695.3: The target of the method call might be null."} r#66 != null;
  this#693 := r#66;
  // begin exhale (precondition)
  exhaleMask#_2394 := Mask;
  havoc exhaleHeap#_2393;
  if (!(Heap[this#693, AVLTreeNode.left] == null)) {
    assert {:msg "  695.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#694: int :: (0 <= k#92#694) && (k#92#694 < Seq#Length(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys], k#92#694) < Heap[this#693, AVLTreeNode.key]));
  }
  if (!(Heap[this#693, AVLTreeNode.right] == null)) {
    assert {:msg "  695.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#695: int :: (0 <= k#93#695) && (k#93#695 < Seq#Length(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#693, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys], k#93#695)));
  }
  assert {:msg "  695.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#693, AVLTreeNode.left] == null, 0, Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#693, AVLTreeNode.right] == null, 0, Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  695.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#693, AVLTreeNode.left] == null, 0, Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#693, AVLTreeNode.right] == null, 0, Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  695.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  695.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_2394[this#693, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_2394[this#693, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_2394[this#693, AVLTreeNode.key][perm$N]));
  exhaleMask#_2394[this#693, AVLTreeNode.key] := exhaleMask#_2394[this#693, AVLTreeNode.key][perm$R := exhaleMask#_2394[this#693, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2394);
  assume wf(Heap, exhaleMask#_2394, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  695.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  695.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_2394[this#693, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_2394[this#693, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2394[this#693, AVLTreeNode.height][perm$N]));
  exhaleMask#_2394[this#693, AVLTreeNode.height] := exhaleMask#_2394[this#693, AVLTreeNode.height][perm$R := exhaleMask#_2394[this#693, AVLTreeNode.height][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2394);
  assume wf(Heap, exhaleMask#_2394, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  695.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  695.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_2394[this#693, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_2394[this#693, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_2394[this#693, AVLTreeNode.left][perm$N]));
  exhaleMask#_2394[this#693, AVLTreeNode.left] := exhaleMask#_2394[this#693, AVLTreeNode.left][perm$R := exhaleMask#_2394[this#693, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2394);
  assume wf(Heap, exhaleMask#_2394, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  695.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  695.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_2394[this#693, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_2394[this#693, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_2394[this#693, AVLTreeNode.right][perm$N]));
  exhaleMask#_2394[this#693, AVLTreeNode.right] := exhaleMask#_2394[this#693, AVLTreeNode.right][perm$R := exhaleMask#_2394[this#693, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2394);
  assume wf(Heap, exhaleMask#_2394, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  695.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  695.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_2394[this#693, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_2394[this#693, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2394[this#693, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2394[this#693, AVLTreeNode.keys] := exhaleMask#_2394[this#693, AVLTreeNode.keys][perm$R := exhaleMask#_2394[this#693, AVLTreeNode.keys][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2394);
  assume wf(Heap, exhaleMask#_2394, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  695.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  695.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_2394[this#693, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_2394[this#693, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2394[this#693, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2394[this#693, AVLTreeNode.balanceFactor] := exhaleMask#_2394[this#693, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2394[this#693, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2394);
  assume wf(Heap, exhaleMask#_2394, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#693, AVLTreeNode.left] == null)) {
    assert {:msg "  695.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
    assert {:msg "  695.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false || ((predVer#_2192 == Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2191 == Heap[this#693, AVLTreeNode.left]) && true && predFlag#_2193)) {
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#696: int :: (0 <= lk#79#696) && (lk#79#696 < Seq#Length(Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#696) < Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#697: int :: (0 <= rk#80#697) && (rk#80#697 < Seq#Length(Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#697)));
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height] > 0;
      SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_2394, SecMask, Heap[this#693, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#693, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2393[Heap[this#693, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_2394);
    assume wf(Heap, exhaleMask#_2394, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#693, AVLTreeNode.left] == null)) {
    assert {:msg "  695.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  695.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2394);
    assume wf(Heap, exhaleMask#_2394, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#693, AVLTreeNode.left] == null)) {
    assert {:msg "  695.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  695.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2394);
    assume wf(Heap, exhaleMask#_2394, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#693, AVLTreeNode.left] == null)) {
    assert {:msg "  695.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  695.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2394[Heap[this#693, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2394);
    assume wf(Heap, exhaleMask#_2394, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#693, AVLTreeNode.right] == null)) {
    assert {:msg "  695.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
    assert {:msg "  695.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false || ((predVer#_2192 == Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2191 == Heap[this#693, AVLTreeNode.right]) && true && predFlag#_2193)) {
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#701: int :: (0 <= lk#79#701) && (lk#79#701 < Seq#Length(Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#701) < Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#702: int :: (0 <= rk#80#702) && (rk#80#702 < Seq#Length(Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#702)));
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height] > 0;
      SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_2394, SecMask, Heap[this#693, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#693, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2393[Heap[this#693, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_2394);
    assume wf(Heap, exhaleMask#_2394, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#693, AVLTreeNode.right] == null)) {
    assert {:msg "  695.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  695.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2394);
    assume wf(Heap, exhaleMask#_2394, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#693, AVLTreeNode.right] == null)) {
    assert {:msg "  695.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  695.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2394);
    assume wf(Heap, exhaleMask#_2394, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#693, AVLTreeNode.right] == null)) {
    assert {:msg "  695.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  695.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2394[Heap[this#693, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2394);
    assume wf(Heap, exhaleMask#_2394, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_2394;
  assume IsGoodExhaleState(exhaleHeap#_2393, Heap, Mask, SecMask);
  Heap := exhaleHeap#_2393;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#693 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#693, AVLTreeNode.valid] := Mask[this#693, AVLTreeNode.valid][perm$R := Mask[this#693, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#693, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#693 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#693, AVLTreeNode.height] := Mask[this#693, AVLTreeNode.height][perm$R := Mask[this#693, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#693, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#693 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#693, AVLTreeNode.keys] := Mask[this#693, AVLTreeNode.keys][perm$R := Mask[this#693, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#693, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#693 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#693, AVLTreeNode.balanceFactor] := Mask[this#693, AVLTreeNode.balanceFactor][perm$R := Mask[this#693, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#693, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#693, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2388[this#693, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2388[callHeap#_2388[this#693, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2388[this#693, AVLTreeNode.key])), ite(callHeap#_2388[this#693, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_2388[callHeap#_2388[this#693, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#693, AVLTreeNode.height] == ite(ite(callHeap#_2388[this#693, AVLTreeNode.left] == null, 0, callHeap#_2388[callHeap#_2388[this#693, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_2388[this#693, AVLTreeNode.right] == null, 0, callHeap#_2388[callHeap#_2388[this#693, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_2388[this#693, AVLTreeNode.left] == null, 0, callHeap#_2388[callHeap#_2388[this#693, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_2388[this#693, AVLTreeNode.right] == null, 0, callHeap#_2388[callHeap#_2388[this#693, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#693, AVLTreeNode.balanceFactor] == (ite(callHeap#_2388[this#693, AVLTreeNode.left] == null, 0, callHeap#_2388[callHeap#_2388[this#693, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_2388[this#693, AVLTreeNode.right] == null, 0, callHeap#_2388[callHeap#_2388[this#693, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_2444 := Mask;
  havoc exhaleHeap#_2443;
  assert {:msg "  643.2: The postcondition at 670.11 might not hold. The expression at 670.11 might not evaluate to true."} !(r#66 == null);
  assert {:msg "  643.2: The postcondition at 676.11 might not hold. The expression at 676.11 might not evaluate to true."} Heap[r#66, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height];
  assert {:msg "  643.2: The postcondition at 677.11 might not hold. The expression at 677.11 might not evaluate to true."} Seq#Equal(Heap[r#66, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  643.2: The postcondition at 671.11 might not hold. The permission at 671.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  643.2: The postcondition at 671.11 might not hold. Insufficient fraction at 671.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2444[r#66, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2444[r#66, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2444[r#66, AVLTreeNode.valid][perm$N]));
  exhaleMask#_2444[r#66, AVLTreeNode.valid] := exhaleMask#_2444[r#66, AVLTreeNode.valid][perm$R := exhaleMask#_2444[r#66, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_2192 == Heap[r#66, AVLTreeNode.valid]) && (predRec#_2191 == r#66) && true && predFlag#_2193)) {
    // begin exhale (update SecMask)
    if (!(Heap[r#66, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#706: int :: (0 <= lk#79#706) && (lk#79#706 < Seq#Length(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys], lk#79#706) < Heap[r#66, AVLTreeNode.key]));
    }
    if (!(Heap[r#66, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[r#66, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#707: int :: (0 <= rk#80#707) && (rk#80#707 < Seq#Length(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#66, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys], rk#80#707)));
    }
    if (!(Heap[r#66, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[r#66, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#66, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#66, AVLTreeNode.key])), ite(Heap[r#66, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[r#66, AVLTreeNode.keys], Heap[r#66, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[r#66, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#66, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#66, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#66, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[r#66, AVLTreeNode.height] == ite(ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[r#66, AVLTreeNode.balanceFactor] == (ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[r#66, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[r#66, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[r#66, AVLTreeNode.height] > 0;
    SecMask[r#66, AVLTreeNode.key] := SecMask[r#66, AVLTreeNode.key][perm$R := SecMask[r#66, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[r#66, AVLTreeNode.key][perm$R] < 0) {
      SecMask[r#66, AVLTreeNode.key] := SecMask[r#66, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#66, AVLTreeNode.height] := SecMask[r#66, AVLTreeNode.height][perm$R := SecMask[r#66, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[r#66, AVLTreeNode.height][perm$R] < 0) {
      SecMask[r#66, AVLTreeNode.height] := SecMask[r#66, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#66, AVLTreeNode.left] := SecMask[r#66, AVLTreeNode.left][perm$R := SecMask[r#66, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[r#66, AVLTreeNode.left][perm$R] < 0) {
      SecMask[r#66, AVLTreeNode.left] := SecMask[r#66, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#66, AVLTreeNode.right] := SecMask[r#66, AVLTreeNode.right][perm$R := SecMask[r#66, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[r#66, AVLTreeNode.right][perm$R] < 0) {
      SecMask[r#66, AVLTreeNode.right] := SecMask[r#66, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#66, AVLTreeNode.keys] := SecMask[r#66, AVLTreeNode.keys][perm$R := SecMask[r#66, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[r#66, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[r#66, AVLTreeNode.keys] := SecMask[r#66, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#66, AVLTreeNode.balanceFactor] := SecMask[r#66, AVLTreeNode.balanceFactor][perm$R := SecMask[r#66, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[r#66, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[r#66, AVLTreeNode.balanceFactor] := SecMask[r#66, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[r#66, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#66, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(exhaleMask#_2444, SecMask, r#66, AVLTreeNode.valid)) {
    assume Heap[r#66, AVLTreeNode.valid] < exhaleHeap#_2443[r#66, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_2444);
  assume wf(Heap, exhaleMask#_2444, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  643.2: The postcondition at 672.11 might not hold. The permission at 672.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  643.2: The postcondition at 672.11 might not hold. Insufficient fraction at 672.11 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2444[r#66, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2444[r#66, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2444[r#66, AVLTreeNode.height][perm$N]));
  exhaleMask#_2444[r#66, AVLTreeNode.height] := exhaleMask#_2444[r#66, AVLTreeNode.height][perm$R := exhaleMask#_2444[r#66, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_2444);
  assume wf(Heap, exhaleMask#_2444, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  643.2: The postcondition at 673.11 might not hold. The permission at 673.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  643.2: The postcondition at 673.11 might not hold. Insufficient fraction at 673.11 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2444[r#66, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2444[r#66, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2444[r#66, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2444[r#66, AVLTreeNode.keys] := exhaleMask#_2444[r#66, AVLTreeNode.keys][perm$R := exhaleMask#_2444[r#66, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_2444);
  assume wf(Heap, exhaleMask#_2444, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  643.2: The postcondition at 674.11 might not hold. The permission at 674.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  643.2: The postcondition at 674.11 might not hold. Insufficient fraction at 674.11 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2444[r#66, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2444[r#66, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2444[r#66, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2444[r#66, AVLTreeNode.balanceFactor] := exhaleMask#_2444[r#66, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2444[r#66, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_2444);
  assume wf(Heap, exhaleMask#_2444, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_2444;
  assume IsGoodExhaleState(exhaleHeap#_2443, Heap, Mask, SecMask);
  Heap := exhaleHeap#_2443;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  643.2: Method might lock/unlock more than allowed."} (forall lk#_2465: ref :: {Heap[lk#_2465, held]} {Heap[lk#_2465, rdheld]} (((0 < Heap[lk#_2465, held]) == (0 < old(Heap)[lk#_2465, held])) && (Heap[lk#_2465, rdheld] == old(Heap)[lk#_2465, rdheld])) || false);
  assert {:msg "  643.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceRR$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#67: ref where (r#67 == null) || (dtype(r#67) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2466: int;
  var k#102#711: int where true;
  var k#103#713: int where true;
  assume (0 < methodK#_2466) && ((1000 * methodK#_2466) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  710.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  710.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assert {:msg "  711.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  711.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  711.12: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
  assert {:msg "  711.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  711.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  712.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  712.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  713.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  713.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  714.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  714.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  715.12: Receiver might be null."} true && (0 <= k#102#711) ==> (this != null);
  assert {:msg "  715.12: Location might not be readable."} true && (0 <= k#102#711) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  715.12: Receiver might be null."} true && (0 <= k#102#711) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  715.12: Location might not be readable."} true && (0 <= k#102#711) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  715.12: Receiver might be null."} true && (0 <= k#102#711) && (k#102#711 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  715.12: Location might not be readable."} true && (0 <= k#102#711) && (k#102#711 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  715.12: Receiver might be null."} true && (0 <= k#102#711) && (k#102#711 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  715.12: Location might not be readable."} true && (0 <= k#102#711) && (k#102#711 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  715.37: Sequence index might be negative."} true && (0 <= k#102#711) && (k#102#711 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#102#711);
  assert {:msg "  715.37: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#102#711) && (k#102#711 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#102#711 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assert {:msg "  715.41: Receiver might be null."} true && (0 <= k#102#711) && (k#102#711 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  715.41: Location might not be readable."} true && (0 <= k#102#711) && (k#102#711 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  assume (forall k#102#710: int :: (0 <= k#102#710) && (k#102#710 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#102#710) < Heap[this, AVLTreeNode.key]));
  assert {:msg "  717.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  717.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  717.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  717.28: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  717.28: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  717.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  717.28: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  718.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  718.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  718.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  718.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  719.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  719.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  719.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  719.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  720.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  720.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  720.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  720.32: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  721.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  721.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  721.12: Receiver might be null."} true && (0 <= k#103#713) ==> (this != null);
    assert {:msg "  721.12: Location might not be readable."} true && (0 <= k#103#713) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  721.12: Receiver might be null."} true && (0 <= k#103#713) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  721.12: Location might not be readable."} true && (0 <= k#103#713) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  721.54: Receiver might be null."} true && (0 <= k#103#713) && (k#103#713 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  721.54: Location might not be readable."} true && (0 <= k#103#713) && (k#103#713 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    assert {:msg "  721.12: Receiver might be null."} true && (0 <= k#103#713) && (k#103#713 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  721.12: Location might not be readable."} true && (0 <= k#103#713) && (k#103#713 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  721.12: Receiver might be null."} true && (0 <= k#103#713) && (k#103#713 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  721.12: Location might not be readable."} true && (0 <= k#103#713) && (k#103#713 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  721.60: Sequence index might be negative."} true && (0 <= k#103#713) && (k#103#713 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#103#713);
    assert {:msg "  721.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#103#713) && (k#103#713 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#103#713 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall k#103#712: int :: (0 <= k#103#712) && (k#103#712 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#103#712)));
  }
  assert {:msg "  723.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  723.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  723.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  723.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  723.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  723.27: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  723.41: Receiver might be null."} true ==> (this != null);
    assert {:msg "  723.41: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
    assert {:msg "  723.41: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  723.41: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assert {:msg "  724.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  724.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  724.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  724.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#67 == null);
  assert {:msg "  728.11: Receiver might be null."} r#67 != null;
  assume r#67 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[r#67, AVLTreeNode.valid] := Mask[r#67, AVLTreeNode.valid][perm$R := Mask[r#67, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#67, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#67 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#67, AVLTreeNode.height] := Mask[r#67, AVLTreeNode.height][perm$R := Mask[r#67, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#67, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#67 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#67, AVLTreeNode.keys] := Mask[r#67, AVLTreeNode.keys][perm$R := Mask[r#67, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#67, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#67 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#67, AVLTreeNode.balanceFactor] := Mask[r#67, AVLTreeNode.balanceFactor][perm$R := Mask[r#67, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#67, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  733.11: Receiver might be null."} true ==> (r#67 != null);
  assert {:msg "  733.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#67, AVLTreeNode.height);
  assert {:msg "  733.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  733.27: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  assert {:msg "  733.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  733.27: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  733.43: Receiver might be null."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (r#67 != null);
  assert {:msg "  733.43: Location might not be readable."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(Mask, SecMask, r#67, AVLTreeNode.height);
  assert {:msg "  733.59: Receiver might be null."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  733.59: Location might not be readable."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  assert {:msg "  733.59: Receiver might be null."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  733.59: Location might not be readable."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assume (Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#67, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height] + 1));
  assert {:msg "  734.11: Receiver might be null."} true ==> (r#67 != null);
  assert {:msg "  734.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#67, AVLTreeNode.keys);
  assert {:msg "  734.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  734.25: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  assert {:msg "  734.25: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  734.25: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  734.44: Receiver might be null."} true ==> (this != null);
  assert {:msg "  734.44: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.key);
  assert {:msg "  734.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  734.59: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  734.89: Receiver might be null."} true ==> (this != null);
    assert {:msg "  734.89: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
    assert {:msg "  734.89: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  734.89: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[r#67, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.rebalanceRR(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#67: ref where (r#67 == null) || (dtype(r#67) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2466: int;
  var unfoldK#_2467: int;
  var oldVers#_2487: int;
  var newVers#_2488: int;
  var methodCallK#_2493: int;
  var this#722: ref where (this#722 == null) || (dtype(this#722) == AVLTreeNode#t);
  var callHeap#_2489: HeapType;
  var callMask#_2490: MaskType;
  var callSecMask#_2491: MaskType;
  var callCredits#_2492: CreditsType;
  var exhaleMask#_2495: MaskType;
  var exhaleHeap#_2494: HeapType;
  var isHeld#_2510: int;
  var isRdHeld#_2511: bool;
  var methodCallK#_2516: int;
  var this#727: ref where (this#727 == null) || (dtype(this#727) == AVLTreeNode#t);
  var callHeap#_2512: HeapType;
  var callMask#_2513: MaskType;
  var callSecMask#_2514: MaskType;
  var callCredits#_2515: CreditsType;
  var exhaleMask#_2518: MaskType;
  var exhaleHeap#_2517: HeapType;
  var isHeld#_2533: int;
  var isRdHeld#_2534: bool;
  var exhaleMask#_2536: MaskType;
  var exhaleHeap#_2535: HeapType;
  assume (0 < methodK#_2466) && ((1000 * methodK#_2466) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume (forall k#102#714: int :: (0 <= k#102#714) && (k#102#714 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#102#714) < Heap[this, AVLTreeNode.key]));
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall k#103#715: int :: (0 <= k#103#715) && (k#103#715 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#103#715)));
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // unfold
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.left]);
  assume (0 < unfoldK#_2467) && (unfoldK#_2467 < Fractions(1)) && ((1000 * unfoldK#_2467) < methodK#_2466);
  assert {:msg "  736.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  736.10: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  assert {:msg "  736.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.left] != null;
  // begin exhale (unfold)
  assert {:msg "  736.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  736.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#716: int :: (0 <= lk#79#716) && (lk#79#716 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#716) < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]));
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#717: int :: (0 <= rk#80#717) && (rk#80#717 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#717)));
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.valid)) {
    oldVers#_2487 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    havoc newVers#_2488;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_2488;
    assume oldVers#_2487 < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume (forall lk#79#720: int :: (0 <= lk#79#720) && (lk#79#720 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#720) < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]));
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume (forall rk#80#721: int :: (0 <= rk#80#721) && (rk#80#721 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#721)));
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])));
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // assigment to r
  assert {:msg "  737.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  737.14: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  r#67 := Heap[this, AVLTreeNode.left];
  // update field left
  assert {:msg "  738.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
  assert {:msg "  738.14: Receiver might be null."} true ==> (r#67 != null);
  assert {:msg "  738.14: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#67, AVLTreeNode.right);
  Heap[this, AVLTreeNode.left] := Heap[r#67, AVLTreeNode.right];
  assume wf(Heap, Mask, SecMask);
  assume (0 < methodCallK#_2493) && ((1000 * methodCallK#_2493) < Fractions(1)) && ((1000 * methodCallK#_2493) < methodK#_2466);
  // call close
  callHeap#_2489 := Heap;
  callMask#_2490 := Mask;
  callSecMask#_2491 := SecMask;
  callCredits#_2492 := Credits;
  assume wf(callHeap#_2489, callMask#_2490, callSecMask#_2491);
  assert {:msg "  739.3: The target of the method call might be null."} this != null;
  this#722 := this;
  // begin exhale (precondition)
  exhaleMask#_2495 := Mask;
  havoc exhaleHeap#_2494;
  if (!(Heap[this#722, AVLTreeNode.left] == null)) {
    assert {:msg "  739.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#723: int :: (0 <= k#92#723) && (k#92#723 < Seq#Length(Heap[Heap[this#722, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#722, AVLTreeNode.left], AVLTreeNode.keys], k#92#723) < Heap[this#722, AVLTreeNode.key]));
  }
  if (!(Heap[this#722, AVLTreeNode.right] == null)) {
    assert {:msg "  739.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#724: int :: (0 <= k#93#724) && (k#93#724 < Seq#Length(Heap[Heap[this#722, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#722, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#722, AVLTreeNode.right], AVLTreeNode.keys], k#93#724)));
  }
  assert {:msg "  739.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#722, AVLTreeNode.left] == null, 0, Heap[Heap[this#722, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#722, AVLTreeNode.right] == null, 0, Heap[Heap[this#722, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  739.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#722, AVLTreeNode.left] == null, 0, Heap[Heap[this#722, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#722, AVLTreeNode.right] == null, 0, Heap[Heap[this#722, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  739.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  739.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_2495[this#722, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_2495[this#722, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_2495[this#722, AVLTreeNode.key][perm$N]));
  exhaleMask#_2495[this#722, AVLTreeNode.key] := exhaleMask#_2495[this#722, AVLTreeNode.key][perm$R := exhaleMask#_2495[this#722, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2495);
  assume wf(Heap, exhaleMask#_2495, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  739.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  739.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_2495[this#722, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_2495[this#722, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2495[this#722, AVLTreeNode.height][perm$N]));
  exhaleMask#_2495[this#722, AVLTreeNode.height] := exhaleMask#_2495[this#722, AVLTreeNode.height][perm$R := exhaleMask#_2495[this#722, AVLTreeNode.height][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2495);
  assume wf(Heap, exhaleMask#_2495, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  739.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  739.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_2495[this#722, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_2495[this#722, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_2495[this#722, AVLTreeNode.left][perm$N]));
  exhaleMask#_2495[this#722, AVLTreeNode.left] := exhaleMask#_2495[this#722, AVLTreeNode.left][perm$R := exhaleMask#_2495[this#722, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2495);
  assume wf(Heap, exhaleMask#_2495, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  739.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  739.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_2495[this#722, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_2495[this#722, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_2495[this#722, AVLTreeNode.right][perm$N]));
  exhaleMask#_2495[this#722, AVLTreeNode.right] := exhaleMask#_2495[this#722, AVLTreeNode.right][perm$R := exhaleMask#_2495[this#722, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2495);
  assume wf(Heap, exhaleMask#_2495, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  739.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  739.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_2495[this#722, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_2495[this#722, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2495[this#722, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2495[this#722, AVLTreeNode.keys] := exhaleMask#_2495[this#722, AVLTreeNode.keys][perm$R := exhaleMask#_2495[this#722, AVLTreeNode.keys][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2495);
  assume wf(Heap, exhaleMask#_2495, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  739.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  739.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_2495[this#722, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_2495[this#722, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2495[this#722, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2495[this#722, AVLTreeNode.balanceFactor] := exhaleMask#_2495[this#722, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2495[this#722, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2495);
  assume wf(Heap, exhaleMask#_2495, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#722, AVLTreeNode.left] == null)) {
    assert {:msg "  739.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
    assert {:msg "  739.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_2495, SecMask, Heap[this#722, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#722, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2494[Heap[this#722, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_2495);
    assume wf(Heap, exhaleMask#_2495, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#722, AVLTreeNode.left] == null)) {
    assert {:msg "  739.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  739.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2495);
    assume wf(Heap, exhaleMask#_2495, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#722, AVLTreeNode.left] == null)) {
    assert {:msg "  739.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  739.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2495);
    assume wf(Heap, exhaleMask#_2495, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#722, AVLTreeNode.left] == null)) {
    assert {:msg "  739.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  739.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2495[Heap[this#722, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2495);
    assume wf(Heap, exhaleMask#_2495, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#722, AVLTreeNode.right] == null)) {
    assert {:msg "  739.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
    assert {:msg "  739.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_2495, SecMask, Heap[this#722, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#722, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2494[Heap[this#722, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_2495);
    assume wf(Heap, exhaleMask#_2495, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#722, AVLTreeNode.right] == null)) {
    assert {:msg "  739.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  739.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2495);
    assume wf(Heap, exhaleMask#_2495, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#722, AVLTreeNode.right] == null)) {
    assert {:msg "  739.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  739.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2495);
    assume wf(Heap, exhaleMask#_2495, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#722, AVLTreeNode.right] == null)) {
    assert {:msg "  739.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  739.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2495[Heap[this#722, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2495);
    assume wf(Heap, exhaleMask#_2495, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_2495;
  assume IsGoodExhaleState(exhaleHeap#_2494, Heap, Mask, SecMask);
  Heap := exhaleHeap#_2494;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#722 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#722, AVLTreeNode.valid] := Mask[this#722, AVLTreeNode.valid][perm$R := Mask[this#722, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#722, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#722 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#722, AVLTreeNode.height] := Mask[this#722, AVLTreeNode.height][perm$R := Mask[this#722, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#722, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#722 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#722, AVLTreeNode.keys] := Mask[this#722, AVLTreeNode.keys][perm$R := Mask[this#722, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#722, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#722 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#722, AVLTreeNode.balanceFactor] := Mask[this#722, AVLTreeNode.balanceFactor][perm$R := Mask[this#722, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#722, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#722, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2489[this#722, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2489[callHeap#_2489[this#722, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2489[this#722, AVLTreeNode.key])), ite(callHeap#_2489[this#722, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_2489[callHeap#_2489[this#722, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#722, AVLTreeNode.height] == ite(ite(callHeap#_2489[this#722, AVLTreeNode.left] == null, 0, callHeap#_2489[callHeap#_2489[this#722, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_2489[this#722, AVLTreeNode.right] == null, 0, callHeap#_2489[callHeap#_2489[this#722, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_2489[this#722, AVLTreeNode.left] == null, 0, callHeap#_2489[callHeap#_2489[this#722, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_2489[this#722, AVLTreeNode.right] == null, 0, callHeap#_2489[callHeap#_2489[this#722, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#722, AVLTreeNode.balanceFactor] == (ite(callHeap#_2489[this#722, AVLTreeNode.left] == null, 0, callHeap#_2489[callHeap#_2489[this#722, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_2489[this#722, AVLTreeNode.right] == null, 0, callHeap#_2489[callHeap#_2489[this#722, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // update field right
  assert {:msg "  740.3: Location might not be writable"} CanWrite(Mask, r#67, AVLTreeNode.right);
  Heap[r#67, AVLTreeNode.right] := this;
  assume wf(Heap, Mask, SecMask);
  assume (0 < methodCallK#_2516) && ((1000 * methodCallK#_2516) < Fractions(1)) && ((1000 * methodCallK#_2516) < methodK#_2466);
  // call close
  callHeap#_2512 := Heap;
  callMask#_2513 := Mask;
  callSecMask#_2514 := SecMask;
  callCredits#_2515 := Credits;
  assume wf(callHeap#_2512, callMask#_2513, callSecMask#_2514);
  assert {:msg "  741.3: The target of the method call might be null."} r#67 != null;
  this#727 := r#67;
  // begin exhale (precondition)
  exhaleMask#_2518 := Mask;
  havoc exhaleHeap#_2517;
  if (!(Heap[this#727, AVLTreeNode.left] == null)) {
    assert {:msg "  741.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#728: int :: (0 <= k#92#728) && (k#92#728 < Seq#Length(Heap[Heap[this#727, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#727, AVLTreeNode.left], AVLTreeNode.keys], k#92#728) < Heap[this#727, AVLTreeNode.key]));
  }
  if (!(Heap[this#727, AVLTreeNode.right] == null)) {
    assert {:msg "  741.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#729: int :: (0 <= k#93#729) && (k#93#729 < Seq#Length(Heap[Heap[this#727, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#727, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#727, AVLTreeNode.right], AVLTreeNode.keys], k#93#729)));
  }
  assert {:msg "  741.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#727, AVLTreeNode.left] == null, 0, Heap[Heap[this#727, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#727, AVLTreeNode.right] == null, 0, Heap[Heap[this#727, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  741.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#727, AVLTreeNode.left] == null, 0, Heap[Heap[this#727, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#727, AVLTreeNode.right] == null, 0, Heap[Heap[this#727, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  741.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  741.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_2518[this#727, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_2518[this#727, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_2518[this#727, AVLTreeNode.key][perm$N]));
  exhaleMask#_2518[this#727, AVLTreeNode.key] := exhaleMask#_2518[this#727, AVLTreeNode.key][perm$R := exhaleMask#_2518[this#727, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2518);
  assume wf(Heap, exhaleMask#_2518, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  741.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  741.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_2518[this#727, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_2518[this#727, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2518[this#727, AVLTreeNode.height][perm$N]));
  exhaleMask#_2518[this#727, AVLTreeNode.height] := exhaleMask#_2518[this#727, AVLTreeNode.height][perm$R := exhaleMask#_2518[this#727, AVLTreeNode.height][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2518);
  assume wf(Heap, exhaleMask#_2518, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  741.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  741.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_2518[this#727, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_2518[this#727, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_2518[this#727, AVLTreeNode.left][perm$N]));
  exhaleMask#_2518[this#727, AVLTreeNode.left] := exhaleMask#_2518[this#727, AVLTreeNode.left][perm$R := exhaleMask#_2518[this#727, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2518);
  assume wf(Heap, exhaleMask#_2518, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  741.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  741.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_2518[this#727, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_2518[this#727, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_2518[this#727, AVLTreeNode.right][perm$N]));
  exhaleMask#_2518[this#727, AVLTreeNode.right] := exhaleMask#_2518[this#727, AVLTreeNode.right][perm$R := exhaleMask#_2518[this#727, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2518);
  assume wf(Heap, exhaleMask#_2518, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  741.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  741.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_2518[this#727, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_2518[this#727, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2518[this#727, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2518[this#727, AVLTreeNode.keys] := exhaleMask#_2518[this#727, AVLTreeNode.keys][perm$R := exhaleMask#_2518[this#727, AVLTreeNode.keys][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2518);
  assume wf(Heap, exhaleMask#_2518, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  741.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  741.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_2518[this#727, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_2518[this#727, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2518[this#727, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2518[this#727, AVLTreeNode.balanceFactor] := exhaleMask#_2518[this#727, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2518[this#727, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_2518);
  assume wf(Heap, exhaleMask#_2518, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#727, AVLTreeNode.left] == null)) {
    assert {:msg "  741.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
    assert {:msg "  741.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_2518, SecMask, Heap[this#727, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#727, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2517[Heap[this#727, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_2518);
    assume wf(Heap, exhaleMask#_2518, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#727, AVLTreeNode.left] == null)) {
    assert {:msg "  741.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  741.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2518);
    assume wf(Heap, exhaleMask#_2518, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#727, AVLTreeNode.left] == null)) {
    assert {:msg "  741.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  741.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2518);
    assume wf(Heap, exhaleMask#_2518, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#727, AVLTreeNode.left] == null)) {
    assert {:msg "  741.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  741.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2518[Heap[this#727, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2518);
    assume wf(Heap, exhaleMask#_2518, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#727, AVLTreeNode.right] == null)) {
    assert {:msg "  741.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
    assert {:msg "  741.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_2518, SecMask, Heap[this#727, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#727, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2517[Heap[this#727, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_2518);
    assume wf(Heap, exhaleMask#_2518, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#727, AVLTreeNode.right] == null)) {
    assert {:msg "  741.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  741.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2518);
    assume wf(Heap, exhaleMask#_2518, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#727, AVLTreeNode.right] == null)) {
    assert {:msg "  741.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  741.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2518);
    assume wf(Heap, exhaleMask#_2518, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#727, AVLTreeNode.right] == null)) {
    assert {:msg "  741.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  741.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2518[Heap[this#727, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2518);
    assume wf(Heap, exhaleMask#_2518, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_2518;
  assume IsGoodExhaleState(exhaleHeap#_2517, Heap, Mask, SecMask);
  Heap := exhaleHeap#_2517;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#727 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#727, AVLTreeNode.valid] := Mask[this#727, AVLTreeNode.valid][perm$R := Mask[this#727, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#727, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#727 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#727, AVLTreeNode.height] := Mask[this#727, AVLTreeNode.height][perm$R := Mask[this#727, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#727, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#727 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#727, AVLTreeNode.keys] := Mask[this#727, AVLTreeNode.keys][perm$R := Mask[this#727, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#727, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#727 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#727, AVLTreeNode.balanceFactor] := Mask[this#727, AVLTreeNode.balanceFactor][perm$R := Mask[this#727, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#727, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#727, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2512[this#727, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2512[callHeap#_2512[this#727, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2512[this#727, AVLTreeNode.key])), ite(callHeap#_2512[this#727, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_2512[callHeap#_2512[this#727, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#727, AVLTreeNode.height] == ite(ite(callHeap#_2512[this#727, AVLTreeNode.left] == null, 0, callHeap#_2512[callHeap#_2512[this#727, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_2512[this#727, AVLTreeNode.right] == null, 0, callHeap#_2512[callHeap#_2512[this#727, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_2512[this#727, AVLTreeNode.left] == null, 0, callHeap#_2512[callHeap#_2512[this#727, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_2512[this#727, AVLTreeNode.right] == null, 0, callHeap#_2512[callHeap#_2512[this#727, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#727, AVLTreeNode.balanceFactor] == (ite(callHeap#_2512[this#727, AVLTreeNode.left] == null, 0, callHeap#_2512[callHeap#_2512[this#727, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_2512[this#727, AVLTreeNode.right] == null, 0, callHeap#_2512[callHeap#_2512[this#727, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_2536 := Mask;
  havoc exhaleHeap#_2535;
  assert {:msg "  701.2: The postcondition at 727.11 might not hold. The expression at 727.11 might not evaluate to true."} !(r#67 == null);
  assert {:msg "  701.2: The postcondition at 733.11 might not hold. The expression at 733.11 might not evaluate to true."} (Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#67, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height] + 1));
  assert {:msg "  701.2: The postcondition at 734.11 might not hold. The expression at 734.11 might not evaluate to true."} Seq#Equal(Heap[r#67, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  701.2: The postcondition at 728.11 might not hold. The permission at 728.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  701.2: The postcondition at 728.11 might not hold. Insufficient fraction at 728.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2536[r#67, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2536[r#67, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2536[r#67, AVLTreeNode.valid][perm$N]));
  exhaleMask#_2536[r#67, AVLTreeNode.valid] := exhaleMask#_2536[r#67, AVLTreeNode.valid][perm$R := exhaleMask#_2536[r#67, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (!CanRead(exhaleMask#_2536, SecMask, r#67, AVLTreeNode.valid)) {
    assume Heap[r#67, AVLTreeNode.valid] < exhaleHeap#_2535[r#67, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_2536);
  assume wf(Heap, exhaleMask#_2536, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  701.2: The postcondition at 729.11 might not hold. The permission at 729.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  701.2: The postcondition at 729.11 might not hold. Insufficient fraction at 729.11 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2536[r#67, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2536[r#67, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2536[r#67, AVLTreeNode.height][perm$N]));
  exhaleMask#_2536[r#67, AVLTreeNode.height] := exhaleMask#_2536[r#67, AVLTreeNode.height][perm$R := exhaleMask#_2536[r#67, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_2536);
  assume wf(Heap, exhaleMask#_2536, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  701.2: The postcondition at 730.11 might not hold. The permission at 730.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  701.2: The postcondition at 730.11 might not hold. Insufficient fraction at 730.11 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2536[r#67, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2536[r#67, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2536[r#67, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2536[r#67, AVLTreeNode.keys] := exhaleMask#_2536[r#67, AVLTreeNode.keys][perm$R := exhaleMask#_2536[r#67, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_2536);
  assume wf(Heap, exhaleMask#_2536, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  701.2: The postcondition at 731.11 might not hold. The permission at 731.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  701.2: The postcondition at 731.11 might not hold. Insufficient fraction at 731.11 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2536[r#67, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2536[r#67, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2536[r#67, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2536[r#67, AVLTreeNode.balanceFactor] := exhaleMask#_2536[r#67, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2536[r#67, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_2536);
  assume wf(Heap, exhaleMask#_2536, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_2536;
  assume IsGoodExhaleState(exhaleHeap#_2535, Heap, Mask, SecMask);
  Heap := exhaleHeap#_2535;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  701.2: Method might lock/unlock more than allowed."} (forall lk#_2541: ref :: {Heap[lk#_2541, held]} {Heap[lk#_2541, rdheld]} (((0 < Heap[lk#_2541, held]) == (0 < old(Heap)[lk#_2541, held])) && (Heap[lk#_2541, rdheld] == old(Heap)[lk#_2541, rdheld])) || false);
  assert {:msg "  701.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceRight$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#68: ref where (r#68 == null) || (dtype(r#68) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2542: int;
  var k#104#733: int where true;
  var k#105#735: int where true;
  assume (0 < methodK#_2542) && ((1000 * methodK#_2542) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  754.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  754.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  754.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  754.25: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  754.25: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  754.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  754.25: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  755.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  755.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  755.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  755.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  756.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  756.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  756.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  756.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  757.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  757.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  757.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  757.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  758.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  758.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  758.12: Receiver might be null."} true && (0 <= k#104#733) ==> (this != null);
    assert {:msg "  758.12: Location might not be readable."} true && (0 <= k#104#733) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  758.12: Receiver might be null."} true && (0 <= k#104#733) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  758.12: Location might not be readable."} true && (0 <= k#104#733) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  758.12: Receiver might be null."} true && (0 <= k#104#733) && (k#104#733 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  758.12: Location might not be readable."} true && (0 <= k#104#733) && (k#104#733 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  758.12: Receiver might be null."} true && (0 <= k#104#733) && (k#104#733 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  758.12: Location might not be readable."} true && (0 <= k#104#733) && (k#104#733 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  758.50: Sequence index might be negative."} true && (0 <= k#104#733) && (k#104#733 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#104#733);
    assert {:msg "  758.50: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#104#733) && (k#104#733 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#104#733 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  758.54: Receiver might be null."} true && (0 <= k#104#733) && (k#104#733 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  758.54: Location might not be readable."} true && (0 <= k#104#733) && (k#104#733 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    assume (forall k#104#732: int :: (0 <= k#104#732) && (k#104#732 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#104#732) < Heap[this, AVLTreeNode.key]));
  }
  assert {:msg "  760.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  760.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume !(Heap[this, AVLTreeNode.right] == null);
  assert {:msg "  761.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  761.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  761.12: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
  assert {:msg "  761.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  761.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  762.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  762.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  763.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  763.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  764.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  764.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  765.12: Receiver might be null."} true && (0 <= k#105#735) ==> (this != null);
  assert {:msg "  765.12: Location might not be readable."} true && (0 <= k#105#735) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  765.12: Receiver might be null."} true && (0 <= k#105#735) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  765.12: Location might not be readable."} true && (0 <= k#105#735) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  765.38: Receiver might be null."} true && (0 <= k#105#735) && (k#105#735 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  765.38: Location might not be readable."} true && (0 <= k#105#735) && (k#105#735 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  assert {:msg "  765.12: Receiver might be null."} true && (0 <= k#105#735) && (k#105#735 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  765.12: Location might not be readable."} true && (0 <= k#105#735) && (k#105#735 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  765.12: Receiver might be null."} true && (0 <= k#105#735) && (k#105#735 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  765.12: Location might not be readable."} true && (0 <= k#105#735) && (k#105#735 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  765.44: Sequence index might be negative."} true && (0 <= k#105#735) && (k#105#735 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#105#735);
  assert {:msg "  765.44: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#105#735) && (k#105#735 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#105#735 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume (forall k#105#734: int :: (0 <= k#105#734) && (k#105#734 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#105#734)));
  assert {:msg "  768.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  768.13: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  768.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  768.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  768.26: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  768.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  768.39: Receiver might be null."} true ==> (this != null);
  assert {:msg "  768.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  768.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  768.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#68 == null);
  assert {:msg "  771.11: Receiver might be null."} r#68 != null;
  assume r#68 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[r#68, AVLTreeNode.valid] := Mask[r#68, AVLTreeNode.valid][perm$R := Mask[r#68, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#68, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#68 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#68, AVLTreeNode.height] := Mask[r#68, AVLTreeNode.height][perm$R := Mask[r#68, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#68, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#68 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#68, AVLTreeNode.keys] := Mask[r#68, AVLTreeNode.keys][perm$R := Mask[r#68, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#68, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#68 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#68, AVLTreeNode.balanceFactor] := Mask[r#68, AVLTreeNode.balanceFactor][perm$R := Mask[r#68, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#68, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  776.11: Receiver might be null."} true ==> (r#68 != null);
  assert {:msg "  776.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#68, AVLTreeNode.height);
  assert {:msg "  776.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  776.27: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  assert {:msg "  776.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  776.27: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assert {:msg "  776.44: Receiver might be null."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (r#68 != null);
  assert {:msg "  776.44: Location might not be readable."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(Mask, SecMask, r#68, AVLTreeNode.height);
  assert {:msg "  776.60: Receiver might be null."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  776.60: Location might not be readable."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  assert {:msg "  776.60: Receiver might be null."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  776.60: Location might not be readable."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#68, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height] + 1));
  assert {:msg "  777.11: Receiver might be null."} true ==> (r#68 != null);
  assert {:msg "  777.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#68, AVLTreeNode.keys);
  assert {:msg "  777.26: Receiver might be null."} true ==> (this != null);
  assert {:msg "  777.26: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  777.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  777.51: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
    assert {:msg "  777.51: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  777.51: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  777.71: Receiver might be null."} true ==> (this != null);
  assert {:msg "  777.71: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.key);
  assert {:msg "  777.84: Receiver might be null."} true ==> (this != null);
  assert {:msg "  777.84: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  assert {:msg "  777.84: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  777.84: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  assume Seq#Equal(Heap[r#68, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.rebalanceRight(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#68: ref where (r#68 == null) || (dtype(r#68) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2542: int;
  var rbf#70: int where true;
  var methodCallK#_2547: int;
  var this#738: ref where (this#738 == null) || (dtype(this#738) == AVLTreeNode#t);
  var bf#739: int where true;
  var callHeap#_2543: HeapType;
  var callMask#_2544: MaskType;
  var callSecMask#_2545: MaskType;
  var callCredits#_2546: CreditsType;
  var exhaleMask#_2549: MaskType;
  var exhaleHeap#_2548: HeapType;
  var isHeld#_2552: int;
  var isRdHeld#_2553: bool;
  var predRec#_2554: ref;
  var predFlag#_2556: bool;
  var predVer#_2555: int;
  var predRec#_2573: ref;
  var predFlag#_2575: bool;
  var predVer#_2574: int;
  var cond#_2592: bool;
  var assertHeap#_2593: HeapType;
  var assertMask#_2594: MaskType;
  var assertSecMask#_2595: MaskType;
  var assertCredits#_2596: CreditsType;
  var exhaleMask#_2598: MaskType;
  var exhaleHeap#_2597: HeapType;
  var unfoldingK#_2604: int;
  var predFlag#_2603: bool;
  var unfoldingHeap#_2599: HeapType;
  var unfoldingMask#_2600: MaskType;
  var unfoldingSecMask#_2601: MaskType;
  var unfoldingCredits#_2602: CreditsType;
  var oldVers#_2624: int;
  var newVers#_2625: int;
  var methodCallK#_2646: int;
  var this#764: ref where (this#764 == null) || (dtype(this#764) == AVLTreeNode#t);
  var r#765: ref where (r#765 == null) || (dtype(r#765) == AVLTreeNode#t);
  var callHeap#_2642: HeapType;
  var callMask#_2643: MaskType;
  var callSecMask#_2644: MaskType;
  var callCredits#_2645: CreditsType;
  var exhaleMask#_2648: MaskType;
  var exhaleHeap#_2647: HeapType;
  var isHeld#_2759: int;
  var isRdHeld#_2760: bool;
  var methodCallK#_2765: int;
  var this#794: ref where (this#794 == null) || (dtype(this#794) == AVLTreeNode#t);
  var r#795: ref where (r#795 == null) || (dtype(r#795) == AVLTreeNode#t);
  var callHeap#_2761: HeapType;
  var callMask#_2762: MaskType;
  var callSecMask#_2763: MaskType;
  var callCredits#_2764: CreditsType;
  var exhaleMask#_2767: MaskType;
  var exhaleHeap#_2766: HeapType;
  var isHeld#_2878: int;
  var isRdHeld#_2879: bool;
  var exhaleMask#_2881: MaskType;
  var exhaleHeap#_2880: HeapType;
  assume (0 < methodK#_2542) && ((1000 * methodK#_2542) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall k#104#736: int :: (0 <= k#104#736) && (k#104#736 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#104#736) < Heap[this, AVLTreeNode.key]));
  }
  assume !(Heap[this, AVLTreeNode.right] == null);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume (forall k#105#737: int :: (0 <= k#105#737) && (k#105#737 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#105#737)));
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // local var rbf
  assume (0 < methodCallK#_2547) && ((1000 * methodCallK#_2547) < Fractions(1)) && ((1000 * methodCallK#_2547) < methodK#_2542);
  // call getBalanceFactor
  callHeap#_2543 := Heap;
  callMask#_2544 := Mask;
  callSecMask#_2545 := SecMask;
  callCredits#_2546 := Credits;
  assume wf(callHeap#_2543, callMask#_2544, callSecMask#_2545);
  assert {:msg "  780.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  780.15: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  780.3: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
  this#738 := Heap[this, AVLTreeNode.right];
  // begin exhale (precondition)
  exhaleMask#_2549 := Mask;
  havoc exhaleHeap#_2548;
  assert {:msg "  780.3: The precondition at 489.12 might not hold. The permission at 489.12 might not be positive."} methodCallK#_2547 > 0;
  assert {:msg "  780.3: The precondition at 489.12 might not hold. Insufficient fraction at 489.12 for AVLTreeNode.balanceFactor."} exhaleMask#_2549[this#738, AVLTreeNode.balanceFactor][perm$R] > 0;
  assume methodCallK#_2547 < exhaleMask#_2549[this#738, AVLTreeNode.balanceFactor][perm$R];
  exhaleMask#_2549[this#738, AVLTreeNode.balanceFactor] := exhaleMask#_2549[this#738, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2549[this#738, AVLTreeNode.balanceFactor][perm$R] - methodCallK#_2547];
  assume IsGoodMask(exhaleMask#_2549);
  assume wf(Heap, exhaleMask#_2549, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  780.3: The precondition at 488.12 might not hold. The permission at 488.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  780.3: The precondition at 488.12 might not hold. Insufficient fraction at 488.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2549[this#738, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2549[this#738, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2549[this#738, AVLTreeNode.valid][perm$N]));
  exhaleMask#_2549[this#738, AVLTreeNode.valid] := exhaleMask#_2549[this#738, AVLTreeNode.valid][perm$R := exhaleMask#_2549[this#738, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (!CanRead(exhaleMask#_2549, SecMask, this#738, AVLTreeNode.valid)) {
    assume Heap[this#738, AVLTreeNode.valid] < exhaleHeap#_2548[this#738, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_2549);
  assume wf(Heap, exhaleMask#_2549, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_2549;
  assume IsGoodExhaleState(exhaleHeap#_2548, Heap, Mask, SecMask);
  Heap := exhaleHeap#_2548;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  havoc bf#739;
  // inhale (postcondition)
  assume this#738 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#738, AVLTreeNode.valid] := Mask[this#738, AVLTreeNode.valid][perm$R := Mask[this#738, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#738, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#738 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodCallK#_2547 > 0;
  Mask[this#738, AVLTreeNode.balanceFactor] := Mask[this#738, AVLTreeNode.balanceFactor][perm$R := Mask[this#738, AVLTreeNode.balanceFactor][perm$R] + methodCallK#_2547];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#738, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume bf#739 == Heap[this#738, AVLTreeNode.balanceFactor];
  predRec#_2554 := this#738;
  predFlag#_2556 := true;
  assume #AVLTreeNode.valid#trigger(this#738);
  predVer#_2555 := Heap[this#738, AVLTreeNode.valid];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[this#738, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#740: int :: (0 <= lk#79#740) && (lk#79#740 < Seq#Length(Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys], lk#79#740) < Heap[this#738, AVLTreeNode.key]));
    }
    if (!(Heap[this#738, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this#738, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#741: int :: (0 <= rk#80#741) && (rk#80#741 < Seq#Length(Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#738, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys], rk#80#741)));
    }
    if (!(Heap[this#738, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this#738, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this#738, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this#738, AVLTreeNode.key])), ite(Heap[this#738, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this#738, AVLTreeNode.keys], Heap[this#738, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this#738, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this#738, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this#738, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this#738, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this#738, AVLTreeNode.height] == ite(ite(Heap[this#738, AVLTreeNode.left] == null, 0, Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this#738, AVLTreeNode.right] == null, 0, Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this#738, AVLTreeNode.left] == null, 0, Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this#738, AVLTreeNode.right] == null, 0, Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this#738, AVLTreeNode.balanceFactor] == (ite(Heap[this#738, AVLTreeNode.left] == null, 0, Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#738, AVLTreeNode.right] == null, 0, Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this#738, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this#738, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this#738, AVLTreeNode.height] > 0;
    SecMask[this#738, AVLTreeNode.key] := SecMask[this#738, AVLTreeNode.key][perm$R := SecMask[this#738, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this#738, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this#738, AVLTreeNode.key] := SecMask[this#738, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#738, AVLTreeNode.height] := SecMask[this#738, AVLTreeNode.height][perm$R := SecMask[this#738, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this#738, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this#738, AVLTreeNode.height] := SecMask[this#738, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#738, AVLTreeNode.left] := SecMask[this#738, AVLTreeNode.left][perm$R := SecMask[this#738, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this#738, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this#738, AVLTreeNode.left] := SecMask[this#738, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#738, AVLTreeNode.right] := SecMask[this#738, AVLTreeNode.right][perm$R := SecMask[this#738, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this#738, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this#738, AVLTreeNode.right] := SecMask[this#738, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#738, AVLTreeNode.keys] := SecMask[this#738, AVLTreeNode.keys][perm$R := SecMask[this#738, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this#738, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this#738, AVLTreeNode.keys] := SecMask[this#738, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#738, AVLTreeNode.balanceFactor] := SecMask[this#738, AVLTreeNode.balanceFactor][perm$R := SecMask[this#738, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this#738, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this#738, AVLTreeNode.balanceFactor] := SecMask[this#738, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#738, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  assume predRec#_2554 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  SecMask[predRec#_2554, AVLTreeNode.key] := SecMask[predRec#_2554, AVLTreeNode.key][perm$R := SecMask[predRec#_2554, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2554, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2554 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_2554, AVLTreeNode.height] := SecMask[predRec#_2554, AVLTreeNode.height][perm$R := SecMask[predRec#_2554, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2554, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2554 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2554, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_2554, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[predRec#_2554, AVLTreeNode.left] := SecMask[predRec#_2554, AVLTreeNode.left][perm$R := SecMask[predRec#_2554, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2554, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2554 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2554, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_2554, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[predRec#_2554, AVLTreeNode.right] := SecMask[predRec#_2554, AVLTreeNode.right][perm$R := SecMask[predRec#_2554, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2554, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2554 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_2554, AVLTreeNode.keys] := SecMask[predRec#_2554, AVLTreeNode.keys][perm$R := SecMask[predRec#_2554, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2554, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2554 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_2554, AVLTreeNode.balanceFactor] := SecMask[predRec#_2554, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_2554, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2554, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_2554, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2554, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2554, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2554, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2554, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2554, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2554, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2554, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2554, AVLTreeNode.left] == null)) {
    assume (forall lk#79#744: int :: (0 <= lk#79#744) && (lk#79#744 < Seq#Length(Heap[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.keys], lk#79#744) < Heap[predRec#_2554, AVLTreeNode.key]));
  }
  if (!(Heap[predRec#_2554, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_2554, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2554, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2554, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2554, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2554, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2554, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2554, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2554, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2554, AVLTreeNode.right] == null)) {
    assume (forall rk#80#745: int :: (0 <= rk#80#745) && (rk#80#745 < Seq#Length(Heap[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_2554, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.keys], rk#80#745)));
  }
  if (!(Heap[predRec#_2554, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_2554, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_2554, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_2554, AVLTreeNode.key])), ite(Heap[predRec#_2554, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_2554, AVLTreeNode.keys], Heap[predRec#_2554, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[predRec#_2554, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_2554, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_2554, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_2554, AVLTreeNode.key])));
  assume Heap[predRec#_2554, AVLTreeNode.height] == ite(ite(Heap[predRec#_2554, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_2554, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_2554, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_2554, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_2554, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_2554, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2554, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_2554, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2554, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_2554, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_2554, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_2554, AVLTreeNode.height] > 0;
  assume (bf#739 > 0) ==> (!(Heap[this#738, AVLTreeNode.left] == null));
  predRec#_2573 := this#738;
  predFlag#_2575 := true;
  assume #AVLTreeNode.valid#trigger(this#738);
  predVer#_2574 := Heap[this#738, AVLTreeNode.valid];
  if (false || ((predVer#_2555 == Heap[this#738, AVLTreeNode.valid]) && (predRec#_2554 == this#738) && true && predFlag#_2556)) {
    // begin exhale (update SecMask)
    if (!(Heap[this#738, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#746: int :: (0 <= lk#79#746) && (lk#79#746 < Seq#Length(Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys], lk#79#746) < Heap[this#738, AVLTreeNode.key]));
    }
    if (!(Heap[this#738, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[this#738, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#747: int :: (0 <= rk#80#747) && (rk#80#747 < Seq#Length(Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#738, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys], rk#80#747)));
    }
    if (!(Heap[this#738, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[this#738, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this#738, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this#738, AVLTreeNode.key])), ite(Heap[this#738, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[this#738, AVLTreeNode.keys], Heap[this#738, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[this#738, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this#738, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this#738, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this#738, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[this#738, AVLTreeNode.height] == ite(ite(Heap[this#738, AVLTreeNode.left] == null, 0, Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this#738, AVLTreeNode.right] == null, 0, Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this#738, AVLTreeNode.left] == null, 0, Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this#738, AVLTreeNode.right] == null, 0, Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[this#738, AVLTreeNode.balanceFactor] == (ite(Heap[this#738, AVLTreeNode.left] == null, 0, Heap[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#738, AVLTreeNode.right] == null, 0, Heap[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[this#738, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[this#738, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[this#738, AVLTreeNode.height] > 0;
    SecMask[this#738, AVLTreeNode.key] := SecMask[this#738, AVLTreeNode.key][perm$R := SecMask[this#738, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[this#738, AVLTreeNode.key][perm$R] < 0) {
      SecMask[this#738, AVLTreeNode.key] := SecMask[this#738, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#738, AVLTreeNode.height] := SecMask[this#738, AVLTreeNode.height][perm$R := SecMask[this#738, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[this#738, AVLTreeNode.height][perm$R] < 0) {
      SecMask[this#738, AVLTreeNode.height] := SecMask[this#738, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#738, AVLTreeNode.left] := SecMask[this#738, AVLTreeNode.left][perm$R := SecMask[this#738, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[this#738, AVLTreeNode.left][perm$R] < 0) {
      SecMask[this#738, AVLTreeNode.left] := SecMask[this#738, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#738, AVLTreeNode.right] := SecMask[this#738, AVLTreeNode.right][perm$R := SecMask[this#738, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[this#738, AVLTreeNode.right][perm$R] < 0) {
      SecMask[this#738, AVLTreeNode.right] := SecMask[this#738, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#738, AVLTreeNode.keys] := SecMask[this#738, AVLTreeNode.keys][perm$R := SecMask[this#738, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[this#738, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[this#738, AVLTreeNode.keys] := SecMask[this#738, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[this#738, AVLTreeNode.balanceFactor] := SecMask[this#738, AVLTreeNode.balanceFactor][perm$R := SecMask[this#738, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[this#738, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[this#738, AVLTreeNode.balanceFactor] := SecMask[this#738, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#738, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.left] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#738, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#738, AVLTreeNode.right] == null)) {
      SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#738, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  assume predRec#_2573 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  SecMask[predRec#_2573, AVLTreeNode.key] := SecMask[predRec#_2573, AVLTreeNode.key][perm$R := SecMask[predRec#_2573, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2573, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2573 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_2573, AVLTreeNode.height] := SecMask[predRec#_2573, AVLTreeNode.height][perm$R := SecMask[predRec#_2573, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2573, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2573 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2573, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_2573, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[predRec#_2573, AVLTreeNode.left] := SecMask[predRec#_2573, AVLTreeNode.left][perm$R := SecMask[predRec#_2573, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2573, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2573 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2573, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_2573, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[predRec#_2573, AVLTreeNode.right] := SecMask[predRec#_2573, AVLTreeNode.right][perm$R := SecMask[predRec#_2573, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2573, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2573 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_2573, AVLTreeNode.keys] := SecMask[predRec#_2573, AVLTreeNode.keys][perm$R := SecMask[predRec#_2573, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2573, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2573 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_2573, AVLTreeNode.balanceFactor] := SecMask[predRec#_2573, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_2573, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2573, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_2573, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2573, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2573, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2573, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2573, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2573, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2573, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2573, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2573, AVLTreeNode.left] == null)) {
    assume (forall lk#79#750: int :: (0 <= lk#79#750) && (lk#79#750 < Seq#Length(Heap[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.keys], lk#79#750) < Heap[predRec#_2573, AVLTreeNode.key]));
  }
  if (!(Heap[predRec#_2573, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_2573, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2573, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2573, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2573, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2573, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2573, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2573, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2573, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2573, AVLTreeNode.right] == null)) {
    assume (forall rk#80#751: int :: (0 <= rk#80#751) && (rk#80#751 < Seq#Length(Heap[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_2573, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.keys], rk#80#751)));
  }
  if (!(Heap[predRec#_2573, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_2573, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_2573, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_2573, AVLTreeNode.key])), ite(Heap[predRec#_2573, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_2573, AVLTreeNode.keys], Heap[predRec#_2573, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[predRec#_2573, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_2573, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_2573, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_2573, AVLTreeNode.key])));
  assume Heap[predRec#_2573, AVLTreeNode.height] == ite(ite(Heap[predRec#_2573, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_2573, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_2573, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_2573, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_2573, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_2573, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2573, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_2573, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2573, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_2573, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_2573, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_2573, AVLTreeNode.height] > 0;
  assume (bf#739 < 0) ==> (!(Heap[this#738, AVLTreeNode.right] == null));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  rbf#70 := bf#739;
  // if
  cond#_2592 := rbf#70 > 0;
  if (cond#_2592) {
    // assert
    assertHeap#_2593 := Heap;
    assertMask#_2594 := Mask;
    assertSecMask#_2595 := SecMask;
    assertCredits#_2596 := Credits;
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    // begin exhale (assert)
    exhaleMask#_2598 := assertMask#_2594;
    havoc exhaleHeap#_2597;
    // unfolding
    assume (0 < unfoldingK#_2604) && ((1000 * unfoldingK#_2604) < Fractions(1));
    predFlag#_2603 := true;
    assert {:msg "  782.21: Receiver might be null."} true ==> (this != null);
    assert {:msg "  782.21: Location might not be readable."} true ==> CanRead(assertMask#_2594, assertSecMask#_2595, this, AVLTreeNode.right);
    assert {:msg "  782.21: Receiver might be null."} true ==> (assertHeap#_2593[this, AVLTreeNode.right] != null);
    unfoldingHeap#_2599 := assertHeap#_2593;
    unfoldingMask#_2600 := assertMask#_2594;
    unfoldingSecMask#_2601 := assertSecMask#_2595;
    unfoldingCredits#_2602 := assertCredits#_2596;
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    // begin exhale (unfolding)
    assert {:msg "  782.11: Unfolding might fail. The permission at 782.21 might not be positive."} Fractions(100) > 0;
    assert {:msg "  782.11: Unfolding might fail. Insufficient fraction at 782.21 for AVLTreeNode.valid."} (Fractions(100) <= unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if ((false || ((predVer#_2574 == unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2573 == unfoldingHeap#_2599[this, AVLTreeNode.right]) && true && predFlag#_2575)) || ((predVer#_2555 == unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == unfoldingHeap#_2599[this, AVLTreeNode.right]) && true && predFlag#_2556)) {
      if ((predVer#_2555 == unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == unfoldingHeap#_2599[this, AVLTreeNode.right]) && true && predFlag#_2556) {
      } else {
      }
      // begin exhale (update SecMask)
      if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#752: int :: (0 <= lk#79#752) && (lk#79#752 < Seq#Length(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#752) < unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#753: int :: (0 <= rk#80#753) && (rk#80#753 < Seq#Length(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#753)));
      }
      if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
      unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2601[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
        assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      }
      if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
        assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      }
      if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
        assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      }
      if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
        assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      }
      if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
        assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      }
      if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
        assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      }
      if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
        assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      }
      if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2601[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
        assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      }
      assume wf(unfoldingHeap#_2599, unfoldingSecMask#_2601, unfoldingSecMask#_2601);
      // end exhale
    }
    if (!CanRead(unfoldingMask#_2600, unfoldingSecMask#_2601, unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid)) {
      oldVers#_2624 := unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid];
      havoc newVers#_2625;
      unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_2625;
      assume oldVers#_2624 < unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(unfoldingMask#_2600);
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume IsGoodMask(unfoldingMask#_2600);
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    // end exhale
    // inhale (unfolding)
    assume unfoldingHeap#_2599[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume true;
    assume Fractions(100) > 0;
    unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_2600);
    assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key]));
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume unfoldingHeap#_2599[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2600);
    assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume unfoldingHeap#_2599[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume (unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_2600);
    assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left]));
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume unfoldingHeap#_2599[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume (unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_2600);
    assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right]));
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume unfoldingHeap#_2599[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2600);
    assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume unfoldingHeap#_2599[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2600);
    assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume Fractions(100) > 0;
      unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(unfoldingMask#_2600);
      assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    }
    if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_2600);
      assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    }
    if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_2600);
      assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]));
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    }
    if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_2600);
      assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    }
    if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume (forall lk#79#756: int :: (0 <= lk#79#756) && (lk#79#756 < Seq#Length(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#756) < unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key]));
    }
    if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume Fractions(100) > 0;
      unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(unfoldingMask#_2600);
      assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    }
    if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_2600);
      assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    }
    if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_2600);
      assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]));
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    }
    if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume true;
      assume Fractions(50) > 0;
      unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2600[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(unfoldingMask#_2600);
      assume IsGoodState(heapFragment(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
      assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    }
    if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume (forall rk#80#757: int :: (0 <= rk#80#757) && (rk#80#757 < Seq#Length(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#757)));
    }
    if (!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key]);
    assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.key])));
    assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2599[unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume unfoldingHeap#_2599[unfoldingHeap#_2599[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    assume IsGoodMask(unfoldingMask#_2600);
    assume wf(unfoldingHeap#_2599, unfoldingMask#_2600, unfoldingSecMask#_2601);
    // end inhale
    if ((false || ((predVer#_2574 == assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2573 == assertHeap#_2593[this, AVLTreeNode.right]) && true && predFlag#_2575)) || ((predVer#_2555 == assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == assertHeap#_2593[this, AVLTreeNode.right]) && true && predFlag#_2556)) {
      if ((predVer#_2555 == assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == assertHeap#_2593[this, AVLTreeNode.right]) && true && predFlag#_2556) {
      } else {
      }
      // begin exhale (update SecMask)
      if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#758: int :: (0 <= lk#79#758) && (lk#79#758 < Seq#Length(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#758) < assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#759: int :: (0 <= rk#80#759) && (rk#80#759 < Seq#Length(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#759)));
      }
      if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key])), ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys], assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
      assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
        assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      }
      if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
        assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      }
      if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
        assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      }
      if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
        assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      }
      if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
        assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      }
      if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
        assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      }
      if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
        assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      }
      if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
        assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      }
      assume wf(assertHeap#_2593, assertSecMask#_2595, assertSecMask#_2595);
      // end exhale
    }
    assume assertHeap#_2593[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume true;
    assume Fractions(100) > 0;
    assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_2594);
    assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key]));
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume assertHeap#_2593[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_2594);
    assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume assertHeap#_2593[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume (assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_2594);
    assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left]));
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume assertHeap#_2593[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume (assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
    assume Fractions(100) > 0;
    assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + Fractions(100)];
    assume IsGoodMask(assertMask#_2594);
    assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right]));
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume assertHeap#_2593[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_2594);
    assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume assertHeap#_2593[this, AVLTreeNode.right] != null;
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume true;
    assume Fractions(50) > 0;
    assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_2595[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(assertMask#_2594);
    assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume Fractions(100) > 0;
      assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(assertMask#_2594);
      assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]));
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    }
    if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_2594);
      assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]));
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    }
    if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_2594);
      assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]));
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    }
    if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_2594);
      assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    }
    if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume (forall lk#79#762: int :: (0 <= lk#79#762) && (lk#79#762 < Seq#Length(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#762) < assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key]));
    }
    if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume Fractions(100) > 0;
      assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(assertMask#_2594);
      assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]));
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    }
    if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_2594);
      assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    }
    if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_2594);
      assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]));
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    }
    if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume true;
      assume Fractions(50) > 0;
      assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := assertSecMask#_2595[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
      assume IsGoodMask(assertMask#_2594);
      assume IsGoodState(heapFragment(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
      assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    }
    if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume (forall rk#80#763: int :: (0 <= rk#80#763) && (rk#80#763 < Seq#Length(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#763)));
    }
    if (!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key])), ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys], assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key]);
    assume (forall kk#81: int :: Seq#Contains(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.key])));
    assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, assertHeap#_2593[assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume assertHeap#_2593[assertHeap#_2593[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    assert {:msg "  782.4: Assertion might not hold. The expression at 782.11 might not evaluate to true."} rbf#70 == 1;
    assertMask#_2594 := exhaleMask#_2598;
    assume IsGoodExhaleState(exhaleHeap#_2597, assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    assertHeap#_2593 := exhaleHeap#_2597;
    assume IsGoodMask(assertMask#_2594);
    assume wf(assertHeap#_2593, assertMask#_2594, assertSecMask#_2595);
    // end exhale
    assume (0 < methodCallK#_2646) && ((1000 * methodCallK#_2646) < Fractions(1)) && ((1000 * methodCallK#_2646) < methodK#_2542);
    // call rebalanceLR
    callHeap#_2642 := Heap;
    callMask#_2643 := Mask;
    callSecMask#_2644 := SecMask;
    callCredits#_2645 := Credits;
    assume wf(callHeap#_2642, callMask#_2643, callSecMask#_2644);
    assert {:msg "  783.4: The target of the method call might be null."} this != null;
    this#764 := this;
    // begin exhale (precondition)
    exhaleMask#_2648 := Mask;
    havoc exhaleHeap#_2647;
    if (!(Heap[this#764, AVLTreeNode.left] == null)) {
      assert {:msg "  783.4: The precondition at 803.12 might not hold. The expression at 803.25 might not evaluate to true."} (forall k#106#766: int :: (0 <= k#106#766) && (k#106#766 < Seq#Length(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys], k#106#766) < Heap[this#764, AVLTreeNode.key]));
    }
    assert {:msg "  783.4: The precondition at 805.12 might not hold. The expression at 805.12 might not evaluate to true."} !(Heap[this#764, AVLTreeNode.right] == null);
    assert {:msg "  783.4: The precondition at 810.12 might not hold. The expression at 810.12 might not evaluate to true."} (forall k#107#767: int :: (0 <= k#107#767) && (k#107#767 < Seq#Length(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#764, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys], k#107#767)));
    assert {:msg "  783.4: The precondition at 812.12 might not hold. The expression at 812.12 might not evaluate to true."} !(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] == null);
    assert {:msg "  783.4: The precondition at 814.12 might not hold. The expression at 814.12 might not evaluate to true."} (ite(Heap[this#764, AVLTreeNode.left] == null, 0, Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
    assert {:msg "  783.4: The precondition at 815.12 might not hold. The expression at 815.12 might not evaluate to true."} Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor] == 1;
    assert {:msg "  783.4: The precondition at 791.12 might not hold. The permission at 791.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  783.4: The precondition at 791.12 might not hold. Insufficient fraction at 791.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_2648[this#764, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_2648[this#764, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_2648[this#764, AVLTreeNode.key][perm$N]));
    exhaleMask#_2648[this#764, AVLTreeNode.key] := exhaleMask#_2648[this#764, AVLTreeNode.key][perm$R := exhaleMask#_2648[this#764, AVLTreeNode.key][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_2648);
    assume wf(Heap, exhaleMask#_2648, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 792.12 might not hold. The permission at 792.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  783.4: The precondition at 792.12 might not hold. Insufficient fraction at 792.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_2648[this#764, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_2648[this#764, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2648[this#764, AVLTreeNode.height][perm$N]));
    exhaleMask#_2648[this#764, AVLTreeNode.height] := exhaleMask#_2648[this#764, AVLTreeNode.height][perm$R := exhaleMask#_2648[this#764, AVLTreeNode.height][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_2648);
    assume wf(Heap, exhaleMask#_2648, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 793.12 might not hold. The permission at 793.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  783.4: The precondition at 793.12 might not hold. Insufficient fraction at 793.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_2648[this#764, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_2648[this#764, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_2648[this#764, AVLTreeNode.left][perm$N]));
    exhaleMask#_2648[this#764, AVLTreeNode.left] := exhaleMask#_2648[this#764, AVLTreeNode.left][perm$R := exhaleMask#_2648[this#764, AVLTreeNode.left][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_2648);
    assume wf(Heap, exhaleMask#_2648, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 794.12 might not hold. The permission at 794.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  783.4: The precondition at 794.12 might not hold. Insufficient fraction at 794.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_2648[this#764, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_2648[this#764, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_2648[this#764, AVLTreeNode.right][perm$N]));
    exhaleMask#_2648[this#764, AVLTreeNode.right] := exhaleMask#_2648[this#764, AVLTreeNode.right][perm$R := exhaleMask#_2648[this#764, AVLTreeNode.right][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_2648);
    assume wf(Heap, exhaleMask#_2648, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 796.12 might not hold. The permission at 796.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  783.4: The precondition at 796.12 might not hold. Insufficient fraction at 796.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_2648[this#764, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_2648[this#764, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2648[this#764, AVLTreeNode.keys][perm$N]));
    exhaleMask#_2648[this#764, AVLTreeNode.keys] := exhaleMask#_2648[this#764, AVLTreeNode.keys][perm$R := exhaleMask#_2648[this#764, AVLTreeNode.keys][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_2648);
    assume wf(Heap, exhaleMask#_2648, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 797.12 might not hold. The permission at 797.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  783.4: The precondition at 797.12 might not hold. Insufficient fraction at 797.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_2648[this#764, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_2648[this#764, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2648[this#764, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2648[this#764, AVLTreeNode.balanceFactor] := exhaleMask#_2648[this#764, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2648[this#764, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_2648);
    assume wf(Heap, exhaleMask#_2648, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#764, AVLTreeNode.left] == null)) {
      assert {:msg "  783.4: The precondition at 799.12 might not hold. The permission at 799.25 might not be positive."} Fractions(100) > 0;
      assert {:msg "  783.4: The precondition at 799.12 might not hold. Insufficient fraction at 799.25 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if ((false || ((predVer#_2574 == Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2573 == Heap[this#764, AVLTreeNode.left]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[this#764, AVLTreeNode.left]) && true && predFlag#_2556)) {
        if ((predVer#_2555 == Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[this#764, AVLTreeNode.left]) && true && predFlag#_2556) {
        } else {
        }
        // begin exhale (update SecMask)
        if (!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
          assume (forall lk#79#768: int :: (0 <= lk#79#768) && (lk#79#768 < Seq#Length(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#768) < Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.key]));
        }
        if (!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
          assume Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
          assume (forall rk#80#769: int :: (0 <= rk#80#769) && (rk#80#769 < Seq#Length(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#769)));
        }
        if (!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
          assume Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
        assume Seq#Equal(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
        //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
        assume Seq#Contains(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.key]);
        //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
        assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.key])));
        //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
        assume Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
        assume Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
        //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
        assume Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
        //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
        assume Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
        //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
        assume Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height] > 0;
        SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
        if (SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
          SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
        if (SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
          SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
        if (SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
          SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
          }
          assume Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] != Heap[this#764, AVLTreeNode.left];
          if ((false || ((predVer#_2574 == Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2573 == Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left]) && true && predFlag#_2556)) {
            if ((predVer#_2555 == Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left]) && true && predFlag#_2556) {
            } else {
            }
            // begin exhale (update SecMask)
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
              assume (forall lk#79#772: int :: (0 <= lk#79#772) && (lk#79#772 < Seq#Length(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#772) < Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key]));
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
              assume (forall rk#80#773: int :: (0 <= rk#80#773) && (rk#80#773 < Seq#Length(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#773)));
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
            }
            //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
            assume Seq#Equal(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
            //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
            assume Seq#Contains(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key]);
            //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
            assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key])));
            //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
            //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
            //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
            //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
            //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
              SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
              SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
              SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            assume wf(Heap, SecMask, SecMask);
            // end exhale
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
          }
          assume Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] != Heap[this#764, AVLTreeNode.left];
          if ((false || ((predVer#_2574 == Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2573 == Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right]) && true && predFlag#_2556)) {
            if ((predVer#_2555 == Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right]) && true && predFlag#_2556) {
            } else {
            }
            // begin exhale (update SecMask)
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
              assume (forall lk#79#776: int :: (0 <= lk#79#776) && (lk#79#776 < Seq#Length(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#776) < Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key]));
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
              assume (forall rk#80#777: int :: (0 <= rk#80#777) && (rk#80#777 < Seq#Length(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#777)));
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
            }
            //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
            assume Seq#Equal(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
            //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
            assume Seq#Contains(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key]);
            //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
            assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key])));
            //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
            //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
            //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
            //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
            //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
              SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
              SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
              SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            assume wf(Heap, SecMask, SecMask);
            // end exhale
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume wf(Heap, SecMask, SecMask);
        // end exhale
      }
      if (!CanRead(exhaleMask#_2648, SecMask, Heap[this#764, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#764, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2647[Heap[this#764, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_2648);
      assume wf(Heap, exhaleMask#_2648, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#764, AVLTreeNode.left] == null)) {
      assert {:msg "  783.4: The precondition at 800.12 might not hold. The permission at 800.25 might not be positive."} Fractions(50) > 0;
      assert {:msg "  783.4: The precondition at 800.12 might not hold. Insufficient fraction at 800.25 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_2648);
      assume wf(Heap, exhaleMask#_2648, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#764, AVLTreeNode.left] == null)) {
      assert {:msg "  783.4: The precondition at 801.12 might not hold. The permission at 801.25 might not be positive."} Fractions(50) > 0;
      assert {:msg "  783.4: The precondition at 801.12 might not hold. Insufficient fraction at 801.25 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_2648);
      assume wf(Heap, exhaleMask#_2648, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#764, AVLTreeNode.left] == null)) {
      assert {:msg "  783.4: The precondition at 802.12 might not hold. The permission at 802.25 might not be positive."} Fractions(50) > 0;
      assert {:msg "  783.4: The precondition at 802.12 might not hold. Insufficient fraction at 802.25 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2648[Heap[this#764, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_2648);
      assume wf(Heap, exhaleMask#_2648, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assert {:msg "  783.4: The precondition at 806.12 might not hold. The permission at 806.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  783.4: The precondition at 806.12 might not hold. Insufficient fraction at 806.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if ((false || ((predVer#_2574 == Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2573 == Heap[this#764, AVLTreeNode.right]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[this#764, AVLTreeNode.right]) && true && predFlag#_2556)) {
      if ((predVer#_2555 == Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[this#764, AVLTreeNode.right]) && true && predFlag#_2556) {
      } else {
      }
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#781: int :: (0 <= lk#79#781) && (lk#79#781 < Seq#Length(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#781) < Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#782: int :: (0 <= rk#80#782) && (rk#80#782 < Seq#Length(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#782)));
      }
      if (!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height] > 0;
      SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] != Heap[this#764, AVLTreeNode.right];
        if ((false || ((predVer#_2574 == Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2573 == Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left]) && true && predFlag#_2556)) {
          if ((predVer#_2555 == Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left]) && true && predFlag#_2556) {
          } else {
          }
          // begin exhale (update SecMask)
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
            assume (forall lk#79#785: int :: (0 <= lk#79#785) && (lk#79#785 < Seq#Length(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#785) < Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key]));
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
            assume (forall rk#80#786: int :: (0 <= rk#80#786) && (rk#80#786 < Seq#Length(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#786)));
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
          }
          //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
          assume Seq#Equal(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
          //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
          assume Seq#Contains(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key]);
          //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
          assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key])));
          //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
          //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
          //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
          //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
          //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          assume wf(Heap, SecMask, SecMask);
          // end exhale
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] != Heap[this#764, AVLTreeNode.right];
        if ((false || ((predVer#_2574 == Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2573 == Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right]) && true && predFlag#_2556)) {
          if ((predVer#_2555 == Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right]) && true && predFlag#_2556) {
          } else {
          }
          // begin exhale (update SecMask)
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
            assume (forall lk#79#789: int :: (0 <= lk#79#789) && (lk#79#789 < Seq#Length(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#789) < Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key]));
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
            assume (forall rk#80#790: int :: (0 <= rk#80#790) && (rk#80#790 < Seq#Length(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#790)));
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
          }
          //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
          assume Seq#Equal(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
          //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
          assume Seq#Contains(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key]);
          //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
          assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key])));
          //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
          //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
          //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
          //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
          //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          assume wf(Heap, SecMask, SecMask);
          // end exhale
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_2648, SecMask, Heap[this#764, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#764, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2647[Heap[this#764, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_2648);
    assume wf(Heap, exhaleMask#_2648, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 807.12 might not hold. The permission at 807.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  783.4: The precondition at 807.12 might not hold. Insufficient fraction at 807.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2648);
    assume wf(Heap, exhaleMask#_2648, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 808.12 might not hold. The permission at 808.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  783.4: The precondition at 808.12 might not hold. Insufficient fraction at 808.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2648);
    assume wf(Heap, exhaleMask#_2648, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 809.12 might not hold. The permission at 809.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  783.4: The precondition at 809.12 might not hold. Insufficient fraction at 809.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2648[Heap[this#764, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2648);
    assume wf(Heap, exhaleMask#_2648, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_2648;
    assume IsGoodExhaleState(exhaleHeap#_2647, Heap, Mask, SecMask);
    Heap := exhaleHeap#_2647;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#765;
    // inhale (postcondition)
    assume !(r#765 == null);
    assume r#765 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[r#765, AVLTreeNode.valid] := Mask[r#765, AVLTreeNode.valid][perm$R := Mask[r#765, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#765, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#765 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#765, AVLTreeNode.height] := Mask[r#765, AVLTreeNode.height][perm$R := Mask[r#765, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#765, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#765 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#765, AVLTreeNode.keys] := Mask[r#765, AVLTreeNode.keys][perm$R := Mask[r#765, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#765, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#765 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#765, AVLTreeNode.balanceFactor] := Mask[r#765, AVLTreeNode.balanceFactor][perm$R := Mask[r#765, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#765, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Heap[r#765, AVLTreeNode.height] == callHeap#_2642[callHeap#_2642[this#764, AVLTreeNode.right], AVLTreeNode.height];
    assume Seq#Equal(Heap[r#765, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2642[this#764, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2642[callHeap#_2642[this#764, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2642[this#764, AVLTreeNode.key])), callHeap#_2642[callHeap#_2642[this#764, AVLTreeNode.right], AVLTreeNode.keys]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    r#68 := r#765;
  } else {
    assume (0 < methodCallK#_2765) && ((1000 * methodCallK#_2765) < Fractions(1)) && ((1000 * methodCallK#_2765) < methodK#_2542);
    // call rebalanceLL
    callHeap#_2761 := Heap;
    callMask#_2762 := Mask;
    callSecMask#_2763 := SecMask;
    callCredits#_2764 := Credits;
    assume wf(callHeap#_2761, callMask#_2762, callSecMask#_2763);
    assert {:msg "  785.4: The target of the method call might be null."} this != null;
    this#794 := this;
    // begin exhale (precondition)
    exhaleMask#_2767 := Mask;
    havoc exhaleHeap#_2766;
    if (!(Heap[this#794, AVLTreeNode.left] == null)) {
      assert {:msg "  785.4: The precondition at 858.12 might not hold. The expression at 858.25 might not evaluate to true."} (forall k#112#796: int :: (0 <= k#112#796) && (k#112#796 < Seq#Length(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys], k#112#796) < Heap[this#794, AVLTreeNode.key]));
    }
    assert {:msg "  785.4: The precondition at 860.12 might not hold. The expression at 860.12 might not evaluate to true."} !(Heap[this#794, AVLTreeNode.right] == null);
    assert {:msg "  785.4: The precondition at 865.12 might not hold. The expression at 865.12 might not evaluate to true."} (forall k#113#797: int :: (0 <= k#113#797) && (k#113#797 < Seq#Length(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#794, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys], k#113#797)));
    assert {:msg "  785.4: The precondition at 867.12 might not hold. The expression at 867.12 might not evaluate to true."} (ite(Heap[this#794, AVLTreeNode.left] == null, 0, Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
    assert {:msg "  785.4: The precondition at 868.12 might not hold. The expression at 868.12 might not evaluate to true."} Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 0;
    assert {:msg "  785.4: The precondition at 846.12 might not hold. The permission at 846.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  785.4: The precondition at 846.12 might not hold. Insufficient fraction at 846.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_2767[this#794, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_2767[this#794, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_2767[this#794, AVLTreeNode.key][perm$N]));
    exhaleMask#_2767[this#794, AVLTreeNode.key] := exhaleMask#_2767[this#794, AVLTreeNode.key][perm$R := exhaleMask#_2767[this#794, AVLTreeNode.key][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_2767);
    assume wf(Heap, exhaleMask#_2767, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 847.12 might not hold. The permission at 847.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  785.4: The precondition at 847.12 might not hold. Insufficient fraction at 847.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_2767[this#794, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_2767[this#794, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2767[this#794, AVLTreeNode.height][perm$N]));
    exhaleMask#_2767[this#794, AVLTreeNode.height] := exhaleMask#_2767[this#794, AVLTreeNode.height][perm$R := exhaleMask#_2767[this#794, AVLTreeNode.height][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_2767);
    assume wf(Heap, exhaleMask#_2767, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 848.12 might not hold. The permission at 848.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  785.4: The precondition at 848.12 might not hold. Insufficient fraction at 848.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_2767[this#794, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_2767[this#794, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_2767[this#794, AVLTreeNode.left][perm$N]));
    exhaleMask#_2767[this#794, AVLTreeNode.left] := exhaleMask#_2767[this#794, AVLTreeNode.left][perm$R := exhaleMask#_2767[this#794, AVLTreeNode.left][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_2767);
    assume wf(Heap, exhaleMask#_2767, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 849.12 might not hold. The permission at 849.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  785.4: The precondition at 849.12 might not hold. Insufficient fraction at 849.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_2767[this#794, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_2767[this#794, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_2767[this#794, AVLTreeNode.right][perm$N]));
    exhaleMask#_2767[this#794, AVLTreeNode.right] := exhaleMask#_2767[this#794, AVLTreeNode.right][perm$R := exhaleMask#_2767[this#794, AVLTreeNode.right][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_2767);
    assume wf(Heap, exhaleMask#_2767, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 851.12 might not hold. The permission at 851.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  785.4: The precondition at 851.12 might not hold. Insufficient fraction at 851.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_2767[this#794, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_2767[this#794, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2767[this#794, AVLTreeNode.keys][perm$N]));
    exhaleMask#_2767[this#794, AVLTreeNode.keys] := exhaleMask#_2767[this#794, AVLTreeNode.keys][perm$R := exhaleMask#_2767[this#794, AVLTreeNode.keys][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_2767);
    assume wf(Heap, exhaleMask#_2767, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 852.12 might not hold. The permission at 852.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  785.4: The precondition at 852.12 might not hold. Insufficient fraction at 852.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_2767[this#794, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_2767[this#794, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2767[this#794, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2767[this#794, AVLTreeNode.balanceFactor] := exhaleMask#_2767[this#794, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2767[this#794, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
    assume IsGoodMask(exhaleMask#_2767);
    assume wf(Heap, exhaleMask#_2767, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#794, AVLTreeNode.left] == null)) {
      assert {:msg "  785.4: The precondition at 854.12 might not hold. The permission at 854.25 might not be positive."} Fractions(100) > 0;
      assert {:msg "  785.4: The precondition at 854.12 might not hold. Insufficient fraction at 854.25 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if ((false || ((predVer#_2574 == Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2573 == Heap[this#794, AVLTreeNode.left]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[this#794, AVLTreeNode.left]) && true && predFlag#_2556)) {
        if ((predVer#_2555 == Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[this#794, AVLTreeNode.left]) && true && predFlag#_2556) {
        } else {
        }
        // begin exhale (update SecMask)
        if (!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
          assume (forall lk#79#798: int :: (0 <= lk#79#798) && (lk#79#798 < Seq#Length(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#798) < Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.key]));
        }
        if (!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
          assume Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
          assume (forall rk#80#799: int :: (0 <= rk#80#799) && (rk#80#799 < Seq#Length(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#799)));
        }
        if (!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
          assume Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
        assume Seq#Equal(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
        //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
        assume Seq#Contains(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.key]);
        //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
        assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.key])));
        //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
        assume Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
        assume Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
        //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
        assume Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
        //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
        assume Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
        //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
        assume Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height] > 0;
        SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
        if (SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
          SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
        if (SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
          SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
        if (SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
          SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
          }
          assume Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] != Heap[this#794, AVLTreeNode.left];
          if ((false || ((predVer#_2574 == Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2573 == Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left]) && true && predFlag#_2556)) {
            if ((predVer#_2555 == Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left]) && true && predFlag#_2556) {
            } else {
            }
            // begin exhale (update SecMask)
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
              assume (forall lk#79#802: int :: (0 <= lk#79#802) && (lk#79#802 < Seq#Length(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#802) < Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key]));
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
              assume (forall rk#80#803: int :: (0 <= rk#80#803) && (rk#80#803 < Seq#Length(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#803)));
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
            }
            //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
            assume Seq#Equal(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
            //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
            assume Seq#Contains(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key]);
            //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
            assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key])));
            //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
            //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
            //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
            //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
            //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
              SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
              SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
              SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            assume wf(Heap, SecMask, SecMask);
            // end exhale
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
          }
          assume Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] != Heap[this#794, AVLTreeNode.left];
          if ((false || ((predVer#_2574 == Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2573 == Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right]) && true && predFlag#_2556)) {
            if ((predVer#_2555 == Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right]) && true && predFlag#_2556) {
            } else {
            }
            // begin exhale (update SecMask)
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
              assume (forall lk#79#806: int :: (0 <= lk#79#806) && (lk#79#806 < Seq#Length(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#806) < Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key]));
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
              assume (forall rk#80#807: int :: (0 <= rk#80#807) && (rk#80#807 < Seq#Length(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#807)));
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
              assume Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
            }
            //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
            assume Seq#Equal(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
            //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
            assume Seq#Contains(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key]);
            //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
            assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key])));
            //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
            //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
            //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
            //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
            //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
            assume Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
              SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
              SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
              SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            if (!(Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right] == null)) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
              if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
                SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
              }
              assume wf(Heap, SecMask, SecMask);
              assume wf(Heap, Mask, SecMask);
            }
            assume wf(Heap, SecMask, SecMask);
            // end exhale
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume wf(Heap, SecMask, SecMask);
        // end exhale
      }
      if (!CanRead(exhaleMask#_2767, SecMask, Heap[this#794, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#794, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2766[Heap[this#794, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume IsGoodMask(exhaleMask#_2767);
      assume wf(Heap, exhaleMask#_2767, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#794, AVLTreeNode.left] == null)) {
      assert {:msg "  785.4: The precondition at 855.12 might not hold. The permission at 855.25 might not be positive."} Fractions(50) > 0;
      assert {:msg "  785.4: The precondition at 855.12 might not hold. Insufficient fraction at 855.25 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_2767);
      assume wf(Heap, exhaleMask#_2767, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#794, AVLTreeNode.left] == null)) {
      assert {:msg "  785.4: The precondition at 856.12 might not hold. The permission at 856.25 might not be positive."} Fractions(50) > 0;
      assert {:msg "  785.4: The precondition at 856.12 might not hold. Insufficient fraction at 856.25 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_2767);
      assume wf(Heap, exhaleMask#_2767, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#794, AVLTreeNode.left] == null)) {
      assert {:msg "  785.4: The precondition at 857.12 might not hold. The permission at 857.25 might not be positive."} Fractions(50) > 0;
      assert {:msg "  785.4: The precondition at 857.12 might not hold. Insufficient fraction at 857.25 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2767[Heap[this#794, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      assume IsGoodMask(exhaleMask#_2767);
      assume wf(Heap, exhaleMask#_2767, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assert {:msg "  785.4: The precondition at 861.12 might not hold. The permission at 861.12 might not be positive."} Fractions(100) > 0;
    assert {:msg "  785.4: The precondition at 861.12 might not hold. Insufficient fraction at 861.12 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if ((false || ((predVer#_2574 == Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2573 == Heap[this#794, AVLTreeNode.right]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[this#794, AVLTreeNode.right]) && true && predFlag#_2556)) {
      if ((predVer#_2555 == Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[this#794, AVLTreeNode.right]) && true && predFlag#_2556) {
      } else {
      }
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#811: int :: (0 <= lk#79#811) && (lk#79#811 < Seq#Length(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#811) < Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#812: int :: (0 <= rk#80#812) && (rk#80#812 < Seq#Length(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#812)));
      }
      if (!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height] > 0;
      SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] != Heap[this#794, AVLTreeNode.right];
        if ((false || ((predVer#_2574 == Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2573 == Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left]) && true && predFlag#_2556)) {
          if ((predVer#_2555 == Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left]) && true && predFlag#_2556) {
          } else {
          }
          // begin exhale (update SecMask)
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
            assume (forall lk#79#815: int :: (0 <= lk#79#815) && (lk#79#815 < Seq#Length(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#815) < Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key]));
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
            assume (forall rk#80#816: int :: (0 <= rk#80#816) && (rk#80#816 < Seq#Length(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#816)));
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
          }
          //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
          assume Seq#Equal(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
          //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
          assume Seq#Contains(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key]);
          //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
          assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key])));
          //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
          //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
          //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
          //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
          //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          assume wf(Heap, SecMask, SecMask);
          // end exhale
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] != Heap[this#794, AVLTreeNode.right];
        if ((false || ((predVer#_2574 == Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2573 == Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right]) && true && predFlag#_2556)) {
          if ((predVer#_2555 == Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right]) && true && predFlag#_2556) {
          } else {
          }
          // begin exhale (update SecMask)
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
            assume (forall lk#79#819: int :: (0 <= lk#79#819) && (lk#79#819 < Seq#Length(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#819) < Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key]));
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
            assume (forall rk#80#820: int :: (0 <= rk#80#820) && (rk#80#820 < Seq#Length(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#820)));
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
            assume Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
          }
          //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
          assume Seq#Equal(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
          //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
          assume Seq#Contains(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key]);
          //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
          assume (forall kk#81: int :: Seq#Contains(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key])));
          //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
          //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
          //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
          //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
          //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
          assume Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right] == null)) {
            SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
            if (SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
              SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
            }
            assume wf(Heap, SecMask, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          assume wf(Heap, SecMask, SecMask);
          // end exhale
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_2767, SecMask, Heap[this#794, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#794, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2766[Heap[this#794, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_2767);
    assume wf(Heap, exhaleMask#_2767, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 862.12 might not hold. The permission at 862.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  785.4: The precondition at 862.12 might not hold. Insufficient fraction at 862.12 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2767);
    assume wf(Heap, exhaleMask#_2767, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 863.12 might not hold. The permission at 863.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  785.4: The precondition at 863.12 might not hold. Insufficient fraction at 863.12 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2767);
    assume wf(Heap, exhaleMask#_2767, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 864.12 might not hold. The permission at 864.12 might not be positive."} Fractions(50) > 0;
    assert {:msg "  785.4: The precondition at 864.12 might not hold. Insufficient fraction at 864.12 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2767[Heap[this#794, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_2767);
    assume wf(Heap, exhaleMask#_2767, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_2767;
    assume IsGoodExhaleState(exhaleHeap#_2766, Heap, Mask, SecMask);
    Heap := exhaleHeap#_2766;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#795;
    // inhale (postcondition)
    assume !(r#795 == null);
    assume r#795 != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[r#795, AVLTreeNode.valid] := Mask[r#795, AVLTreeNode.valid][perm$R := Mask[r#795, AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#795, AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#795 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#795, AVLTreeNode.height] := Mask[r#795, AVLTreeNode.height][perm$R := Mask[r#795, AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#795, AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#795 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#795, AVLTreeNode.keys] := Mask[r#795, AVLTreeNode.keys][perm$R := Mask[r#795, AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#795, AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#795 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[r#795, AVLTreeNode.balanceFactor] := Mask[r#795, AVLTreeNode.balanceFactor][perm$R := Mask[r#795, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[r#795, AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume (Heap[r#795, AVLTreeNode.height] == callHeap#_2761[callHeap#_2761[this#794, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#795, AVLTreeNode.height] == (callHeap#_2761[callHeap#_2761[this#794, AVLTreeNode.right], AVLTreeNode.height] + 1));
    assume Seq#Equal(Heap[r#795, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2761[this#794, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2761[callHeap#_2761[this#794, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2761[this#794, AVLTreeNode.key])), callHeap#_2761[callHeap#_2761[this#794, AVLTreeNode.right], AVLTreeNode.keys]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    r#68 := r#795;
  }
  // begin exhale (postcondition)
  exhaleMask#_2881 := Mask;
  havoc exhaleHeap#_2880;
  assert {:msg "  745.2: The postcondition at 770.11 might not hold. The expression at 770.11 might not evaluate to true."} !(r#68 == null);
  assert {:msg "  745.2: The postcondition at 776.11 might not hold. The expression at 776.11 might not evaluate to true."} (Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#68, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height] + 1));
  assert {:msg "  745.2: The postcondition at 777.11 might not hold. The expression at 777.11 might not evaluate to true."} Seq#Equal(Heap[r#68, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assert {:msg "  745.2: The postcondition at 771.11 might not hold. The permission at 771.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  745.2: The postcondition at 771.11 might not hold. Insufficient fraction at 771.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_2881[r#68, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_2881[r#68, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_2881[r#68, AVLTreeNode.valid][perm$N]));
  exhaleMask#_2881[r#68, AVLTreeNode.valid] := exhaleMask#_2881[r#68, AVLTreeNode.valid][perm$R := exhaleMask#_2881[r#68, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if ((false || ((predVer#_2574 == Heap[r#68, AVLTreeNode.valid]) && (predRec#_2573 == r#68) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[r#68, AVLTreeNode.valid]) && (predRec#_2554 == r#68) && true && predFlag#_2556)) {
    if ((predVer#_2555 == Heap[r#68, AVLTreeNode.valid]) && (predRec#_2554 == r#68) && true && predFlag#_2556) {
    } else {
    }
    // begin exhale (update SecMask)
    if (!(Heap[r#68, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#824: int :: (0 <= lk#79#824) && (lk#79#824 < Seq#Length(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys], lk#79#824) < Heap[r#68, AVLTreeNode.key]));
    }
    if (!(Heap[r#68, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[r#68, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#825: int :: (0 <= rk#80#825) && (rk#80#825 < Seq#Length(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#68, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys], rk#80#825)));
    }
    if (!(Heap[r#68, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[r#68, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#68, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#68, AVLTreeNode.key])), ite(Heap[r#68, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[r#68, AVLTreeNode.keys], Heap[r#68, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[r#68, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#68, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#68, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#68, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[r#68, AVLTreeNode.height] == ite(ite(Heap[r#68, AVLTreeNode.left] == null, 0, Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#68, AVLTreeNode.right] == null, 0, Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#68, AVLTreeNode.left] == null, 0, Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#68, AVLTreeNode.right] == null, 0, Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[r#68, AVLTreeNode.balanceFactor] == (ite(Heap[r#68, AVLTreeNode.left] == null, 0, Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#68, AVLTreeNode.right] == null, 0, Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[r#68, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[r#68, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[r#68, AVLTreeNode.height] > 0;
    SecMask[r#68, AVLTreeNode.key] := SecMask[r#68, AVLTreeNode.key][perm$R := SecMask[r#68, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[r#68, AVLTreeNode.key][perm$R] < 0) {
      SecMask[r#68, AVLTreeNode.key] := SecMask[r#68, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#68, AVLTreeNode.height] := SecMask[r#68, AVLTreeNode.height][perm$R := SecMask[r#68, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[r#68, AVLTreeNode.height][perm$R] < 0) {
      SecMask[r#68, AVLTreeNode.height] := SecMask[r#68, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#68, AVLTreeNode.left] := SecMask[r#68, AVLTreeNode.left][perm$R := SecMask[r#68, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[r#68, AVLTreeNode.left][perm$R] < 0) {
      SecMask[r#68, AVLTreeNode.left] := SecMask[r#68, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#68, AVLTreeNode.right] := SecMask[r#68, AVLTreeNode.right][perm$R := SecMask[r#68, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[r#68, AVLTreeNode.right][perm$R] < 0) {
      SecMask[r#68, AVLTreeNode.right] := SecMask[r#68, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#68, AVLTreeNode.keys] := SecMask[r#68, AVLTreeNode.keys][perm$R := SecMask[r#68, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[r#68, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[r#68, AVLTreeNode.keys] := SecMask[r#68, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#68, AVLTreeNode.balanceFactor] := SecMask[r#68, AVLTreeNode.balanceFactor][perm$R := SecMask[r#68, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[r#68, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[r#68, AVLTreeNode.balanceFactor] := SecMask[r#68, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[r#68, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume Heap[r#68, AVLTreeNode.left] != r#68;
      if ((false || ((predVer#_2574 == Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2573 == Heap[r#68, AVLTreeNode.left]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[r#68, AVLTreeNode.left]) && true && predFlag#_2556)) {
        if ((predVer#_2555 == Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2554 == Heap[r#68, AVLTreeNode.left]) && true && predFlag#_2556) {
        } else {
        }
        // begin exhale (update SecMask)
        if (!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
          assume (forall lk#79#828: int :: (0 <= lk#79#828) && (lk#79#828 < Seq#Length(Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#828) < Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.key]));
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
          assume Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
          assume (forall rk#80#829: int :: (0 <= rk#80#829) && (rk#80#829 < Seq#Length(Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#829)));
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
          assume Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
        assume Seq#Equal(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
        //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
        assume Seq#Contains(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.key]);
        //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
        assume (forall kk#81: int :: Seq#Contains(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.key])));
        //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
        assume Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
        assume Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
        //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
        assume Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
        //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
        assume Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
        //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
        assume Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height] > 0;
        SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
        if (SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
          SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
        if (SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
          SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
        if (SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
          SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#68, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume wf(Heap, SecMask, SecMask);
        // end exhale
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#68, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#68, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#68, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#68, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#68, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume Heap[r#68, AVLTreeNode.right] != r#68;
      if ((false || ((predVer#_2574 == Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2573 == Heap[r#68, AVLTreeNode.right]) && true && predFlag#_2575)) || ((predVer#_2555 == Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[r#68, AVLTreeNode.right]) && true && predFlag#_2556)) {
        if ((predVer#_2555 == Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2554 == Heap[r#68, AVLTreeNode.right]) && true && predFlag#_2556) {
        } else {
        }
        // begin exhale (update SecMask)
        if (!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
          assume (forall lk#79#832: int :: (0 <= lk#79#832) && (lk#79#832 < Seq#Length(Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#832) < Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.key]));
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
          assume Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
          assume (forall rk#80#833: int :: (0 <= rk#80#833) && (rk#80#833 < Seq#Length(Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#833)));
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
          assume Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
        assume Seq#Equal(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
        //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
        assume Seq#Contains(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.key]);
        //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
        assume (forall kk#81: int :: Seq#Contains(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.key])));
        //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
        assume Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
        assume Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
        //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
        assume Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
        //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
        assume Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
        //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
        assume Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height] > 0;
        SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
        if (SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
          SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
        if (SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
          SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
        if (SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
          SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
          if (SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
            SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[r#68, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
          }
          assume wf(Heap, SecMask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume wf(Heap, SecMask, SecMask);
        // end exhale
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#68, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#68, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#68, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#68, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(exhaleMask#_2881, SecMask, r#68, AVLTreeNode.valid)) {
    assume Heap[r#68, AVLTreeNode.valid] < exhaleHeap#_2880[r#68, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_2881);
  assume wf(Heap, exhaleMask#_2881, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  745.2: The postcondition at 772.11 might not hold. The permission at 772.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  745.2: The postcondition at 772.11 might not hold. Insufficient fraction at 772.11 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_2881[r#68, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_2881[r#68, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_2881[r#68, AVLTreeNode.height][perm$N]));
  exhaleMask#_2881[r#68, AVLTreeNode.height] := exhaleMask#_2881[r#68, AVLTreeNode.height][perm$R := exhaleMask#_2881[r#68, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_2881);
  assume wf(Heap, exhaleMask#_2881, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  745.2: The postcondition at 773.11 might not hold. The permission at 773.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  745.2: The postcondition at 773.11 might not hold. Insufficient fraction at 773.11 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_2881[r#68, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_2881[r#68, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_2881[r#68, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2881[r#68, AVLTreeNode.keys] := exhaleMask#_2881[r#68, AVLTreeNode.keys][perm$R := exhaleMask#_2881[r#68, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_2881);
  assume wf(Heap, exhaleMask#_2881, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  745.2: The postcondition at 774.11 might not hold. The permission at 774.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  745.2: The postcondition at 774.11 might not hold. Insufficient fraction at 774.11 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_2881[r#68, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_2881[r#68, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_2881[r#68, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2881[r#68, AVLTreeNode.balanceFactor] := exhaleMask#_2881[r#68, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2881[r#68, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_2881);
  assume wf(Heap, exhaleMask#_2881, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_2881;
  assume IsGoodExhaleState(exhaleHeap#_2880, Heap, Mask, SecMask);
  Heap := exhaleHeap#_2880;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  745.2: Method might lock/unlock more than allowed."} (forall lk#_2934: ref :: {Heap[lk#_2934, held]} {Heap[lk#_2934, rdheld]} (((0 < Heap[lk#_2934, held]) == (0 < old(Heap)[lk#_2934, held])) && (Heap[lk#_2934, rdheld] == old(Heap)[lk#_2934, rdheld])) || false);
  assert {:msg "  745.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceLR$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#71: ref where (r#71 == null) || (dtype(r#71) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2935: int;
  var k#106#837: int where true;
  var k#107#839: int where true;
  var predRec#_2936: ref;
  var predFlag#_2938: bool;
  var predVer#_2937: int;
  var unfoldingK#_2944: int;
  var predFlag#_2943: bool;
  var unfoldingHeap#_2939: HeapType;
  var unfoldingMask#_2940: MaskType;
  var unfoldingSecMask#_2941: MaskType;
  var unfoldingCredits#_2942: CreditsType;
  var oldVers#_2964: int;
  var newVers#_2965: int;
  assume (0 < methodK#_2935) && ((1000 * methodK#_2935) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  799.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  799.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  799.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  799.25: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  799.25: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  799.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  799.25: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  800.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  800.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  800.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  800.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  801.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  801.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  801.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  801.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  802.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  802.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  802.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  802.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  803.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  803.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  803.12: Receiver might be null."} true && (0 <= k#106#837) ==> (this != null);
    assert {:msg "  803.12: Location might not be readable."} true && (0 <= k#106#837) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  803.12: Receiver might be null."} true && (0 <= k#106#837) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  803.12: Location might not be readable."} true && (0 <= k#106#837) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  803.12: Receiver might be null."} true && (0 <= k#106#837) && (k#106#837 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  803.12: Location might not be readable."} true && (0 <= k#106#837) && (k#106#837 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  803.12: Receiver might be null."} true && (0 <= k#106#837) && (k#106#837 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  803.12: Location might not be readable."} true && (0 <= k#106#837) && (k#106#837 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  803.50: Sequence index might be negative."} true && (0 <= k#106#837) && (k#106#837 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#106#837);
    assert {:msg "  803.50: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#106#837) && (k#106#837 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#106#837 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  803.54: Receiver might be null."} true && (0 <= k#106#837) && (k#106#837 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  803.54: Location might not be readable."} true && (0 <= k#106#837) && (k#106#837 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    assume (forall k#106#836: int :: (0 <= k#106#836) && (k#106#836 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#106#836) < Heap[this, AVLTreeNode.key]));
  }
  assert {:msg "  805.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  805.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume !(Heap[this, AVLTreeNode.right] == null);
  assert {:msg "  806.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  806.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  806.12: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
  assert {:msg "  806.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  806.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  807.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  807.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  808.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  808.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  809.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  809.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  810.12: Receiver might be null."} true && (0 <= k#107#839) ==> (this != null);
  assert {:msg "  810.12: Location might not be readable."} true && (0 <= k#107#839) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  810.12: Receiver might be null."} true && (0 <= k#107#839) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  810.12: Location might not be readable."} true && (0 <= k#107#839) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  810.38: Receiver might be null."} true && (0 <= k#107#839) && (k#107#839 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  810.38: Location might not be readable."} true && (0 <= k#107#839) && (k#107#839 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  assert {:msg "  810.12: Receiver might be null."} true && (0 <= k#107#839) && (k#107#839 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  810.12: Location might not be readable."} true && (0 <= k#107#839) && (k#107#839 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  810.12: Receiver might be null."} true && (0 <= k#107#839) && (k#107#839 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  810.12: Location might not be readable."} true && (0 <= k#107#839) && (k#107#839 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  810.44: Sequence index might be negative."} true && (0 <= k#107#839) && (k#107#839 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#107#839);
  assert {:msg "  810.44: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#107#839) && (k#107#839 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#107#839 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume (forall k#107#838: int :: (0 <= k#107#838) && (k#107#838 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#107#838)));
  predRec#_2936 := Heap[this, AVLTreeNode.right];
  predFlag#_2938 := true;
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.right]);
  predVer#_2937 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  // unfolding
  assume (0 < unfoldingK#_2944) && ((1000 * unfoldingK#_2944) < Fractions(1));
  predFlag#_2943 := true;
  assert {:msg "  812.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  812.22: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  812.22: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  unfoldingHeap#_2939 := Heap;
  unfoldingMask#_2940 := Mask;
  unfoldingSecMask#_2941 := SecMask;
  unfoldingCredits#_2942 := Credits;
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  // begin exhale (unfolding)
  assert {:msg "  812.12: Unfolding might fail. The permission at 812.22 might not be positive."} Fractions(100) > 0;
  assert {:msg "  812.12: Unfolding might fail. Insufficient fraction at 812.22 for AVLTreeNode.valid."} (Fractions(100) <= unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
  unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#840: int :: (0 <= lk#79#840) && (lk#79#840 < Seq#Length(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#840) < unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key]));
    }
    if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#841: int :: (0 <= rk#80#841) && (rk#80#841 < Seq#Length(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#841)));
    }
    if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
    if (unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
    }
    assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    if (unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
    }
    assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
    if (unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
    }
    assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
    if (unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
    }
    assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2941[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
      assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    }
    if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
      assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    }
    if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
      assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    }
    if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
      assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    }
    if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
      assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    }
    if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
      assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    }
    if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
      assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    }
    if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingSecMask#_2941[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
      assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    }
    assume wf(unfoldingHeap#_2939, unfoldingSecMask#_2941, unfoldingSecMask#_2941);
    // end exhale
  }
  if (!CanRead(unfoldingMask#_2940, unfoldingSecMask#_2941, unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.valid)) {
    oldVers#_2964 := unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.valid];
    havoc newVers#_2965;
    unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_2965;
    assume oldVers#_2964 < unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.valid];
  }
  assume IsGoodMask(unfoldingMask#_2940);
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume IsGoodMask(unfoldingMask#_2940);
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  // end exhale
  // inhale (unfolding)
  assume unfoldingHeap#_2939[this, AVLTreeNode.right] != null;
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume true;
  assume Fractions(100) > 0;
  unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(unfoldingMask#_2940);
  assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key]));
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume unfoldingHeap#_2939[this, AVLTreeNode.right] != null;
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume true;
  assume Fractions(50) > 0;
  unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(unfoldingMask#_2940);
  assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume unfoldingHeap#_2939[this, AVLTreeNode.right] != null;
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume (unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(unfoldingMask#_2940);
  assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left]));
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume unfoldingHeap#_2939[this, AVLTreeNode.right] != null;
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume (unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(unfoldingMask#_2940);
  assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right]));
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume unfoldingHeap#_2939[this, AVLTreeNode.right] != null;
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume true;
  assume Fractions(50) > 0;
  unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(unfoldingMask#_2940);
  assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume unfoldingHeap#_2939[this, AVLTreeNode.right] != null;
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume true;
  assume Fractions(50) > 0;
  unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(unfoldingMask#_2940);
  assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume Fractions(100) > 0;
    unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_2940);
    assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  }
  if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2940);
    assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  }
  if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2940);
    assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  }
  if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2940);
    assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  }
  if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume (forall lk#79#844: int :: (0 <= lk#79#844) && (lk#79#844 < Seq#Length(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#844) < unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key]));
  }
  if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume Fractions(100) > 0;
    unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(unfoldingMask#_2940);
    assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  }
  if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2940);
    assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  }
  if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2940);
    assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  }
  if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume true;
    assume Fractions(50) > 0;
    unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2940[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(unfoldingMask#_2940);
    assume IsGoodState(heapFragment(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
    assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  }
  if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume (forall rk#80#845: int :: (0 <= rk#80#845) && (rk#80#845 < Seq#Length(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#845)));
  }
  if (!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.key])));
  assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2939[unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
  assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
  assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume unfoldingHeap#_2939[unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  assume IsGoodMask(unfoldingMask#_2940);
  assume wf(unfoldingHeap#_2939, unfoldingMask#_2940, unfoldingSecMask#_2941);
  // end inhale
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#846: int :: (0 <= lk#79#846) && (lk#79#846 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#846) < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]));
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#847: int :: (0 <= rk#80#847) && (rk#80#847 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#847)));
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume (forall lk#79#850: int :: (0 <= lk#79#850) && (lk#79#850 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#850) < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]));
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume (forall rk#80#851: int :: (0 <= rk#80#851) && (rk#80#851 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#851)));
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])));
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  assert {:msg "  812.37: Receiver might be null."} true ==> (this != null);
  assert {:msg "  812.37: Location might not be readable."} true ==> CanRead(unfoldingMask#_2940, unfoldingSecMask#_2941, this, AVLTreeNode.right);
  assert {:msg "  812.37: Receiver might be null."} true ==> (unfoldingHeap#_2939[this, AVLTreeNode.right] != null);
  assert {:msg "  812.37: Location might not be readable."} true ==> CanRead(unfoldingMask#_2940, unfoldingSecMask#_2941, unfoldingHeap#_2939[this, AVLTreeNode.right], AVLTreeNode.left);
  assume !(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null);
  assert {:msg "  814.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  814.13: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  814.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  814.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  814.26: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  814.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  814.39: Receiver might be null."} true ==> (this != null);
  assert {:msg "  814.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  814.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  814.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assert {:msg "  815.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  815.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  815.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  815.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#71 == null);
  assert {:msg "  818.11: Receiver might be null."} r#71 != null;
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[r#71, AVLTreeNode.valid] := Mask[r#71, AVLTreeNode.valid][perm$R := Mask[r#71, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#71, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#71, AVLTreeNode.height] := Mask[r#71, AVLTreeNode.height][perm$R := Mask[r#71, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#71, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#71, AVLTreeNode.keys] := Mask[r#71, AVLTreeNode.keys][perm$R := Mask[r#71, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#71, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#71, AVLTreeNode.balanceFactor] := Mask[r#71, AVLTreeNode.balanceFactor][perm$R := Mask[r#71, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#71, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  823.11: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  823.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#71, AVLTreeNode.height);
  assert {:msg "  823.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  823.27: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  assert {:msg "  823.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  823.27: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assume Heap[r#71, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height];
  assert {:msg "  824.11: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  824.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#71, AVLTreeNode.keys);
  assert {:msg "  824.26: Receiver might be null."} true ==> (this != null);
  assert {:msg "  824.26: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  824.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  824.51: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
    assert {:msg "  824.51: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  824.51: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  824.71: Receiver might be null."} true ==> (this != null);
  assert {:msg "  824.71: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.key);
  assert {:msg "  824.84: Receiver might be null."} true ==> (this != null);
  assert {:msg "  824.84: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  assert {:msg "  824.84: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  824.84: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  assume Seq#Equal(Heap[r#71, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.rebalanceLR(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#71: ref where (r#71 == null) || (dtype(r#71) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2935: int;
  var predRec#_2982: ref;
  var predFlag#_2984: bool;
  var predVer#_2983: int;
  var assertHeap#_3001: HeapType;
  var assertMask#_3002: MaskType;
  var assertSecMask#_3003: MaskType;
  var assertCredits#_3004: CreditsType;
  var exhaleMask#_3006: MaskType;
  var exhaleHeap#_3005: HeapType;
  var k#108#861: int where true;
  var unfoldK#_3007: int;
  var oldVers#_3027: int;
  var newVers#_3028: int;
  var assertHeap#_3029: HeapType;
  var assertMask#_3030: MaskType;
  var assertSecMask#_3031: MaskType;
  var assertCredits#_3032: CreditsType;
  var exhaleMask#_3034: MaskType;
  var exhaleHeap#_3033: HeapType;
  var k#109#870: int where true;
  var unfoldK#_3035: int;
  var oldVers#_3055: int;
  var newVers#_3056: int;
  var assertHeap#_3057: HeapType;
  var assertMask#_3058: MaskType;
  var assertSecMask#_3059: MaskType;
  var assertCredits#_3060: CreditsType;
  var exhaleMask#_3062: MaskType;
  var exhaleHeap#_3061: HeapType;
  var k#110#879: int where true;
  var methodCallK#_3067: int;
  var this#881: ref where (this#881 == null) || (dtype(this#881) == AVLTreeNode#t);
  var callHeap#_3063: HeapType;
  var callMask#_3064: MaskType;
  var callSecMask#_3065: MaskType;
  var callCredits#_3066: CreditsType;
  var exhaleMask#_3069: MaskType;
  var exhaleHeap#_3068: HeapType;
  var isHeld#_3116: int;
  var isRdHeld#_3117: bool;
  var assertHeap#_3118: HeapType;
  var assertMask#_3119: MaskType;
  var assertSecMask#_3120: MaskType;
  var assertCredits#_3121: CreditsType;
  var exhaleMask#_3123: MaskType;
  var exhaleHeap#_3122: HeapType;
  var k#111#895: int where true;
  var methodCallK#_3128: int;
  var this#897: ref where (this#897 == null) || (dtype(this#897) == AVLTreeNode#t);
  var callHeap#_3124: HeapType;
  var callMask#_3125: MaskType;
  var callSecMask#_3126: MaskType;
  var callCredits#_3127: CreditsType;
  var exhaleMask#_3130: MaskType;
  var exhaleHeap#_3129: HeapType;
  var isHeld#_3177: int;
  var isRdHeld#_3178: bool;
  var methodCallK#_3183: int;
  var this#910: ref where (this#910 == null) || (dtype(this#910) == AVLTreeNode#t);
  var callHeap#_3179: HeapType;
  var callMask#_3180: MaskType;
  var callSecMask#_3181: MaskType;
  var callCredits#_3182: CreditsType;
  var exhaleMask#_3185: MaskType;
  var exhaleHeap#_3184: HeapType;
  var isHeld#_3232: int;
  var isRdHeld#_3233: bool;
  var exhaleMask#_3235: MaskType;
  var exhaleHeap#_3234: HeapType;
  assume (0 < methodK#_2935) && ((1000 * methodK#_2935) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall k#106#852: int :: (0 <= k#106#852) && (k#106#852 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#106#852) < Heap[this, AVLTreeNode.key]));
  }
  assume !(Heap[this, AVLTreeNode.right] == null);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume (forall k#107#853: int :: (0 <= k#107#853) && (k#107#853 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#107#853)));
  predRec#_2982 := Heap[this, AVLTreeNode.right];
  predFlag#_2984 := true;
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.right]);
  predVer#_2983 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#854: int :: (0 <= lk#79#854) && (lk#79#854 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#854) < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]));
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#855: int :: (0 <= rk#80#855) && (rk#80#855 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#855)));
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  assume predRec#_2982 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  SecMask[predRec#_2982, AVLTreeNode.key] := SecMask[predRec#_2982, AVLTreeNode.key][perm$R := SecMask[predRec#_2982, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2982, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2982 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_2982, AVLTreeNode.height] := SecMask[predRec#_2982, AVLTreeNode.height][perm$R := SecMask[predRec#_2982, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2982, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2982 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2982, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_2982, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[predRec#_2982, AVLTreeNode.left] := SecMask[predRec#_2982, AVLTreeNode.left][perm$R := SecMask[predRec#_2982, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2982, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2982 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2982, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_2982, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  SecMask[predRec#_2982, AVLTreeNode.right] := SecMask[predRec#_2982, AVLTreeNode.right][perm$R := SecMask[predRec#_2982, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2982, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2982 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_2982, AVLTreeNode.keys] := SecMask[predRec#_2982, AVLTreeNode.keys][perm$R := SecMask[predRec#_2982, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2982, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2982 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  SecMask[predRec#_2982, AVLTreeNode.balanceFactor] := SecMask[predRec#_2982, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_2982, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[predRec#_2982, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_2982, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2982, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2982, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2982, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2982, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2982, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2982, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2982, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2982, AVLTreeNode.left] == null)) {
    assume (forall lk#79#858: int :: (0 <= lk#79#858) && (lk#79#858 < Seq#Length(Heap[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.keys], lk#79#858) < Heap[predRec#_2982, AVLTreeNode.key]));
  }
  if (!(Heap[predRec#_2982, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_2982, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2982, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    SecMask[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2982, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2982, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2982, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2982, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2982, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2982, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    SecMask[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2982, AVLTreeNode.right] == null)) {
    assume (forall rk#80#859: int :: (0 <= rk#80#859) && (rk#80#859 < Seq#Length(Heap[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_2982, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.keys], rk#80#859)));
  }
  if (!(Heap[predRec#_2982, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_2982, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_2982, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_2982, AVLTreeNode.key])), ite(Heap[predRec#_2982, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_2982, AVLTreeNode.keys], Heap[predRec#_2982, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[predRec#_2982, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_2982, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_2982, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_2982, AVLTreeNode.key])));
  assume Heap[predRec#_2982, AVLTreeNode.height] == ite(ite(Heap[predRec#_2982, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_2982, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_2982, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_2982, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_2982, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_2982, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2982, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_2982, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2982, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_2982, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_2982, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_2982, AVLTreeNode.height] > 0;
  assume !(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // assert
  assertHeap#_3001 := Heap;
  assertMask#_3002 := Mask;
  assertSecMask#_3003 := SecMask;
  assertCredits#_3004 := Credits;
  assume wf(assertHeap#_3001, assertMask#_3002, assertSecMask#_3003);
  // begin exhale (assert)
  exhaleMask#_3006 := assertMask#_3002;
  havoc exhaleHeap#_3005;
  assert {:msg "  826.10: Receiver might be null."} true && (0 <= k#108#861) ==> (this != null);
  assert {:msg "  826.10: Location might not be readable."} true && (0 <= k#108#861) ==> CanRead(assertMask#_3002, assertSecMask#_3003, this, AVLTreeNode.right);
  assert {:msg "  826.10: Receiver might be null."} true && (0 <= k#108#861) ==> (assertHeap#_3001[this, AVLTreeNode.right] != null);
  assert {:msg "  826.10: Location might not be readable."} true && (0 <= k#108#861) ==> CanRead(assertMask#_3002, assertSecMask#_3003, assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  826.36: Receiver might be null."} true && (0 <= k#108#861) && (k#108#861 < Seq#Length(assertHeap#_3001[assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  826.36: Location might not be readable."} true && (0 <= k#108#861) && (k#108#861 < Seq#Length(assertHeap#_3001[assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_3002, assertSecMask#_3003, this, AVLTreeNode.key);
  assert {:msg "  826.10: Receiver might be null."} true && (0 <= k#108#861) && (k#108#861 < Seq#Length(assertHeap#_3001[assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  826.10: Location might not be readable."} true && (0 <= k#108#861) && (k#108#861 < Seq#Length(assertHeap#_3001[assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_3002, assertSecMask#_3003, this, AVLTreeNode.right);
  assert {:msg "  826.10: Receiver might be null."} true && (0 <= k#108#861) && (k#108#861 < Seq#Length(assertHeap#_3001[assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_3001[this, AVLTreeNode.right] != null);
  assert {:msg "  826.10: Location might not be readable."} true && (0 <= k#108#861) && (k#108#861 < Seq#Length(assertHeap#_3001[assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_3002, assertSecMask#_3003, assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  826.42: Sequence index might be negative."} true && (0 <= k#108#861) && (k#108#861 < Seq#Length(assertHeap#_3001[assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#108#861);
  assert {:msg "  826.42: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#108#861) && (k#108#861 < Seq#Length(assertHeap#_3001[assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#108#861 < Seq#Length(assertHeap#_3001[assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assert {:msg "  826.3: Assertion might not hold. The expression at 826.10 might not evaluate to true."} (forall k#108#860: int :: (0 <= k#108#860) && (k#108#860 < Seq#Length(assertHeap#_3001[assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_3001[this, AVLTreeNode.key] < Seq#Index(assertHeap#_3001[assertHeap#_3001[this, AVLTreeNode.right], AVLTreeNode.keys], k#108#860)));
  assertMask#_3002 := exhaleMask#_3006;
  assume IsGoodExhaleState(exhaleHeap#_3005, assertHeap#_3001, assertMask#_3002, assertSecMask#_3003);
  assertHeap#_3001 := exhaleHeap#_3005;
  assume IsGoodMask(assertMask#_3002);
  assume wf(assertHeap#_3001, assertMask#_3002, assertSecMask#_3003);
  // end exhale
  // unfold
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.right]);
  assume (0 < unfoldK#_3007) && (unfoldK#_3007 < Fractions(1)) && ((1000 * unfoldK#_3007) < methodK#_2935);
  assert {:msg "  827.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  827.10: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  827.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.right] != null;
  // begin exhale (unfold)
  assert {:msg "  827.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  827.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_2983 == Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2982 == Heap[this, AVLTreeNode.right]) && true && predFlag#_2984)) {
    // begin exhale (update SecMask)
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#863: int :: (0 <= lk#79#863) && (lk#79#863 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#863) < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]));
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#864: int :: (0 <= rk#80#864) && (rk#80#864 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#864)));
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.valid)) {
    oldVers#_3027 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    havoc newVers#_3028;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_3028;
    assume oldVers#_3027 < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume (forall lk#79#867: int :: (0 <= lk#79#867) && (lk#79#867 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#867) < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]));
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume (forall rk#80#868: int :: (0 <= rk#80#868) && (rk#80#868 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#868)));
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])));
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // assigment to r
  assert {:msg "  828.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  828.8: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  828.8: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  828.8: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.left);
  r#71 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left];
  // assert
  assertHeap#_3029 := Heap;
  assertMask#_3030 := Mask;
  assertSecMask#_3031 := SecMask;
  assertCredits#_3032 := Credits;
  assume wf(assertHeap#_3029, assertMask#_3030, assertSecMask#_3031);
  // begin exhale (assert)
  exhaleMask#_3034 := assertMask#_3030;
  havoc exhaleHeap#_3033;
  assert {:msg "  829.10: Receiver might be null."} true && (0 <= k#109#870) ==> (r#71 != null);
  assert {:msg "  829.10: Location might not be readable."} true && (0 <= k#109#870) ==> CanRead(assertMask#_3030, assertSecMask#_3031, r#71, AVLTreeNode.keys);
  assert {:msg "  829.32: Receiver might be null."} true && (0 <= k#109#870) && (k#109#870 < Seq#Length(assertHeap#_3029[r#71, AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  829.32: Location might not be readable."} true && (0 <= k#109#870) && (k#109#870 < Seq#Length(assertHeap#_3029[r#71, AVLTreeNode.keys])) ==> CanRead(assertMask#_3030, assertSecMask#_3031, this, AVLTreeNode.key);
  assert {:msg "  829.10: Receiver might be null."} true && (0 <= k#109#870) && (k#109#870 < Seq#Length(assertHeap#_3029[r#71, AVLTreeNode.keys])) ==> (r#71 != null);
  assert {:msg "  829.10: Location might not be readable."} true && (0 <= k#109#870) && (k#109#870 < Seq#Length(assertHeap#_3029[r#71, AVLTreeNode.keys])) ==> CanRead(assertMask#_3030, assertSecMask#_3031, r#71, AVLTreeNode.keys);
  assert {:msg "  829.38: Sequence index might be negative."} true && (0 <= k#109#870) && (k#109#870 < Seq#Length(assertHeap#_3029[r#71, AVLTreeNode.keys])) ==> (0 <= k#109#870);
  assert {:msg "  829.38: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#109#870) && (k#109#870 < Seq#Length(assertHeap#_3029[r#71, AVLTreeNode.keys])) ==> (k#109#870 < Seq#Length(assertHeap#_3029[r#71, AVLTreeNode.keys]));
  assert {:msg "  829.3: Assertion might not hold. The expression at 829.10 might not evaluate to true."} (forall k#109#869: int :: (0 <= k#109#869) && (k#109#869 < Seq#Length(assertHeap#_3029[r#71, AVLTreeNode.keys])) ==> (assertHeap#_3029[this, AVLTreeNode.key] < Seq#Index(assertHeap#_3029[r#71, AVLTreeNode.keys], k#109#869)));
  assertMask#_3030 := exhaleMask#_3034;
  assume IsGoodExhaleState(exhaleHeap#_3033, assertHeap#_3029, assertMask#_3030, assertSecMask#_3031);
  assertHeap#_3029 := exhaleHeap#_3033;
  assume IsGoodMask(assertMask#_3030);
  assume wf(assertHeap#_3029, assertMask#_3030, assertSecMask#_3031);
  // end exhale
  // unfold
  assume #AVLTreeNode.valid#trigger(r#71);
  assume (0 < unfoldK#_3035) && (unfoldK#_3035 < Fractions(1)) && ((1000 * unfoldK#_3035) < methodK#_2935);
  assert {:msg "  830.3: The target of the fold statement might be null."} r#71 != null;
  // begin exhale (unfold)
  assert {:msg "  830.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  830.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[r#71, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[r#71, AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[r#71, AVLTreeNode.valid][perm$N]));
  Mask[r#71, AVLTreeNode.valid] := Mask[r#71, AVLTreeNode.valid][perm$R := Mask[r#71, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_2983 == Heap[r#71, AVLTreeNode.valid]) && (predRec#_2982 == r#71) && true && predFlag#_2984)) {
    // begin exhale (update SecMask)
    if (!(Heap[r#71, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#872: int :: (0 <= lk#79#872) && (lk#79#872 < Seq#Length(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys], lk#79#872) < Heap[r#71, AVLTreeNode.key]));
    }
    if (!(Heap[r#71, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[r#71, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#873: int :: (0 <= rk#80#873) && (rk#80#873 < Seq#Length(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#71, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys], rk#80#873)));
    }
    if (!(Heap[r#71, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[r#71, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#71, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#71, AVLTreeNode.key])), ite(Heap[r#71, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[r#71, AVLTreeNode.keys], Heap[r#71, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[r#71, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#71, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#71, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#71, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[r#71, AVLTreeNode.height] == ite(ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[r#71, AVLTreeNode.balanceFactor] == (ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[r#71, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[r#71, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[r#71, AVLTreeNode.height] > 0;
    SecMask[r#71, AVLTreeNode.key] := SecMask[r#71, AVLTreeNode.key][perm$R := SecMask[r#71, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[r#71, AVLTreeNode.key][perm$R] < 0) {
      SecMask[r#71, AVLTreeNode.key] := SecMask[r#71, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#71, AVLTreeNode.height] := SecMask[r#71, AVLTreeNode.height][perm$R := SecMask[r#71, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[r#71, AVLTreeNode.height][perm$R] < 0) {
      SecMask[r#71, AVLTreeNode.height] := SecMask[r#71, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#71, AVLTreeNode.left] := SecMask[r#71, AVLTreeNode.left][perm$R := SecMask[r#71, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[r#71, AVLTreeNode.left][perm$R] < 0) {
      SecMask[r#71, AVLTreeNode.left] := SecMask[r#71, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#71, AVLTreeNode.right] := SecMask[r#71, AVLTreeNode.right][perm$R := SecMask[r#71, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[r#71, AVLTreeNode.right][perm$R] < 0) {
      SecMask[r#71, AVLTreeNode.right] := SecMask[r#71, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#71, AVLTreeNode.keys] := SecMask[r#71, AVLTreeNode.keys][perm$R := SecMask[r#71, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[r#71, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[r#71, AVLTreeNode.keys] := SecMask[r#71, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#71, AVLTreeNode.balanceFactor] := SecMask[r#71, AVLTreeNode.balanceFactor][perm$R := SecMask[r#71, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[r#71, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[r#71, AVLTreeNode.balanceFactor] := SecMask[r#71, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[r#71, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, r#71, AVLTreeNode.valid)) {
    oldVers#_3055 := Heap[r#71, AVLTreeNode.valid];
    havoc newVers#_3056;
    Heap[r#71, AVLTreeNode.valid] := newVers#_3056;
    assume oldVers#_3055 < Heap[r#71, AVLTreeNode.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[r#71, AVLTreeNode.key] := Mask[r#71, AVLTreeNode.key][perm$R := Mask[r#71, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#71, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#71, AVLTreeNode.height] := Mask[r#71, AVLTreeNode.height][perm$R := Mask[r#71, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#71, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[r#71, AVLTreeNode.left] == null) || (dtype(Heap[r#71, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[r#71, AVLTreeNode.left] := Mask[r#71, AVLTreeNode.left][perm$R := Mask[r#71, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#71, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[r#71, AVLTreeNode.right] == null) || (dtype(Heap[r#71, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[r#71, AVLTreeNode.right] := Mask[r#71, AVLTreeNode.right][perm$R := Mask[r#71, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#71, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#71, AVLTreeNode.keys] := Mask[r#71, AVLTreeNode.keys][perm$R := Mask[r#71, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#71, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#71, AVLTreeNode.balanceFactor] := Mask[r#71, AVLTreeNode.balanceFactor][perm$R := Mask[r#71, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#71, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[r#71, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[r#71, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[r#71, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[r#71, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume (forall lk#79#876: int :: (0 <= lk#79#876) && (lk#79#876 < Seq#Length(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys], lk#79#876) < Heap[r#71, AVLTreeNode.key]));
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[r#71, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[r#71, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[r#71, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[r#71, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume (forall rk#80#877: int :: (0 <= rk#80#877) && (rk#80#877 < Seq#Length(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#71, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys], rk#80#877)));
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[r#71, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#71, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#71, AVLTreeNode.key])), ite(Heap[r#71, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[r#71, AVLTreeNode.keys], Heap[r#71, AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[r#71, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#71, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#71, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#71, AVLTreeNode.key])));
  assume Heap[r#71, AVLTreeNode.height] == ite(ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[r#71, AVLTreeNode.balanceFactor] == (ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[r#71, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[r#71, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[r#71, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // assert
  assertHeap#_3057 := Heap;
  assertMask#_3058 := Mask;
  assertSecMask#_3059 := SecMask;
  assertCredits#_3060 := Credits;
  assume wf(assertHeap#_3057, assertMask#_3058, assertSecMask#_3059);
  // begin exhale (assert)
  exhaleMask#_3062 := assertMask#_3058;
  havoc exhaleHeap#_3061;
  assert {:msg "  831.10: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  831.10: Location might not be readable."} true ==> CanRead(assertMask#_3058, assertSecMask#_3059, r#71, AVLTreeNode.left);
  if (!(assertHeap#_3057[r#71, AVLTreeNode.left] == null)) {
    assert {:msg "  831.10: Receiver might be null."} true && (0 <= k#110#879) ==> (r#71 != null);
    assert {:msg "  831.10: Location might not be readable."} true && (0 <= k#110#879) ==> CanRead(assertMask#_3058, assertSecMask#_3059, r#71, AVLTreeNode.left);
    assert {:msg "  831.10: Receiver might be null."} true && (0 <= k#110#879) ==> (assertHeap#_3057[r#71, AVLTreeNode.left] != null);
    assert {:msg "  831.10: Location might not be readable."} true && (0 <= k#110#879) ==> CanRead(assertMask#_3058, assertSecMask#_3059, assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  831.54: Receiver might be null."} true && (0 <= k#110#879) && (k#110#879 < Seq#Length(assertHeap#_3057[assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  831.54: Location might not be readable."} true && (0 <= k#110#879) && (k#110#879 < Seq#Length(assertHeap#_3057[assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_3058, assertSecMask#_3059, this, AVLTreeNode.key);
    assert {:msg "  831.10: Receiver might be null."} true && (0 <= k#110#879) && (k#110#879 < Seq#Length(assertHeap#_3057[assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (r#71 != null);
    assert {:msg "  831.10: Location might not be readable."} true && (0 <= k#110#879) && (k#110#879 < Seq#Length(assertHeap#_3057[assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_3058, assertSecMask#_3059, r#71, AVLTreeNode.left);
    assert {:msg "  831.10: Receiver might be null."} true && (0 <= k#110#879) && (k#110#879 < Seq#Length(assertHeap#_3057[assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (assertHeap#_3057[r#71, AVLTreeNode.left] != null);
    assert {:msg "  831.10: Location might not be readable."} true && (0 <= k#110#879) && (k#110#879 < Seq#Length(assertHeap#_3057[assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_3058, assertSecMask#_3059, assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  831.60: Sequence index might be negative."} true && (0 <= k#110#879) && (k#110#879 < Seq#Length(assertHeap#_3057[assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#110#879);
    assert {:msg "  831.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#110#879) && (k#110#879 < Seq#Length(assertHeap#_3057[assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#110#879 < Seq#Length(assertHeap#_3057[assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  831.3: Assertion might not hold. The expression at 831.27 might not evaluate to true."} (forall k#110#878: int :: (0 <= k#110#878) && (k#110#878 < Seq#Length(assertHeap#_3057[assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (assertHeap#_3057[this, AVLTreeNode.key] < Seq#Index(assertHeap#_3057[assertHeap#_3057[r#71, AVLTreeNode.left], AVLTreeNode.keys], k#110#878)));
  }
  assertMask#_3058 := exhaleMask#_3062;
  assume IsGoodExhaleState(exhaleHeap#_3061, assertHeap#_3057, assertMask#_3058, assertSecMask#_3059);
  assertHeap#_3057 := exhaleHeap#_3061;
  assume IsGoodMask(assertMask#_3058);
  assume wf(assertHeap#_3057, assertMask#_3058, assertSecMask#_3059);
  // end exhale
  // update field left
  assert {:msg "  832.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  832.3: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  832.3: Location might not be writable"} CanWrite(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.left);
  assert {:msg "  832.17: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  832.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#71, AVLTreeNode.right);
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := Heap[r#71, AVLTreeNode.right];
  assume wf(Heap, Mask, SecMask);
  assume (0 < methodCallK#_3067) && ((1000 * methodCallK#_3067) < Fractions(1)) && ((1000 * methodCallK#_3067) < methodK#_2935);
  // call close
  callHeap#_3063 := Heap;
  callMask#_3064 := Mask;
  callSecMask#_3065 := SecMask;
  callCredits#_3066 := Credits;
  assume wf(callHeap#_3063, callMask#_3064, callSecMask#_3065);
  assert {:msg "  833.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  833.8: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  833.3: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
  this#881 := Heap[this, AVLTreeNode.right];
  // begin exhale (precondition)
  exhaleMask#_3069 := Mask;
  havoc exhaleHeap#_3068;
  if (!(Heap[this#881, AVLTreeNode.left] == null)) {
    assert {:msg "  833.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#882: int :: (0 <= k#92#882) && (k#92#882 < Seq#Length(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys], k#92#882) < Heap[this#881, AVLTreeNode.key]));
  }
  if (!(Heap[this#881, AVLTreeNode.right] == null)) {
    assert {:msg "  833.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#883: int :: (0 <= k#93#883) && (k#93#883 < Seq#Length(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#881, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys], k#93#883)));
  }
  assert {:msg "  833.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#881, AVLTreeNode.left] == null, 0, Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#881, AVLTreeNode.right] == null, 0, Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  833.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#881, AVLTreeNode.left] == null, 0, Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#881, AVLTreeNode.right] == null, 0, Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  833.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  833.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_3069[this#881, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_3069[this#881, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_3069[this#881, AVLTreeNode.key][perm$N]));
  exhaleMask#_3069[this#881, AVLTreeNode.key] := exhaleMask#_3069[this#881, AVLTreeNode.key][perm$R := exhaleMask#_3069[this#881, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3069);
  assume wf(Heap, exhaleMask#_3069, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  833.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  833.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_3069[this#881, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_3069[this#881, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3069[this#881, AVLTreeNode.height][perm$N]));
  exhaleMask#_3069[this#881, AVLTreeNode.height] := exhaleMask#_3069[this#881, AVLTreeNode.height][perm$R := exhaleMask#_3069[this#881, AVLTreeNode.height][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3069);
  assume wf(Heap, exhaleMask#_3069, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  833.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  833.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_3069[this#881, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_3069[this#881, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_3069[this#881, AVLTreeNode.left][perm$N]));
  exhaleMask#_3069[this#881, AVLTreeNode.left] := exhaleMask#_3069[this#881, AVLTreeNode.left][perm$R := exhaleMask#_3069[this#881, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3069);
  assume wf(Heap, exhaleMask#_3069, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  833.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  833.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_3069[this#881, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_3069[this#881, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_3069[this#881, AVLTreeNode.right][perm$N]));
  exhaleMask#_3069[this#881, AVLTreeNode.right] := exhaleMask#_3069[this#881, AVLTreeNode.right][perm$R := exhaleMask#_3069[this#881, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3069);
  assume wf(Heap, exhaleMask#_3069, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  833.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  833.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_3069[this#881, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_3069[this#881, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3069[this#881, AVLTreeNode.keys][perm$N]));
  exhaleMask#_3069[this#881, AVLTreeNode.keys] := exhaleMask#_3069[this#881, AVLTreeNode.keys][perm$R := exhaleMask#_3069[this#881, AVLTreeNode.keys][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3069);
  assume wf(Heap, exhaleMask#_3069, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  833.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  833.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_3069[this#881, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_3069[this#881, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3069[this#881, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_3069[this#881, AVLTreeNode.balanceFactor] := exhaleMask#_3069[this#881, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3069[this#881, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3069);
  assume wf(Heap, exhaleMask#_3069, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#881, AVLTreeNode.left] == null)) {
    assert {:msg "  833.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
    assert {:msg "  833.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false || ((predVer#_2983 == Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2982 == Heap[this#881, AVLTreeNode.left]) && true && predFlag#_2984)) {
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#884: int :: (0 <= lk#79#884) && (lk#79#884 < Seq#Length(Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#884) < Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#885: int :: (0 <= rk#80#885) && (rk#80#885 < Seq#Length(Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#885)));
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height] > 0;
      SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_3069, SecMask, Heap[this#881, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#881, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_3068[Heap[this#881, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_3069);
    assume wf(Heap, exhaleMask#_3069, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#881, AVLTreeNode.left] == null)) {
    assert {:msg "  833.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  833.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3069);
    assume wf(Heap, exhaleMask#_3069, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#881, AVLTreeNode.left] == null)) {
    assert {:msg "  833.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  833.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3069);
    assume wf(Heap, exhaleMask#_3069, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#881, AVLTreeNode.left] == null)) {
    assert {:msg "  833.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  833.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3069[Heap[this#881, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3069);
    assume wf(Heap, exhaleMask#_3069, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#881, AVLTreeNode.right] == null)) {
    assert {:msg "  833.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
    assert {:msg "  833.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false || ((predVer#_2983 == Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2982 == Heap[this#881, AVLTreeNode.right]) && true && predFlag#_2984)) {
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#889: int :: (0 <= lk#79#889) && (lk#79#889 < Seq#Length(Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#889) < Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#890: int :: (0 <= rk#80#890) && (rk#80#890 < Seq#Length(Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#890)));
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height] > 0;
      SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_3069, SecMask, Heap[this#881, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#881, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_3068[Heap[this#881, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_3069);
    assume wf(Heap, exhaleMask#_3069, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#881, AVLTreeNode.right] == null)) {
    assert {:msg "  833.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  833.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3069);
    assume wf(Heap, exhaleMask#_3069, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#881, AVLTreeNode.right] == null)) {
    assert {:msg "  833.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  833.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3069);
    assume wf(Heap, exhaleMask#_3069, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#881, AVLTreeNode.right] == null)) {
    assert {:msg "  833.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  833.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3069[Heap[this#881, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3069);
    assume wf(Heap, exhaleMask#_3069, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_3069;
  assume IsGoodExhaleState(exhaleHeap#_3068, Heap, Mask, SecMask);
  Heap := exhaleHeap#_3068;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#881 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#881, AVLTreeNode.valid] := Mask[this#881, AVLTreeNode.valid][perm$R := Mask[this#881, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#881, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#881 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#881, AVLTreeNode.height] := Mask[this#881, AVLTreeNode.height][perm$R := Mask[this#881, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#881, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#881 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#881, AVLTreeNode.keys] := Mask[this#881, AVLTreeNode.keys][perm$R := Mask[this#881, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#881, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#881 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#881, AVLTreeNode.balanceFactor] := Mask[this#881, AVLTreeNode.balanceFactor][perm$R := Mask[this#881, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#881, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#881, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_3063[this#881, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_3063[callHeap#_3063[this#881, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_3063[this#881, AVLTreeNode.key])), ite(callHeap#_3063[this#881, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_3063[callHeap#_3063[this#881, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#881, AVLTreeNode.height] == ite(ite(callHeap#_3063[this#881, AVLTreeNode.left] == null, 0, callHeap#_3063[callHeap#_3063[this#881, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_3063[this#881, AVLTreeNode.right] == null, 0, callHeap#_3063[callHeap#_3063[this#881, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_3063[this#881, AVLTreeNode.left] == null, 0, callHeap#_3063[callHeap#_3063[this#881, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_3063[this#881, AVLTreeNode.right] == null, 0, callHeap#_3063[callHeap#_3063[this#881, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#881, AVLTreeNode.balanceFactor] == (ite(callHeap#_3063[this#881, AVLTreeNode.left] == null, 0, callHeap#_3063[callHeap#_3063[this#881, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_3063[this#881, AVLTreeNode.right] == null, 0, callHeap#_3063[callHeap#_3063[this#881, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // update field right
  assert {:msg "  834.3: Location might not be writable"} CanWrite(Mask, r#71, AVLTreeNode.right);
  assert {:msg "  834.17: Receiver might be null."} true ==> (this != null);
  assert {:msg "  834.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  Heap[r#71, AVLTreeNode.right] := Heap[this, AVLTreeNode.right];
  assume wf(Heap, Mask, SecMask);
  // update field right
  assert {:msg "  835.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
  assert {:msg "  835.17: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  835.17: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#71, AVLTreeNode.left);
  Heap[this, AVLTreeNode.right] := Heap[r#71, AVLTreeNode.left];
  assume wf(Heap, Mask, SecMask);
  // assert
  assertHeap#_3118 := Heap;
  assertMask#_3119 := Mask;
  assertSecMask#_3120 := SecMask;
  assertCredits#_3121 := Credits;
  assume wf(assertHeap#_3118, assertMask#_3119, assertSecMask#_3120);
  // begin exhale (assert)
  exhaleMask#_3123 := assertMask#_3119;
  havoc exhaleHeap#_3122;
  assert {:msg "  836.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  836.10: Location might not be readable."} true ==> CanRead(assertMask#_3119, assertSecMask#_3120, this, AVLTreeNode.right);
  if (!(assertHeap#_3118[this, AVLTreeNode.right] == null)) {
    assert {:msg "  836.10: Receiver might be null."} true && (0 <= k#111#895) ==> (this != null);
    assert {:msg "  836.10: Location might not be readable."} true && (0 <= k#111#895) ==> CanRead(assertMask#_3119, assertSecMask#_3120, this, AVLTreeNode.right);
    assert {:msg "  836.10: Receiver might be null."} true && (0 <= k#111#895) ==> (assertHeap#_3118[this, AVLTreeNode.right] != null);
    assert {:msg "  836.10: Location might not be readable."} true && (0 <= k#111#895) ==> CanRead(assertMask#_3119, assertSecMask#_3120, assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  836.52: Receiver might be null."} true && (0 <= k#111#895) && (k#111#895 < Seq#Length(assertHeap#_3118[assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  836.52: Location might not be readable."} true && (0 <= k#111#895) && (k#111#895 < Seq#Length(assertHeap#_3118[assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_3119, assertSecMask#_3120, this, AVLTreeNode.key);
    assert {:msg "  836.10: Receiver might be null."} true && (0 <= k#111#895) && (k#111#895 < Seq#Length(assertHeap#_3118[assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  836.10: Location might not be readable."} true && (0 <= k#111#895) && (k#111#895 < Seq#Length(assertHeap#_3118[assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_3119, assertSecMask#_3120, this, AVLTreeNode.right);
    assert {:msg "  836.10: Receiver might be null."} true && (0 <= k#111#895) && (k#111#895 < Seq#Length(assertHeap#_3118[assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_3118[this, AVLTreeNode.right] != null);
    assert {:msg "  836.10: Location might not be readable."} true && (0 <= k#111#895) && (k#111#895 < Seq#Length(assertHeap#_3118[assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_3119, assertSecMask#_3120, assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  836.58: Sequence index might be negative."} true && (0 <= k#111#895) && (k#111#895 < Seq#Length(assertHeap#_3118[assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#111#895);
    assert {:msg "  836.58: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#111#895) && (k#111#895 < Seq#Length(assertHeap#_3118[assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#111#895 < Seq#Length(assertHeap#_3118[assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assert {:msg "  836.3: Assertion might not hold. The expression at 836.26 might not evaluate to true."} (forall k#111#894: int :: (0 <= k#111#894) && (k#111#894 < Seq#Length(assertHeap#_3118[assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_3118[this, AVLTreeNode.key] < Seq#Index(assertHeap#_3118[assertHeap#_3118[this, AVLTreeNode.right], AVLTreeNode.keys], k#111#894)));
  }
  assertMask#_3119 := exhaleMask#_3123;
  assume IsGoodExhaleState(exhaleHeap#_3122, assertHeap#_3118, assertMask#_3119, assertSecMask#_3120);
  assertHeap#_3118 := exhaleHeap#_3122;
  assume IsGoodMask(assertMask#_3119);
  assume wf(assertHeap#_3118, assertMask#_3119, assertSecMask#_3120);
  // end exhale
  assume (0 < methodCallK#_3128) && ((1000 * methodCallK#_3128) < Fractions(1)) && ((1000 * methodCallK#_3128) < methodK#_2935);
  // call close
  callHeap#_3124 := Heap;
  callMask#_3125 := Mask;
  callSecMask#_3126 := SecMask;
  callCredits#_3127 := Credits;
  assume wf(callHeap#_3124, callMask#_3125, callSecMask#_3126);
  assert {:msg "  837.3: The target of the method call might be null."} this != null;
  this#897 := this;
  // begin exhale (precondition)
  exhaleMask#_3130 := Mask;
  havoc exhaleHeap#_3129;
  if (!(Heap[this#897, AVLTreeNode.left] == null)) {
    assert {:msg "  837.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#898: int :: (0 <= k#92#898) && (k#92#898 < Seq#Length(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys], k#92#898) < Heap[this#897, AVLTreeNode.key]));
  }
  if (!(Heap[this#897, AVLTreeNode.right] == null)) {
    assert {:msg "  837.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#899: int :: (0 <= k#93#899) && (k#93#899 < Seq#Length(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#897, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys], k#93#899)));
  }
  assert {:msg "  837.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#897, AVLTreeNode.left] == null, 0, Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#897, AVLTreeNode.right] == null, 0, Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  837.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#897, AVLTreeNode.left] == null, 0, Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#897, AVLTreeNode.right] == null, 0, Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  837.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  837.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_3130[this#897, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_3130[this#897, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_3130[this#897, AVLTreeNode.key][perm$N]));
  exhaleMask#_3130[this#897, AVLTreeNode.key] := exhaleMask#_3130[this#897, AVLTreeNode.key][perm$R := exhaleMask#_3130[this#897, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3130);
  assume wf(Heap, exhaleMask#_3130, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  837.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  837.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_3130[this#897, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_3130[this#897, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3130[this#897, AVLTreeNode.height][perm$N]));
  exhaleMask#_3130[this#897, AVLTreeNode.height] := exhaleMask#_3130[this#897, AVLTreeNode.height][perm$R := exhaleMask#_3130[this#897, AVLTreeNode.height][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3130);
  assume wf(Heap, exhaleMask#_3130, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  837.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  837.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_3130[this#897, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_3130[this#897, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_3130[this#897, AVLTreeNode.left][perm$N]));
  exhaleMask#_3130[this#897, AVLTreeNode.left] := exhaleMask#_3130[this#897, AVLTreeNode.left][perm$R := exhaleMask#_3130[this#897, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3130);
  assume wf(Heap, exhaleMask#_3130, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  837.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  837.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_3130[this#897, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_3130[this#897, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_3130[this#897, AVLTreeNode.right][perm$N]));
  exhaleMask#_3130[this#897, AVLTreeNode.right] := exhaleMask#_3130[this#897, AVLTreeNode.right][perm$R := exhaleMask#_3130[this#897, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3130);
  assume wf(Heap, exhaleMask#_3130, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  837.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  837.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_3130[this#897, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_3130[this#897, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3130[this#897, AVLTreeNode.keys][perm$N]));
  exhaleMask#_3130[this#897, AVLTreeNode.keys] := exhaleMask#_3130[this#897, AVLTreeNode.keys][perm$R := exhaleMask#_3130[this#897, AVLTreeNode.keys][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3130);
  assume wf(Heap, exhaleMask#_3130, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  837.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  837.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_3130[this#897, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_3130[this#897, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3130[this#897, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_3130[this#897, AVLTreeNode.balanceFactor] := exhaleMask#_3130[this#897, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3130[this#897, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3130);
  assume wf(Heap, exhaleMask#_3130, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#897, AVLTreeNode.left] == null)) {
    assert {:msg "  837.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
    assert {:msg "  837.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false || ((predVer#_2983 == Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2982 == Heap[this#897, AVLTreeNode.left]) && true && predFlag#_2984)) {
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#900: int :: (0 <= lk#79#900) && (lk#79#900 < Seq#Length(Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#900) < Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#901: int :: (0 <= rk#80#901) && (rk#80#901 < Seq#Length(Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#901)));
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height] > 0;
      SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_3130, SecMask, Heap[this#897, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#897, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_3129[Heap[this#897, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_3130);
    assume wf(Heap, exhaleMask#_3130, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#897, AVLTreeNode.left] == null)) {
    assert {:msg "  837.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  837.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3130);
    assume wf(Heap, exhaleMask#_3130, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#897, AVLTreeNode.left] == null)) {
    assert {:msg "  837.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  837.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3130);
    assume wf(Heap, exhaleMask#_3130, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#897, AVLTreeNode.left] == null)) {
    assert {:msg "  837.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  837.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3130[Heap[this#897, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3130);
    assume wf(Heap, exhaleMask#_3130, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#897, AVLTreeNode.right] == null)) {
    assert {:msg "  837.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
    assert {:msg "  837.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false || ((predVer#_2983 == Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2982 == Heap[this#897, AVLTreeNode.right]) && true && predFlag#_2984)) {
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#905: int :: (0 <= lk#79#905) && (lk#79#905 < Seq#Length(Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#905) < Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#906: int :: (0 <= rk#80#906) && (rk#80#906 < Seq#Length(Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#906)));
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height] > 0;
      SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_3130, SecMask, Heap[this#897, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#897, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_3129[Heap[this#897, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_3130);
    assume wf(Heap, exhaleMask#_3130, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#897, AVLTreeNode.right] == null)) {
    assert {:msg "  837.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  837.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3130);
    assume wf(Heap, exhaleMask#_3130, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#897, AVLTreeNode.right] == null)) {
    assert {:msg "  837.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  837.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3130);
    assume wf(Heap, exhaleMask#_3130, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#897, AVLTreeNode.right] == null)) {
    assert {:msg "  837.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  837.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3130[Heap[this#897, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3130);
    assume wf(Heap, exhaleMask#_3130, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_3130;
  assume IsGoodExhaleState(exhaleHeap#_3129, Heap, Mask, SecMask);
  Heap := exhaleHeap#_3129;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#897 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#897, AVLTreeNode.valid] := Mask[this#897, AVLTreeNode.valid][perm$R := Mask[this#897, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#897, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#897 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#897, AVLTreeNode.height] := Mask[this#897, AVLTreeNode.height][perm$R := Mask[this#897, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#897, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#897 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#897, AVLTreeNode.keys] := Mask[this#897, AVLTreeNode.keys][perm$R := Mask[this#897, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#897, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#897 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#897, AVLTreeNode.balanceFactor] := Mask[this#897, AVLTreeNode.balanceFactor][perm$R := Mask[this#897, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#897, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#897, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_3124[this#897, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_3124[callHeap#_3124[this#897, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_3124[this#897, AVLTreeNode.key])), ite(callHeap#_3124[this#897, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_3124[callHeap#_3124[this#897, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#897, AVLTreeNode.height] == ite(ite(callHeap#_3124[this#897, AVLTreeNode.left] == null, 0, callHeap#_3124[callHeap#_3124[this#897, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_3124[this#897, AVLTreeNode.right] == null, 0, callHeap#_3124[callHeap#_3124[this#897, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_3124[this#897, AVLTreeNode.left] == null, 0, callHeap#_3124[callHeap#_3124[this#897, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_3124[this#897, AVLTreeNode.right] == null, 0, callHeap#_3124[callHeap#_3124[this#897, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#897, AVLTreeNode.balanceFactor] == (ite(callHeap#_3124[this#897, AVLTreeNode.left] == null, 0, callHeap#_3124[callHeap#_3124[this#897, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_3124[this#897, AVLTreeNode.right] == null, 0, callHeap#_3124[callHeap#_3124[this#897, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // update field left
  assert {:msg "  838.3: Location might not be writable"} CanWrite(Mask, r#71, AVLTreeNode.left);
  Heap[r#71, AVLTreeNode.left] := this;
  assume wf(Heap, Mask, SecMask);
  assume (0 < methodCallK#_3183) && ((1000 * methodCallK#_3183) < Fractions(1)) && ((1000 * methodCallK#_3183) < methodK#_2935);
  // call close
  callHeap#_3179 := Heap;
  callMask#_3180 := Mask;
  callSecMask#_3181 := SecMask;
  callCredits#_3182 := Credits;
  assume wf(callHeap#_3179, callMask#_3180, callSecMask#_3181);
  assert {:msg "  839.3: The target of the method call might be null."} r#71 != null;
  this#910 := r#71;
  // begin exhale (precondition)
  exhaleMask#_3185 := Mask;
  havoc exhaleHeap#_3184;
  if (!(Heap[this#910, AVLTreeNode.left] == null)) {
    assert {:msg "  839.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#911: int :: (0 <= k#92#911) && (k#92#911 < Seq#Length(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys], k#92#911) < Heap[this#910, AVLTreeNode.key]));
  }
  if (!(Heap[this#910, AVLTreeNode.right] == null)) {
    assert {:msg "  839.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#912: int :: (0 <= k#93#912) && (k#93#912 < Seq#Length(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#910, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys], k#93#912)));
  }
  assert {:msg "  839.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#910, AVLTreeNode.left] == null, 0, Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#910, AVLTreeNode.right] == null, 0, Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  839.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#910, AVLTreeNode.left] == null, 0, Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#910, AVLTreeNode.right] == null, 0, Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  839.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  839.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_3185[this#910, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_3185[this#910, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_3185[this#910, AVLTreeNode.key][perm$N]));
  exhaleMask#_3185[this#910, AVLTreeNode.key] := exhaleMask#_3185[this#910, AVLTreeNode.key][perm$R := exhaleMask#_3185[this#910, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3185);
  assume wf(Heap, exhaleMask#_3185, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  839.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  839.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_3185[this#910, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_3185[this#910, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3185[this#910, AVLTreeNode.height][perm$N]));
  exhaleMask#_3185[this#910, AVLTreeNode.height] := exhaleMask#_3185[this#910, AVLTreeNode.height][perm$R := exhaleMask#_3185[this#910, AVLTreeNode.height][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3185);
  assume wf(Heap, exhaleMask#_3185, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  839.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  839.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_3185[this#910, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_3185[this#910, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_3185[this#910, AVLTreeNode.left][perm$N]));
  exhaleMask#_3185[this#910, AVLTreeNode.left] := exhaleMask#_3185[this#910, AVLTreeNode.left][perm$R := exhaleMask#_3185[this#910, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3185);
  assume wf(Heap, exhaleMask#_3185, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  839.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  839.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_3185[this#910, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_3185[this#910, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_3185[this#910, AVLTreeNode.right][perm$N]));
  exhaleMask#_3185[this#910, AVLTreeNode.right] := exhaleMask#_3185[this#910, AVLTreeNode.right][perm$R := exhaleMask#_3185[this#910, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3185);
  assume wf(Heap, exhaleMask#_3185, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  839.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  839.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_3185[this#910, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_3185[this#910, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3185[this#910, AVLTreeNode.keys][perm$N]));
  exhaleMask#_3185[this#910, AVLTreeNode.keys] := exhaleMask#_3185[this#910, AVLTreeNode.keys][perm$R := exhaleMask#_3185[this#910, AVLTreeNode.keys][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3185);
  assume wf(Heap, exhaleMask#_3185, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  839.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  839.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_3185[this#910, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_3185[this#910, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3185[this#910, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_3185[this#910, AVLTreeNode.balanceFactor] := exhaleMask#_3185[this#910, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3185[this#910, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3185);
  assume wf(Heap, exhaleMask#_3185, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#910, AVLTreeNode.left] == null)) {
    assert {:msg "  839.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
    assert {:msg "  839.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false || ((predVer#_2983 == Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.valid]) && (predRec#_2982 == Heap[this#910, AVLTreeNode.left]) && true && predFlag#_2984)) {
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#913: int :: (0 <= lk#79#913) && (lk#79#913 < Seq#Length(Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#913) < Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#914: int :: (0 <= rk#80#914) && (rk#80#914 < Seq#Length(Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#914)));
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height] > 0;
      SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.key][perm$R := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.key] := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left][perm$R := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right][perm$R := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_3185, SecMask, Heap[this#910, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#910, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_3184[Heap[this#910, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_3185);
    assume wf(Heap, exhaleMask#_3185, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#910, AVLTreeNode.left] == null)) {
    assert {:msg "  839.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  839.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3185);
    assume wf(Heap, exhaleMask#_3185, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#910, AVLTreeNode.left] == null)) {
    assert {:msg "  839.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  839.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3185);
    assume wf(Heap, exhaleMask#_3185, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#910, AVLTreeNode.left] == null)) {
    assert {:msg "  839.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  839.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3185[Heap[this#910, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3185);
    assume wf(Heap, exhaleMask#_3185, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#910, AVLTreeNode.right] == null)) {
    assert {:msg "  839.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
    assert {:msg "  839.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (false || ((predVer#_2983 == Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.valid]) && (predRec#_2982 == Heap[this#910, AVLTreeNode.right]) && true && predFlag#_2984)) {
      // begin exhale (update SecMask)
      if (!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
        assume (forall lk#79#918: int :: (0 <= lk#79#918) && (lk#79#918 < Seq#Length(Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#918) < Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.key]));
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
        assume Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
        assume (forall rk#80#919: int :: (0 <= rk#80#919) && (rk#80#919 < Seq#Length(Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#919)));
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
        assume Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
      assume Seq#Equal(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
      //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
      assume Seq#Contains(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.key]);
      //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
      assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.key])));
      //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
      assume Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
      //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
      assume Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
      //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
      assume Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
      //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
      assume Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
      //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
      assume Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height] > 0;
      SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
        SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
        SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
      if (SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
        SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right] == null)) {
        SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
        if (SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
          SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
        }
        assume wf(Heap, SecMask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume wf(Heap, SecMask, SecMask);
      // end exhale
    }
    if (!CanRead(exhaleMask#_3185, SecMask, Heap[this#910, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#910, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_3184[Heap[this#910, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_3185);
    assume wf(Heap, exhaleMask#_3185, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#910, AVLTreeNode.right] == null)) {
    assert {:msg "  839.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  839.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3185);
    assume wf(Heap, exhaleMask#_3185, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#910, AVLTreeNode.right] == null)) {
    assert {:msg "  839.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  839.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3185);
    assume wf(Heap, exhaleMask#_3185, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#910, AVLTreeNode.right] == null)) {
    assert {:msg "  839.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  839.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3185[Heap[this#910, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3185);
    assume wf(Heap, exhaleMask#_3185, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_3185;
  assume IsGoodExhaleState(exhaleHeap#_3184, Heap, Mask, SecMask);
  Heap := exhaleHeap#_3184;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#910 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#910, AVLTreeNode.valid] := Mask[this#910, AVLTreeNode.valid][perm$R := Mask[this#910, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#910, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#910 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#910, AVLTreeNode.height] := Mask[this#910, AVLTreeNode.height][perm$R := Mask[this#910, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#910, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#910 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#910, AVLTreeNode.keys] := Mask[this#910, AVLTreeNode.keys][perm$R := Mask[this#910, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#910, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#910 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#910, AVLTreeNode.balanceFactor] := Mask[this#910, AVLTreeNode.balanceFactor][perm$R := Mask[this#910, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#910, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#910, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_3179[this#910, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_3179[callHeap#_3179[this#910, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_3179[this#910, AVLTreeNode.key])), ite(callHeap#_3179[this#910, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_3179[callHeap#_3179[this#910, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#910, AVLTreeNode.height] == ite(ite(callHeap#_3179[this#910, AVLTreeNode.left] == null, 0, callHeap#_3179[callHeap#_3179[this#910, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_3179[this#910, AVLTreeNode.right] == null, 0, callHeap#_3179[callHeap#_3179[this#910, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_3179[this#910, AVLTreeNode.left] == null, 0, callHeap#_3179[callHeap#_3179[this#910, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_3179[this#910, AVLTreeNode.right] == null, 0, callHeap#_3179[callHeap#_3179[this#910, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#910, AVLTreeNode.balanceFactor] == (ite(callHeap#_3179[this#910, AVLTreeNode.left] == null, 0, callHeap#_3179[callHeap#_3179[this#910, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_3179[this#910, AVLTreeNode.right] == null, 0, callHeap#_3179[callHeap#_3179[this#910, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_3235 := Mask;
  havoc exhaleHeap#_3234;
  assert {:msg "  790.2: The postcondition at 817.11 might not hold. The expression at 817.11 might not evaluate to true."} !(r#71 == null);
  assert {:msg "  790.2: The postcondition at 823.11 might not hold. The expression at 823.11 might not evaluate to true."} Heap[r#71, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height];
  assert {:msg "  790.2: The postcondition at 824.11 might not hold. The expression at 824.11 might not evaluate to true."} Seq#Equal(Heap[r#71, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assert {:msg "  790.2: The postcondition at 818.11 might not hold. The permission at 818.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  790.2: The postcondition at 818.11 might not hold. Insufficient fraction at 818.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_3235[r#71, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_3235[r#71, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_3235[r#71, AVLTreeNode.valid][perm$N]));
  exhaleMask#_3235[r#71, AVLTreeNode.valid] := exhaleMask#_3235[r#71, AVLTreeNode.valid][perm$R := exhaleMask#_3235[r#71, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false || ((predVer#_2983 == Heap[r#71, AVLTreeNode.valid]) && (predRec#_2982 == r#71) && true && predFlag#_2984)) {
    // begin exhale (update SecMask)
    if (!(Heap[r#71, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#923: int :: (0 <= lk#79#923) && (lk#79#923 < Seq#Length(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys], lk#79#923) < Heap[r#71, AVLTreeNode.key]));
    }
    if (!(Heap[r#71, AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[r#71, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#924: int :: (0 <= rk#80#924) && (rk#80#924 < Seq#Length(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#71, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys], rk#80#924)));
    }
    if (!(Heap[r#71, AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[r#71, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#71, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#71, AVLTreeNode.key])), ite(Heap[r#71, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[r#71, AVLTreeNode.keys], Heap[r#71, AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[r#71, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#71, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#71, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#71, AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[r#71, AVLTreeNode.height] == ite(ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[r#71, AVLTreeNode.balanceFactor] == (ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[r#71, AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[r#71, AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[r#71, AVLTreeNode.height] > 0;
    SecMask[r#71, AVLTreeNode.key] := SecMask[r#71, AVLTreeNode.key][perm$R := SecMask[r#71, AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[r#71, AVLTreeNode.key][perm$R] < 0) {
      SecMask[r#71, AVLTreeNode.key] := SecMask[r#71, AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#71, AVLTreeNode.height] := SecMask[r#71, AVLTreeNode.height][perm$R := SecMask[r#71, AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[r#71, AVLTreeNode.height][perm$R] < 0) {
      SecMask[r#71, AVLTreeNode.height] := SecMask[r#71, AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#71, AVLTreeNode.left] := SecMask[r#71, AVLTreeNode.left][perm$R := SecMask[r#71, AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[r#71, AVLTreeNode.left][perm$R] < 0) {
      SecMask[r#71, AVLTreeNode.left] := SecMask[r#71, AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#71, AVLTreeNode.right] := SecMask[r#71, AVLTreeNode.right][perm$R := SecMask[r#71, AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[r#71, AVLTreeNode.right][perm$R] < 0) {
      SecMask[r#71, AVLTreeNode.right] := SecMask[r#71, AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#71, AVLTreeNode.keys] := SecMask[r#71, AVLTreeNode.keys][perm$R := SecMask[r#71, AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[r#71, AVLTreeNode.keys][perm$R] < 0) {
      SecMask[r#71, AVLTreeNode.keys] := SecMask[r#71, AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[r#71, AVLTreeNode.balanceFactor] := SecMask[r#71, AVLTreeNode.balanceFactor][perm$R := SecMask[r#71, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[r#71, AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[r#71, AVLTreeNode.balanceFactor] := SecMask[r#71, AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[r#71, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.left] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[r#71, AVLTreeNode.right] == null)) {
      SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(exhaleMask#_3235, SecMask, r#71, AVLTreeNode.valid)) {
    assume Heap[r#71, AVLTreeNode.valid] < exhaleHeap#_3234[r#71, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_3235);
  assume wf(Heap, exhaleMask#_3235, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  790.2: The postcondition at 819.11 might not hold. The permission at 819.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  790.2: The postcondition at 819.11 might not hold. Insufficient fraction at 819.11 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_3235[r#71, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_3235[r#71, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3235[r#71, AVLTreeNode.height][perm$N]));
  exhaleMask#_3235[r#71, AVLTreeNode.height] := exhaleMask#_3235[r#71, AVLTreeNode.height][perm$R := exhaleMask#_3235[r#71, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_3235);
  assume wf(Heap, exhaleMask#_3235, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  790.2: The postcondition at 820.11 might not hold. The permission at 820.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  790.2: The postcondition at 820.11 might not hold. Insufficient fraction at 820.11 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_3235[r#71, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_3235[r#71, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3235[r#71, AVLTreeNode.keys][perm$N]));
  exhaleMask#_3235[r#71, AVLTreeNode.keys] := exhaleMask#_3235[r#71, AVLTreeNode.keys][perm$R := exhaleMask#_3235[r#71, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_3235);
  assume wf(Heap, exhaleMask#_3235, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  790.2: The postcondition at 821.11 might not hold. The permission at 821.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  790.2: The postcondition at 821.11 might not hold. Insufficient fraction at 821.11 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_3235[r#71, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_3235[r#71, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3235[r#71, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_3235[r#71, AVLTreeNode.balanceFactor] := exhaleMask#_3235[r#71, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3235[r#71, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_3235);
  assume wf(Heap, exhaleMask#_3235, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_3235;
  assume IsGoodExhaleState(exhaleHeap#_3234, Heap, Mask, SecMask);
  Heap := exhaleHeap#_3234;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  790.2: Method might lock/unlock more than allowed."} (forall lk#_3256: ref :: {Heap[lk#_3256, held]} {Heap[lk#_3256, rdheld]} (((0 < Heap[lk#_3256, held]) == (0 < old(Heap)[lk#_3256, held])) && (Heap[lk#_3256, rdheld] == old(Heap)[lk#_3256, rdheld])) || false);
  assert {:msg "  790.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceLL$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#72: ref where (r#72 == null) || (dtype(r#72) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_3257: int;
  var k#112#928: int where true;
  var k#113#930: int where true;
  assume (0 < methodK#_3257) && ((1000 * methodK#_3257) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  854.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  854.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  854.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  854.25: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  854.25: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  854.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  854.25: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  855.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  855.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  855.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  855.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  856.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  856.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  856.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  856.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  857.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  857.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  857.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  857.29: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  858.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  858.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  858.12: Receiver might be null."} true && (0 <= k#112#928) ==> (this != null);
    assert {:msg "  858.12: Location might not be readable."} true && (0 <= k#112#928) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  858.12: Receiver might be null."} true && (0 <= k#112#928) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  858.12: Location might not be readable."} true && (0 <= k#112#928) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  858.12: Receiver might be null."} true && (0 <= k#112#928) && (k#112#928 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  858.12: Location might not be readable."} true && (0 <= k#112#928) && (k#112#928 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  858.12: Receiver might be null."} true && (0 <= k#112#928) && (k#112#928 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  858.12: Location might not be readable."} true && (0 <= k#112#928) && (k#112#928 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  858.50: Sequence index might be negative."} true && (0 <= k#112#928) && (k#112#928 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#112#928);
    assert {:msg "  858.50: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#112#928) && (k#112#928 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#112#928 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  858.54: Receiver might be null."} true && (0 <= k#112#928) && (k#112#928 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  858.54: Location might not be readable."} true && (0 <= k#112#928) && (k#112#928 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
    assume (forall k#112#927: int :: (0 <= k#112#927) && (k#112#927 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#112#927) < Heap[this, AVLTreeNode.key]));
  }
  assert {:msg "  860.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  860.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume !(Heap[this, AVLTreeNode.right] == null);
  assert {:msg "  861.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  861.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  861.12: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
  assert {:msg "  861.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  861.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  862.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  862.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  863.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  863.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  864.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  864.16: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  865.12: Receiver might be null."} true && (0 <= k#113#930) ==> (this != null);
  assert {:msg "  865.12: Location might not be readable."} true && (0 <= k#113#930) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  865.12: Receiver might be null."} true && (0 <= k#113#930) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  865.12: Location might not be readable."} true && (0 <= k#113#930) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  865.38: Receiver might be null."} true && (0 <= k#113#930) && (k#113#930 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  865.38: Location might not be readable."} true && (0 <= k#113#930) && (k#113#930 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.key);
  assert {:msg "  865.12: Receiver might be null."} true && (0 <= k#113#930) && (k#113#930 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  865.12: Location might not be readable."} true && (0 <= k#113#930) && (k#113#930 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  865.12: Receiver might be null."} true && (0 <= k#113#930) && (k#113#930 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  865.12: Location might not be readable."} true && (0 <= k#113#930) && (k#113#930 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  865.44: Sequence index might be negative."} true && (0 <= k#113#930) && (k#113#930 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#113#930);
  assert {:msg "  865.44: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#113#930) && (k#113#930 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#113#930 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume (forall k#113#929: int :: (0 <= k#113#929) && (k#113#929 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#113#929)));
  assert {:msg "  867.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  867.13: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  867.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  867.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.left);
    assert {:msg "  867.26: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  867.26: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  867.39: Receiver might be null."} true ==> (this != null);
  assert {:msg "  867.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  867.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  867.39: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assert {:msg "  868.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  868.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  868.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  868.12: Location might not be readable."} true ==> CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#72 == null);
  assert {:msg "  871.11: Receiver might be null."} r#72 != null;
  assume r#72 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[r#72, AVLTreeNode.valid] := Mask[r#72, AVLTreeNode.valid][perm$R := Mask[r#72, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#72, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#72 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#72, AVLTreeNode.height] := Mask[r#72, AVLTreeNode.height][perm$R := Mask[r#72, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#72, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#72 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#72, AVLTreeNode.keys] := Mask[r#72, AVLTreeNode.keys][perm$R := Mask[r#72, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#72, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#72 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[r#72, AVLTreeNode.balanceFactor] := Mask[r#72, AVLTreeNode.balanceFactor][perm$R := Mask[r#72, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[r#72, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  876.11: Receiver might be null."} true ==> (r#72 != null);
  assert {:msg "  876.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#72, AVLTreeNode.height);
  assert {:msg "  876.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  876.27: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  assert {:msg "  876.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  876.27: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assert {:msg "  876.44: Receiver might be null."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (r#72 != null);
  assert {:msg "  876.44: Location might not be readable."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(Mask, SecMask, r#72, AVLTreeNode.height);
  assert {:msg "  876.60: Receiver might be null."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  876.60: Location might not be readable."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  assert {:msg "  876.60: Receiver might be null."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  876.60: Location might not be readable."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#72, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height] + 1));
  assert {:msg "  877.11: Receiver might be null."} true ==> (r#72 != null);
  assert {:msg "  877.11: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#72, AVLTreeNode.keys);
  assert {:msg "  877.26: Receiver might be null."} true ==> (this != null);
  assert {:msg "  877.26: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  877.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  877.51: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.left);
    assert {:msg "  877.51: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  877.51: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  877.71: Receiver might be null."} true ==> (this != null);
  assert {:msg "  877.71: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.key);
  assert {:msg "  877.84: Receiver might be null."} true ==> (this != null);
  assert {:msg "  877.84: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), this, AVLTreeNode.right);
  assert {:msg "  877.84: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  877.84: Location might not be readable."} true ==> CanRead(old(Mask), old(SecMask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  assume Seq#Equal(Heap[r#72, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}
procedure AVLTreeNode.rebalanceLL(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#72: ref where (r#72 == null) || (dtype(r#72) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_3257: int;
  var unfoldK#_3258: int;
  var oldVers#_3278: int;
  var newVers#_3279: int;
  var methodCallK#_3284: int;
  var this#939: ref where (this#939 == null) || (dtype(this#939) == AVLTreeNode#t);
  var callHeap#_3280: HeapType;
  var callMask#_3281: MaskType;
  var callSecMask#_3282: MaskType;
  var callCredits#_3283: CreditsType;
  var exhaleMask#_3286: MaskType;
  var exhaleHeap#_3285: HeapType;
  var isHeld#_3301: int;
  var isRdHeld#_3302: bool;
  var methodCallK#_3307: int;
  var this#944: ref where (this#944 == null) || (dtype(this#944) == AVLTreeNode#t);
  var callHeap#_3303: HeapType;
  var callMask#_3304: MaskType;
  var callSecMask#_3305: MaskType;
  var callCredits#_3306: CreditsType;
  var exhaleMask#_3309: MaskType;
  var exhaleHeap#_3308: HeapType;
  var isHeld#_3324: int;
  var isRdHeld#_3325: bool;
  var exhaleMask#_3327: MaskType;
  var exhaleHeap#_3326: HeapType;
  assume (0 < methodK#_3257) && ((1000 * methodK#_3257) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall k#112#931: int :: (0 <= k#112#931) && (k#112#931 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#112#931) < Heap[this, AVLTreeNode.key]));
  }
  assume !(Heap[this, AVLTreeNode.right] == null);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume (forall k#113#932: int :: (0 <= k#113#932) && (k#113#932 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#113#932)));
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  // unfold
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.right]);
  assume (0 < unfoldK#_3258) && (unfoldK#_3258 < Fractions(1)) && ((1000 * unfoldK#_3258) < methodK#_3257);
  assert {:msg "  879.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  879.10: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  assert {:msg "  879.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.right] != null;
  // begin exhale (unfold)
  assert {:msg "  879.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  879.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (Fractions(100) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (false) {
    // begin exhale (update SecMask)
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 129.22 might not evaluate to true.
      assume (forall lk#79#933: int :: (0 <= lk#79#933) && (lk#79#933 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#933) < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]));
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      //  assert <undefined position>:  The expression at 130.22 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 136.24 might not evaluate to true.
      assume (forall rk#80#934: int :: (0 <= rk#80#934) && (rk#80#934 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#934)));
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      //  assert <undefined position>:  The expression at 137.23 might not evaluate to true.
      assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    //  assert <undefined position>:  The expression at 139.6 might not evaluate to true.
    assume Seq#Equal(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    //  assert <undefined position>:  The expression at 140.6 might not evaluate to true.
    assume Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
    //  assert <undefined position>:  The expression at 141.7 might not evaluate to true.
    assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])));
    //  assert <undefined position>:  The expression at 146.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    //  assert <undefined position>:  The expression at 147.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    //  assert <undefined position>:  The expression at 148.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    //  assert <undefined position>:  The expression at 149.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    //  assert <undefined position>:  The expression at 150.6 might not evaluate to true.
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] - Fractions(100)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    if (SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
      SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
    }
    assume wf(Heap, SecMask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
      if (SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] < 0) {
        SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := 0];
      }
      assume wf(Heap, SecMask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume wf(Heap, SecMask, SecMask);
    // end exhale
  }
  if (!CanRead(Mask, SecMask, Heap[this, AVLTreeNode.right], AVLTreeNode.valid)) {
    oldVers#_3278 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    havoc newVers#_3279;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_3279;
    assume oldVers#_3278 < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
  assume Fractions(100) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume (forall lk#79#937: int :: (0 <= lk#79#937) && (lk#79#937 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#937) < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]));
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume Fractions(50) > 0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
    assume IsGoodMask(Mask);
    assume IsGoodState(heapFragment(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]));
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume (forall rk#80#938: int :: (0 <= rk#80#938) && (rk#80#938 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#938)));
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume (forall kk#81: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])));
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // assigment to r
  assert {:msg "  880.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  880.14: Location might not be readable."} true ==> CanRead(Mask, SecMask, this, AVLTreeNode.right);
  r#72 := Heap[this, AVLTreeNode.right];
  // update field right
  assert {:msg "  881.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
  assert {:msg "  881.15: Receiver might be null."} true ==> (r#72 != null);
  assert {:msg "  881.15: Location might not be readable."} true ==> CanRead(Mask, SecMask, r#72, AVLTreeNode.left);
  Heap[this, AVLTreeNode.right] := Heap[r#72, AVLTreeNode.left];
  assume wf(Heap, Mask, SecMask);
  assume (0 < methodCallK#_3284) && ((1000 * methodCallK#_3284) < Fractions(1)) && ((1000 * methodCallK#_3284) < methodK#_3257);
  // call close
  callHeap#_3280 := Heap;
  callMask#_3281 := Mask;
  callSecMask#_3282 := SecMask;
  callCredits#_3283 := Credits;
  assume wf(callHeap#_3280, callMask#_3281, callSecMask#_3282);
  assert {:msg "  882.3: The target of the method call might be null."} this != null;
  this#939 := this;
  // begin exhale (precondition)
  exhaleMask#_3286 := Mask;
  havoc exhaleHeap#_3285;
  if (!(Heap[this#939, AVLTreeNode.left] == null)) {
    assert {:msg "  882.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#940: int :: (0 <= k#92#940) && (k#92#940 < Seq#Length(Heap[Heap[this#939, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#939, AVLTreeNode.left], AVLTreeNode.keys], k#92#940) < Heap[this#939, AVLTreeNode.key]));
  }
  if (!(Heap[this#939, AVLTreeNode.right] == null)) {
    assert {:msg "  882.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#941: int :: (0 <= k#93#941) && (k#93#941 < Seq#Length(Heap[Heap[this#939, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#939, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#939, AVLTreeNode.right], AVLTreeNode.keys], k#93#941)));
  }
  assert {:msg "  882.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#939, AVLTreeNode.left] == null, 0, Heap[Heap[this#939, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#939, AVLTreeNode.right] == null, 0, Heap[Heap[this#939, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  882.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#939, AVLTreeNode.left] == null, 0, Heap[Heap[this#939, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#939, AVLTreeNode.right] == null, 0, Heap[Heap[this#939, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  882.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  882.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_3286[this#939, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_3286[this#939, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_3286[this#939, AVLTreeNode.key][perm$N]));
  exhaleMask#_3286[this#939, AVLTreeNode.key] := exhaleMask#_3286[this#939, AVLTreeNode.key][perm$R := exhaleMask#_3286[this#939, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3286);
  assume wf(Heap, exhaleMask#_3286, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  882.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  882.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_3286[this#939, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_3286[this#939, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3286[this#939, AVLTreeNode.height][perm$N]));
  exhaleMask#_3286[this#939, AVLTreeNode.height] := exhaleMask#_3286[this#939, AVLTreeNode.height][perm$R := exhaleMask#_3286[this#939, AVLTreeNode.height][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3286);
  assume wf(Heap, exhaleMask#_3286, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  882.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  882.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_3286[this#939, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_3286[this#939, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_3286[this#939, AVLTreeNode.left][perm$N]));
  exhaleMask#_3286[this#939, AVLTreeNode.left] := exhaleMask#_3286[this#939, AVLTreeNode.left][perm$R := exhaleMask#_3286[this#939, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3286);
  assume wf(Heap, exhaleMask#_3286, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  882.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  882.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_3286[this#939, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_3286[this#939, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_3286[this#939, AVLTreeNode.right][perm$N]));
  exhaleMask#_3286[this#939, AVLTreeNode.right] := exhaleMask#_3286[this#939, AVLTreeNode.right][perm$R := exhaleMask#_3286[this#939, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3286);
  assume wf(Heap, exhaleMask#_3286, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  882.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  882.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_3286[this#939, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_3286[this#939, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3286[this#939, AVLTreeNode.keys][perm$N]));
  exhaleMask#_3286[this#939, AVLTreeNode.keys] := exhaleMask#_3286[this#939, AVLTreeNode.keys][perm$R := exhaleMask#_3286[this#939, AVLTreeNode.keys][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3286);
  assume wf(Heap, exhaleMask#_3286, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  882.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  882.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_3286[this#939, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_3286[this#939, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3286[this#939, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_3286[this#939, AVLTreeNode.balanceFactor] := exhaleMask#_3286[this#939, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3286[this#939, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3286);
  assume wf(Heap, exhaleMask#_3286, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#939, AVLTreeNode.left] == null)) {
    assert {:msg "  882.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
    assert {:msg "  882.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_3286, SecMask, Heap[this#939, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#939, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_3285[Heap[this#939, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_3286);
    assume wf(Heap, exhaleMask#_3286, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#939, AVLTreeNode.left] == null)) {
    assert {:msg "  882.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  882.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3286);
    assume wf(Heap, exhaleMask#_3286, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#939, AVLTreeNode.left] == null)) {
    assert {:msg "  882.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  882.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3286);
    assume wf(Heap, exhaleMask#_3286, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#939, AVLTreeNode.left] == null)) {
    assert {:msg "  882.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  882.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3286[Heap[this#939, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3286);
    assume wf(Heap, exhaleMask#_3286, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#939, AVLTreeNode.right] == null)) {
    assert {:msg "  882.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
    assert {:msg "  882.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_3286, SecMask, Heap[this#939, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#939, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_3285[Heap[this#939, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_3286);
    assume wf(Heap, exhaleMask#_3286, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#939, AVLTreeNode.right] == null)) {
    assert {:msg "  882.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  882.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3286);
    assume wf(Heap, exhaleMask#_3286, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#939, AVLTreeNode.right] == null)) {
    assert {:msg "  882.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  882.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3286);
    assume wf(Heap, exhaleMask#_3286, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#939, AVLTreeNode.right] == null)) {
    assert {:msg "  882.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  882.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3286[Heap[this#939, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3286);
    assume wf(Heap, exhaleMask#_3286, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_3286;
  assume IsGoodExhaleState(exhaleHeap#_3285, Heap, Mask, SecMask);
  Heap := exhaleHeap#_3285;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#939 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#939, AVLTreeNode.valid] := Mask[this#939, AVLTreeNode.valid][perm$R := Mask[this#939, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#939, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#939 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#939, AVLTreeNode.height] := Mask[this#939, AVLTreeNode.height][perm$R := Mask[this#939, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#939, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#939 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#939, AVLTreeNode.keys] := Mask[this#939, AVLTreeNode.keys][perm$R := Mask[this#939, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#939, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#939 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#939, AVLTreeNode.balanceFactor] := Mask[this#939, AVLTreeNode.balanceFactor][perm$R := Mask[this#939, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#939, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#939, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_3280[this#939, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_3280[callHeap#_3280[this#939, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_3280[this#939, AVLTreeNode.key])), ite(callHeap#_3280[this#939, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_3280[callHeap#_3280[this#939, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#939, AVLTreeNode.height] == ite(ite(callHeap#_3280[this#939, AVLTreeNode.left] == null, 0, callHeap#_3280[callHeap#_3280[this#939, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_3280[this#939, AVLTreeNode.right] == null, 0, callHeap#_3280[callHeap#_3280[this#939, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_3280[this#939, AVLTreeNode.left] == null, 0, callHeap#_3280[callHeap#_3280[this#939, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_3280[this#939, AVLTreeNode.right] == null, 0, callHeap#_3280[callHeap#_3280[this#939, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#939, AVLTreeNode.balanceFactor] == (ite(callHeap#_3280[this#939, AVLTreeNode.left] == null, 0, callHeap#_3280[callHeap#_3280[this#939, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_3280[this#939, AVLTreeNode.right] == null, 0, callHeap#_3280[callHeap#_3280[this#939, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // update field left
  assert {:msg "  883.3: Location might not be writable"} CanWrite(Mask, r#72, AVLTreeNode.left);
  Heap[r#72, AVLTreeNode.left] := this;
  assume wf(Heap, Mask, SecMask);
  assume (0 < methodCallK#_3307) && ((1000 * methodCallK#_3307) < Fractions(1)) && ((1000 * methodCallK#_3307) < methodK#_3257);
  // call close
  callHeap#_3303 := Heap;
  callMask#_3304 := Mask;
  callSecMask#_3305 := SecMask;
  callCredits#_3306 := Credits;
  assume wf(callHeap#_3303, callMask#_3304, callSecMask#_3305);
  assert {:msg "  884.3: The target of the method call might be null."} r#72 != null;
  this#944 := r#72;
  // begin exhale (precondition)
  exhaleMask#_3309 := Mask;
  havoc exhaleHeap#_3308;
  if (!(Heap[this#944, AVLTreeNode.left] == null)) {
    assert {:msg "  884.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#945: int :: (0 <= k#92#945) && (k#92#945 < Seq#Length(Heap[Heap[this#944, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#944, AVLTreeNode.left], AVLTreeNode.keys], k#92#945) < Heap[this#944, AVLTreeNode.key]));
  }
  if (!(Heap[this#944, AVLTreeNode.right] == null)) {
    assert {:msg "  884.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#946: int :: (0 <= k#93#946) && (k#93#946 < Seq#Length(Heap[Heap[this#944, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#944, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#944, AVLTreeNode.right], AVLTreeNode.keys], k#93#946)));
  }
  assert {:msg "  884.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#944, AVLTreeNode.left] == null, 0, Heap[Heap[this#944, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#944, AVLTreeNode.right] == null, 0, Heap[Heap[this#944, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  884.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#944, AVLTreeNode.left] == null, 0, Heap[Heap[this#944, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#944, AVLTreeNode.right] == null, 0, Heap[Heap[this#944, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  884.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  884.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} (Fractions(100) <= exhaleMask#_3309[this#944, AVLTreeNode.key][perm$R]) && ((Fractions(100) == exhaleMask#_3309[this#944, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_3309[this#944, AVLTreeNode.key][perm$N]));
  exhaleMask#_3309[this#944, AVLTreeNode.key] := exhaleMask#_3309[this#944, AVLTreeNode.key][perm$R := exhaleMask#_3309[this#944, AVLTreeNode.key][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3309);
  assume wf(Heap, exhaleMask#_3309, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  884.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  884.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} (Fractions(100) <= exhaleMask#_3309[this#944, AVLTreeNode.height][perm$R]) && ((Fractions(100) == exhaleMask#_3309[this#944, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3309[this#944, AVLTreeNode.height][perm$N]));
  exhaleMask#_3309[this#944, AVLTreeNode.height] := exhaleMask#_3309[this#944, AVLTreeNode.height][perm$R := exhaleMask#_3309[this#944, AVLTreeNode.height][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3309);
  assume wf(Heap, exhaleMask#_3309, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  884.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  884.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} (Fractions(100) <= exhaleMask#_3309[this#944, AVLTreeNode.left][perm$R]) && ((Fractions(100) == exhaleMask#_3309[this#944, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_3309[this#944, AVLTreeNode.left][perm$N]));
  exhaleMask#_3309[this#944, AVLTreeNode.left] := exhaleMask#_3309[this#944, AVLTreeNode.left][perm$R := exhaleMask#_3309[this#944, AVLTreeNode.left][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3309);
  assume wf(Heap, exhaleMask#_3309, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  884.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  884.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} (Fractions(100) <= exhaleMask#_3309[this#944, AVLTreeNode.right][perm$R]) && ((Fractions(100) == exhaleMask#_3309[this#944, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_3309[this#944, AVLTreeNode.right][perm$N]));
  exhaleMask#_3309[this#944, AVLTreeNode.right] := exhaleMask#_3309[this#944, AVLTreeNode.right][perm$R := exhaleMask#_3309[this#944, AVLTreeNode.right][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3309);
  assume wf(Heap, exhaleMask#_3309, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  884.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  884.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} (Fractions(100) <= exhaleMask#_3309[this#944, AVLTreeNode.keys][perm$R]) && ((Fractions(100) == exhaleMask#_3309[this#944, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3309[this#944, AVLTreeNode.keys][perm$N]));
  exhaleMask#_3309[this#944, AVLTreeNode.keys] := exhaleMask#_3309[this#944, AVLTreeNode.keys][perm$R := exhaleMask#_3309[this#944, AVLTreeNode.keys][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3309);
  assume wf(Heap, exhaleMask#_3309, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  884.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} Fractions(100) > 0;
  assert {:msg "  884.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} (Fractions(100) <= exhaleMask#_3309[this#944, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(100) == exhaleMask#_3309[this#944, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3309[this#944, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_3309[this#944, AVLTreeNode.balanceFactor] := exhaleMask#_3309[this#944, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3309[this#944, AVLTreeNode.balanceFactor][perm$R] - Fractions(100)];
  assume IsGoodMask(exhaleMask#_3309);
  assume wf(Heap, exhaleMask#_3309, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#944, AVLTreeNode.left] == null)) {
    assert {:msg "  884.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} Fractions(100) > 0;
    assert {:msg "  884.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_3309, SecMask, Heap[this#944, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#944, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_3308[Heap[this#944, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_3309);
    assume wf(Heap, exhaleMask#_3309, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#944, AVLTreeNode.left] == null)) {
    assert {:msg "  884.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  884.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3309);
    assume wf(Heap, exhaleMask#_3309, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#944, AVLTreeNode.left] == null)) {
    assert {:msg "  884.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  884.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3309);
    assume wf(Heap, exhaleMask#_3309, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#944, AVLTreeNode.left] == null)) {
    assert {:msg "  884.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} Fractions(50) > 0;
    assert {:msg "  884.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3309[Heap[this#944, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3309);
    assume wf(Heap, exhaleMask#_3309, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#944, AVLTreeNode.right] == null)) {
    assert {:msg "  884.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} Fractions(100) > 0;
    assert {:msg "  884.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - Fractions(100)];
    if (!CanRead(exhaleMask#_3309, SecMask, Heap[this#944, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#944, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_3308[Heap[this#944, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume IsGoodMask(exhaleMask#_3309);
    assume wf(Heap, exhaleMask#_3309, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#944, AVLTreeNode.right] == null)) {
    assert {:msg "  884.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  884.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.height][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3309);
    assume wf(Heap, exhaleMask#_3309, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#944, AVLTreeNode.right] == null)) {
    assert {:msg "  884.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  884.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3309);
    assume wf(Heap, exhaleMask#_3309, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#944, AVLTreeNode.right] == null)) {
    assert {:msg "  884.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} Fractions(50) > 0;
    assert {:msg "  884.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3309[Heap[this#944, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
    assume IsGoodMask(exhaleMask#_3309);
    assume wf(Heap, exhaleMask#_3309, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_3309;
  assume IsGoodExhaleState(exhaleHeap#_3308, Heap, Mask, SecMask);
  Heap := exhaleHeap#_3308;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#944 != null;
  assume wf(Heap, Mask, SecMask);
  assume Fractions(100) > 0;
  Mask[this#944, AVLTreeNode.valid] := Mask[this#944, AVLTreeNode.valid][perm$R := Mask[this#944, AVLTreeNode.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#944, AVLTreeNode.valid]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#944 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#944, AVLTreeNode.height] := Mask[this#944, AVLTreeNode.height][perm$R := Mask[this#944, AVLTreeNode.height][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#944, AVLTreeNode.height]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#944 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#944, AVLTreeNode.keys] := Mask[this#944, AVLTreeNode.keys][perm$R := Mask[this#944, AVLTreeNode.keys][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#944, AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#944 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this#944, AVLTreeNode.balanceFactor] := Mask[this#944, AVLTreeNode.balanceFactor][perm$R := Mask[this#944, AVLTreeNode.balanceFactor][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(heapFragment(Heap[this#944, AVLTreeNode.balanceFactor]));
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#944, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_3303[this#944, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_3303[callHeap#_3303[this#944, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_3303[this#944, AVLTreeNode.key])), ite(callHeap#_3303[this#944, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_3303[callHeap#_3303[this#944, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#944, AVLTreeNode.height] == ite(ite(callHeap#_3303[this#944, AVLTreeNode.left] == null, 0, callHeap#_3303[callHeap#_3303[this#944, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_3303[this#944, AVLTreeNode.right] == null, 0, callHeap#_3303[callHeap#_3303[this#944, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_3303[this#944, AVLTreeNode.left] == null, 0, callHeap#_3303[callHeap#_3303[this#944, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_3303[this#944, AVLTreeNode.right] == null, 0, callHeap#_3303[callHeap#_3303[this#944, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#944, AVLTreeNode.balanceFactor] == (ite(callHeap#_3303[this#944, AVLTreeNode.left] == null, 0, callHeap#_3303[callHeap#_3303[this#944, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_3303[this#944, AVLTreeNode.right] == null, 0, callHeap#_3303[callHeap#_3303[this#944, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_3327 := Mask;
  havoc exhaleHeap#_3326;
  assert {:msg "  845.2: The postcondition at 870.11 might not hold. The expression at 870.11 might not evaluate to true."} !(r#72 == null);
  assert {:msg "  845.2: The postcondition at 876.11 might not hold. The expression at 876.11 might not evaluate to true."} (Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#72, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height] + 1));
  assert {:msg "  845.2: The postcondition at 877.11 might not hold. The expression at 877.11 might not evaluate to true."} Seq#Equal(Heap[r#72, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assert {:msg "  845.2: The postcondition at 871.11 might not hold. The permission at 871.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  845.2: The postcondition at 871.11 might not hold. Insufficient fraction at 871.11 for AVLTreeNode.valid."} (Fractions(100) <= exhaleMask#_3327[r#72, AVLTreeNode.valid][perm$R]) && ((Fractions(100) == exhaleMask#_3327[r#72, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_3327[r#72, AVLTreeNode.valid][perm$N]));
  exhaleMask#_3327[r#72, AVLTreeNode.valid] := exhaleMask#_3327[r#72, AVLTreeNode.valid][perm$R := exhaleMask#_3327[r#72, AVLTreeNode.valid][perm$R] - Fractions(100)];
  if (!CanRead(exhaleMask#_3327, SecMask, r#72, AVLTreeNode.valid)) {
    assume Heap[r#72, AVLTreeNode.valid] < exhaleHeap#_3326[r#72, AVLTreeNode.valid];
  }
  assume IsGoodMask(exhaleMask#_3327);
  assume wf(Heap, exhaleMask#_3327, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  845.2: The postcondition at 872.11 might not hold. The permission at 872.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  845.2: The postcondition at 872.11 might not hold. Insufficient fraction at 872.11 for AVLTreeNode.height."} (Fractions(50) <= exhaleMask#_3327[r#72, AVLTreeNode.height][perm$R]) && ((Fractions(50) == exhaleMask#_3327[r#72, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_3327[r#72, AVLTreeNode.height][perm$N]));
  exhaleMask#_3327[r#72, AVLTreeNode.height] := exhaleMask#_3327[r#72, AVLTreeNode.height][perm$R := exhaleMask#_3327[r#72, AVLTreeNode.height][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_3327);
  assume wf(Heap, exhaleMask#_3327, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  845.2: The postcondition at 873.11 might not hold. The permission at 873.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  845.2: The postcondition at 873.11 might not hold. Insufficient fraction at 873.11 for AVLTreeNode.keys."} (Fractions(50) <= exhaleMask#_3327[r#72, AVLTreeNode.keys][perm$R]) && ((Fractions(50) == exhaleMask#_3327[r#72, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_3327[r#72, AVLTreeNode.keys][perm$N]));
  exhaleMask#_3327[r#72, AVLTreeNode.keys] := exhaleMask#_3327[r#72, AVLTreeNode.keys][perm$R := exhaleMask#_3327[r#72, AVLTreeNode.keys][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_3327);
  assume wf(Heap, exhaleMask#_3327, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  845.2: The postcondition at 874.11 might not hold. The permission at 874.11 might not be positive."} Fractions(50) > 0;
  assert {:msg "  845.2: The postcondition at 874.11 might not hold. Insufficient fraction at 874.11 for AVLTreeNode.balanceFactor."} (Fractions(50) <= exhaleMask#_3327[r#72, AVLTreeNode.balanceFactor][perm$R]) && ((Fractions(50) == exhaleMask#_3327[r#72, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_3327[r#72, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_3327[r#72, AVLTreeNode.balanceFactor] := exhaleMask#_3327[r#72, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_3327[r#72, AVLTreeNode.balanceFactor][perm$R] - Fractions(50)];
  assume IsGoodMask(exhaleMask#_3327);
  assume wf(Heap, exhaleMask#_3327, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_3327;
  assume IsGoodExhaleState(exhaleHeap#_3326, Heap, Mask, SecMask);
  Heap := exhaleHeap#_3326;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  845.2: Method might lock/unlock more than allowed."} (forall lk#_3332: ref :: {Heap[lk#_3332, held]} {Heap[lk#_3332, rdheld]} (((0 < Heap[lk#_3332, held]) == (0 < old(Heap)[lk#_3332, held])) && (Heap[lk#_3332, rdheld] == old(Heap)[lk#_3332, rdheld])) || false);
  assert {:msg "  845.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
